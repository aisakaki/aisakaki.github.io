<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>配分函数</title>
    <url>/2019/10/18/%E9%85%8D%E5%88%86%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><em>本文为 Deep Learning Ch.18 学习后总结的笔记</em></p>
<h2 id="配分函数"><a href="#配分函数" class="headerlink" title="配分函数"></a>配分函数</h2><p>配分函数是统计物理学中常使用的概念，在前面<a href="[https://aisakaki.com/2019/10/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B/](https://aisakaki.com/2019/10/11/深度学习中的结构化概率模型/">深度学习的结构化概率模型</a> )中出现了配分函数：$p(x)=\frac{1}{Z}\hat{p}(\vec x)$</p>
<p>$x$为模型中的所有参数组成的向量，可以记为：</p>
<script type="math/tex; mode=display">
p(x)=\frac{1}{Z}\hat{p}(x)</script><p>为归一化此式子需要求</p>
<script type="math/tex; mode=display">
Z=\int \hat{p}(x;\theta)dx</script><script type="math/tex; mode=display">
or,Z=\sum_{\vec x}\hat{p}(x;\theta)</script><p>对其求对数似然梯度：</p>
<script type="math/tex; mode=display">
\therefore \nabla_{MLE}=\nabla_\theta \log \hat{p}(x;\theta)=\nabla_\theta \log \frac{\hat{p}(x)}{\int \hat{p}(x;\theta)dx}</script><script type="math/tex; mode=display">
=\nabla_\theta\log \hat{p}(x)-\nabla_\theta\log \int \hat{p}(x;\theta)dx</script><p>前半部分分为正相，后半部分称为负相</p>
<a id="more"></a>
<p>正相很好解决，对于一个mini-batch中的样本直接计算即可</p>
<p>负相就非常难或者无法计算了，可以看到$\int \hat{p}(x;\theta)dx$实际上就是对概率图网络中的所有可能出现的$\vec x$求积分</p>
<h2 id="MCMC求负相"><a href="#MCMC求负相" class="headerlink" title="MCMC求负相"></a>MCMC求负相</h2><p>从离散表达式开始推导</p>
<script type="math/tex; mode=display">
\nabla_\theta \log Z=\frac{\nabla_\theta Z}{Z}</script><script type="math/tex; mode=display">
=\frac{\nabla_\theta\sum_{\vec x}\hat{p}(x;\theta)}{Z}</script><script type="math/tex; mode=display">
=\frac{\sum_{\vec x}\nabla_\theta\hat{p}(x)}{Z}</script><p>显然$e^{\log \hat{p}(x)}=\hat{p}(x)$，</p>
<script type="math/tex; mode=display">
\therefore \nabla_\theta \log Z=\frac{\sum_{\vec x}e^{\log \hat{p}(x)}\nabla_\theta\hat{p}(x)}{Z}</script><script type="math/tex; mode=display">
=</script>]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>统计物理学</tag>
      </tags>
  </entry>
  <entry>
    <title>绽放之后</title>
    <url>/2019/10/17/%E7%BB%BD%E6%94%BE%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<div align="MIDDLE">
<iframe src="//player.bilibili.com/player.html?aid=71516775&cid=123923582&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="564"> 
</iframe>
</div>
<div style="text-align: center"><i>如花火般短暂，如花火般绚烂</i></div>
]]></content>
      <categories>
        <category>Anime</category>
      </categories>
      <tags>
        <tag>青春</tag>
        <tag>新海诚式</tag>
      </tags>
  </entry>
  <entry>
    <title>失眠飞行</title>
    <url>/2019/10/14/%E5%A4%B1%E7%9C%A0%E9%A3%9E%E8%A1%8C/</url>
    <content><![CDATA[<p><img src="//aisakaki.com/2019/10/14/失眠飞行/0.jpg" alt="0"></p>
<p><div style="text-align: center"><i>我想和你 一起闯进森林潜入海底</i></div></p>
<p><div style="text-align: center"><i>我想和你 一起看日出到日落天气</i></div></p>
<p><div style="text-align: center"><i>我想和你穿过格林威治和时间飞行</i></div></p>
<p><div style="text-align: center"><i>我想见你 穿过教堂和人海拥抱你</i></div></p>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1394847947&auto=0&height=66"></iframe><br>真好听，可已经不是YH了</p>
]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>hanser</tag>
        <tag>kb</tag>
      </tags>
  </entry>
  <entry>
    <title>寒露</title>
    <url>/2019/10/13/%E5%AF%92%E9%9C%B2/</url>
    <content><![CDATA[<p>眼眸里流动着窗外的街景，打了一个寒战之后才意识到，深秋的冰冷正从自己倚靠在车窗上的头侧侵袭而来。</p>
<p>四面八方依稀传来的的轮胎与湿漉漉的地面的拍打声不绝于耳，淅淅沥沥的雨点与溅起的水花构成车外寂寥的白噪，在白茫茫的天际下，这座庞大的城市显得格外的孤独。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>秋</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯游戏策划培训课堂笔记-week1</title>
    <url>/2019/10/13/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E7%AD%96%E5%88%92%E5%9F%B9%E8%AE%AD%E8%AF%BE%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0-week1/</url>
    <content><![CDATA[<p><em>很幸运能通过选拔参与腾讯的策划培训，时间是每周日下午，除此之外也打算顺便玩玩虚幻引擎</em></p>
<p><strong>week 1 揭开游戏设计师的神秘面纱—开课典礼</strong></p>
<p>下周开始组队研发一款mini-game</p>
<h2 id="策划"><a href="#策划" class="headerlink" title="策划"></a>策划</h2><p>策划：制定游戏规则，怎么玩</p>
<ol>
<li><strong>想好</strong>要做什么样的游戏</li>
<li><strong>沟通</strong>获得各种制作资源</li>
<li><p><strong>组合</strong>资源成为想要的游戏</p>
<a id="more"></a>
</li>
</ol>
<h2 id="电子游戏研发流程综述"><a href="#电子游戏研发流程综述" class="headerlink" title="电子游戏研发流程综述"></a>电子游戏研发流程综述</h2><ol>
<li><p>提炼游戏创意</p>
<ul>
<li><p>语言简洁精炼</p>
</li>
<li><p>眼前一亮，令人深刻</p>
</li>
<li><p><strong>聚焦用户体验</strong></p>
</li>
</ul>
<p>方法：头脑风暴</p>
<p>然后分类整理，进行评估，初步筛选可行，进一步评估</p>
</li>
<li><p>设计游戏概念</p>
<p>基于游戏创意进行概念设计</p>
<p>可以组成游戏概念设计小组，1~2人</p>
<p>概念：平台，目标用户，类型，描述，玩法，卖点，竞品，美术概念等</p>
</li>
<li><p>制作纸面原型/物理原型</p>
<p>帮助思考，高效沟通，快速试错</p>
<p>纸面原型相比数字原型优点在于成本低，直观，效率高，便于试错</p>
</li>
<li><p>自己试玩原型</p>
<ul>
<li><p>设定规则集</p>
</li>
<li><p>确保运行良好</p>
<p>游戏逻辑合乎常理，所有游戏事件，结果，游戏挑战的平衡，游戏乐趣，顺序呈现</p>
</li>
<li><p>修正结构性问题</p>
</li>
</ul>
</li>
<li><p>模拟测试易用性和游戏性</p>
</li>
<li><p>数字化开发</p>
<ul>
<li><p>构建内容</p>
<p>将纸面原型的逻辑和内容进行数字化</p>
<p>构建内容不要超过游戏内容的20%</p>
<p>创建的游戏内容，未必会很好玩</p>
<p>少构建些内容，万一不好玩造成损失也能够让损失最小化</p>
</li>
<li><p>替代素材</p>
<p>图像，人物简单化</p>
<p>关卡素材足够简单</p>
</li>
<li><p>保证运作</p>
</li>
<li><p>团队协作</p>
<p>策划团队（枢纽），美术团队，程序团队，测试团队</p>
</li>
<li><p>版本管理</p>
<p>vs,SVN,git</p>
</li>
<li><p>需求管理</p>
<p>TAPD(腾讯敏捷项目管理平台)</p>
</li>
<li><p>游戏引擎是如何工作的</p>
<p>略</p>
</li>
</ul>
</li>
<li><p>数字测试易用性和游戏性</p>
<ul>
<li>半结构化测试</li>
<li>检测任务完成情况</li>
<li>收集测试数据</li>
</ul>
<p>技巧：开放式提问，提前设问，有声思维</p>
</li>
<li><p>修正游戏玩法和内容</p>
<ul>
<li>基于用户测试</li>
<li>关注系统问题</li>
<li>从大到小修正</li>
<li>完成第一个迭代，可以玩的数字版本</li>
</ul>
</li>
<li><p>创建下一个迭代</p>
<p>进入<strong>螺旋开发模型</strong> The Spiral Model（3~9循环）</p>
<p>持续迭代过程中，也在不断对游戏的玩法，美术进行迭代</p>
</li>
<li><p>打磨游戏</p>
<ul>
<li>打磨核心元素</li>
<li>打磨细节</li>
<li>提升美术表现品质（所有的UI，素材，人物，图像，场景，道具，动画效果等等）</li>
<li>检查文字</li>
</ul>
</li>
<li><p>继续打磨</p>
<ul>
<li>自己当新手试玩</li>
<li>找旁人试玩</li>
</ul>
</li>
<li><p>再三打磨，直到出类拔萃</p>
<ul>
<li>将自己当作某个别人</li>
<li>终于有一天，看吐了…</li>
</ul>
</li>
<li><p>完整测试</p>
<ul>
<li>真实用户</li>
<li>用户调研</li>
</ul>
</li>
<li><p>修正调优</p>
<ul>
<li>修正遗留漏洞</li>
<li>微调提升玩法，手感</li>
<li>do best</li>
</ul>
</li>
<li><p>版本发布（运营策划这个时候最忙）</p>
<ul>
<li>发布完整版本</li>
<li>版本跟踪</li>
</ul>
</li>
<li><p>打磨和打补丁</p>
</li>
</ol>
<h2 id="案例学习：尼山萨满（By-Next-Studio）"><a href="#案例学习：尼山萨满（By-Next-Studio）" class="headerlink" title="案例学习：尼山萨满（By Next Studio）"></a>案例学习：尼山萨满（By Next Studio）</h2><p>略</p>
<h2 id="电子游戏类型介绍-Video-Game-Genres"><a href="#电子游戏类型介绍-Video-Game-Genres" class="headerlink" title="电子游戏类型介绍(Video Game Genres)"></a>电子游戏类型介绍(Video Game Genres)</h2><p>Genres 来自法语</p>
<p>游戏类型，游戏流派</p>
<p><strong>基于游戏玩法交互的差异来分类</strong></p>
<p>不是基于视觉或叙事差异，不像电影或者小说按照题材内容来分类</p>
<p>类型的本质：<strong>世上本没有路，走的人多了，就成了路………</strong></p>
<p>分类并无统一标准，只是约定俗成方便沟通</p>
<p><strong>几大类：</strong></p>
<ul>
<li><p><strong>动作</strong> <em>Action</em></p>
<p>强调物理挑战，手眼协调，反应时间</p>
<p>细分：平台，射击，格斗，清版，生存</p>
</li>
<li><p><strong>冒险</strong> <em>Adventure</em></p>
<p>嵌入在叙事框架中的谜题，战斗和行动挑战有限</p>
<p>细分：文字冒险，视觉小说，图形冒险，互动电影，混合冒险</p>
</li>
<li><p><strong>动作冒险</strong> <em>Action-Adventures</em></p>
<p>物理挑战，手眼协调，反应时间 + 故事情节，众多角色，储存系统</p>
<p>细分：潜行，恐怖，类GTA，银河恶魔城，通常</p>
</li>
<li><p><strong>角色扮演</strong> <em>Role-Playing</em></p>
<p>玩家扮演一个或多个角色</p>
<p>沉浸在给定世界中</p>
<p>细分：动作，回合，大型多人在线，类rogue，战术，沙盒，地下城……</p>
</li>
<li><p><strong>模拟</strong> <em>Simulation</em></p>
<p>从现实生活中复制各种活动，用于各种目的</p>
<p>细分：经营，生活，交通工具</p>
</li>
<li><p><strong>策略</strong> <em>Strategy</em></p>
<p>强调思维技巧，计划性，针对1~N个对手，很少涉及物理挑战</p>
<p>细分：4X（eXplore,eXpand,eXploit,eXterminate)（如文明），炮术，即时战略，即时战术，多人在线战术竞技，塔防，回合制策略（TBS），回合制战略，战争，大型战略</p>
</li>
<li><p><strong>运动</strong> <em>Sports</em></p>
<p>细分：竞速，体育，竞技，体育格斗</p>
</li>
<li><p><strong>其他</strong> <em>Others</em></p>
<p>聚会，卡牌，益智，等等等等</p>
</li>
</ul>
<p><em>Tips:</em> </p>
<ol>
<li><p>文字冒险与视觉小说的区别</p>
<p>前者如BatMUD（鼻祖级MUD）</p>
<p>后者如一票日本Galgame（<em>演示：交响乐之雨</em>），是以各种多媒体为主，图片为主的</p>
</li>
<li><p>类银河恶魔城</p>
<p>突破了传统平台游戏的局限性，在传统平台游戏的基础上，任天堂的银河战士引入了非线性卷轴设计，KONOMI的恶魔城引入了RPG的部分系统，以此诞生的经典游戏类型。 <em>演示 : Cave Story By Pixel Studio</em></p>
</li>
<li><p>炮术游戏</p>
<p>俗称打炮游戏（误），如百战天虫WMD （2016 By Team17）</p>
</li>
</ol>
<hr>
<p>课后作业略</p>
<p>书籍推荐：<em>The Art of Game Design</em></p>
<p>《全景探秘 游戏设计艺术》（中文版）</p>
]]></content>
      <categories>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>蒙特卡罗方法</title>
    <url>/2019/10/12/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="采样与蒙特卡罗方法"><a href="#采样与蒙特卡罗方法" class="headerlink" title="采样与蒙特卡罗方法"></a>采样与蒙特卡罗方法</h2><p>为什么要采样？比如假设我们要计算积分$\int_a^bh(x)dx$，我们需要枚举$x∈[a,b]$，这是非常困难的；又比如使用mini-batch进行模型训练的时候需要采样</p>
<p>蒙特卡罗采样的思想就是在这种很难进行枚举的时候，使用采样来近似它。这种想法<strong>把和或者积分视作某分布下的期望，然后通过估计对应的平均值来近似这个期望</strong>（也就是说把原函数$h(x)$分解成某个函数与概率密度函数$p(x)$的乘积，即$f(x)$在$p(x)$分布上的均值）</p>
<script type="math/tex; mode=display">
s = \int_a^bh(x)dx=\int_a^bp(x)f(x)dx=E_p(f(x))</script><p>从样本集中抽取$n$个样本$(x_1,\cdots,x_n)～p(x)$（同期望证明略，使用大数定理可证得）来近似之，则</p>
<script type="math/tex; mode=display">
\int_a^bh(x)dx=E_p(f(x))≈\frac{1}{n}\sum_{i=1}^nf(x_i)</script><p>蒙特卡罗方法是一种随机模拟技术</p>
<h2 id="马尔科夫链蒙特卡罗方法（MCMC）"><a href="#马尔科夫链蒙特卡罗方法（MCMC）" class="headerlink" title="马尔科夫链蒙特卡罗方法（MCMC）"></a>马尔科夫链蒙特卡罗方法（MCMC）</h2><p>Markov Chain Monte Carlo</p>
<p>马尔科夫链是<em>随机过程</em>中的重要角色，不多赘述</p>
<p>马尔科夫过程<strong>各态遍历性</strong>需要满足：①非周期  ②不可约</p>
<p>非周期即存在某个取值从它出发转移回自身所需要的转移次数总是整数$d(&gt;1)$的倍数，使得能够“连续”转移，这保证了马尔科夫过程的连续性，否则必须走特定步长（即周期）才能转移，使得马尔科夫过程不连续</p>
<p>不可约即为任意两个取值之间总是能以非零的概率相互转移</p>
<p>若马尔科夫过程是各态遍历的，无论初始值为何，随机变量的最终取值分布会收敛于一个唯一的平稳分布$\pi^*$</p>
<script type="math/tex; mode=display">
\lim_{t\to ∞ }\pi^{(0)}P^t=\pi^*</script><p><strong>意味着马尔科夫过程经过多次转以后，随机变量的分布会一直逼近该平稳分布</strong></p>
<p>可以从这个角度证明：</p>
<script type="math/tex; mode=display">
\pi_t=P^t\pi_0=(Pdiag(\lambda)P^{-1})^t\pi_0=Pdiag(\lambda)^tP^{-1}\pi_0</script><p>可见这个过程将导致$P$中不为1的特征值全部衰减到0，因此该过程就收敛到平稳分布</p>
<script type="math/tex; mode=display">
\pi^*=\pi P</script><p>得到一个特征向量方程，收敛之后的$\pi^*$是特征值为1所对应的特征向量</p>
<p>于是就可以<strong>利用马尔科夫链来进行蒙特卡罗估计</strong>，这类算法被称为<strong>马尔科夫链蒙特卡罗方法（MCMC）</strong></p>
 <a id="more"></a>
<p>由于要保证各态遍历性，于是MCMC方法<strong>最适用于基于能量的模型</strong>（见上一篇笔记）</p>
<p>马尔科夫链的<strong>磨合过程</strong>：运行马尔科夫过程直到收敛</p>
<p>马尔科夫过程中的<strong>混合时间</strong>：在未收敛前的那段时间</p>
<p>连续的马尔科夫链也叫<strong>哈里斯链</strong></p>
<p>难以预测马尔科夫链是否收敛，目前方法：</p>
<p>①看$P$的特征值是否趋近于0 （但通常$P^t$计算难度极大，难以表示）</p>
<p>②启发式方法（手动检查样本；衡量样本间的相关性）</p>
<p><strong>但注意一个问题：在一个马尔科夫链的一个抽样序列无法完全表达均衡分布！</strong></p>
<p>因为在一个马尔科夫链达到平稳状态后，两个连续样本之间会<strong>高度相关</strong>。（在马尔科夫过程平稳后，$P$使得每次转移使得样本的分布不变，但是$P$会改变每一次转移后的样本的形态，但同一时间下的样本形态是高度相关的）</p>
<p>解决办法之一是间隔抽样，另一个是使用<strong>多条马尔科夫链</strong>，每个样本从不同的马尔科夫链抽样，在深度学习中的通用实践是选取的马尔科夫链数目和小批量中的样本数相近。</p>
<h2 id="如何采样？（采样方法）"><a href="#如何采样？（采样方法）" class="headerlink" title="如何采样？（采样方法）"></a>如何采样？（采样方法）</h2><p>对于$uniform(0,1)$，我们可以使用<strong>线性同余发生器算法</strong>LCG：$R=(A*R+B)\%M$，推导略</p>
<p>对于常见的概率分布，可以使用<strong>逆采样</strong>方法，将其他概率分布<strong>映射到</strong>$uniform(0,1)$，推导略（大体思路是将CDF的反函数代入$uniform(0,1)$的概率密度函数）</p>
<p>这需要是常见概率分布，因为必须要求累计概率分布CDF可以求逆，所以</p>
<p>对于非常见概率分布，可以使用<strong>接受—拒绝采样</strong>，但对MCMC使用接受—拒绝采样效果并不好</p>
<p>（以上的采样方法可以以后单独写篇笔记）</p>
<p><strong>那MCMC该如何采样呢？</strong>我们需要采样目标概率分布$p(x)$，而目标概率分布是由转移概率决定的，所以也就是说我们要构造一个转移概率矩阵$P$，使得$p(x)$恰好是我们想要的目标概率分布</p>
<h2 id="Metropolis-Hasting采样"><a href="#Metropolis-Hasting采样" class="headerlink" title="Metropolis Hasting采样"></a>Metropolis Hasting采样</h2><p>为了满足能够构造一个转移概率矩阵$P$，使得$p(x)$<strong>恰好是我们想要的目标概率分布</strong>，我们设定马尔科夫链满足<strong>细致平稳条件</strong></p>
<script type="math/tex; mode=display">
\pi(i)P_{ij}=\pi(j)P_{ji}, \forall i,j</script><p>若满足，则马尔科夫链为平稳分布。</p>
<p>细致平稳条件可理解为从$i$状态转移到$j$状态的付出消耗与从$j$转移回$i$的吸收消耗相同，所以状态$i$上的概率质量$\pi(i)$是稳定的。</p>
<p>那么一般情况下</p>
<script type="math/tex; mode=display">
p(i)q(i,j)≠p(j)q(j,i)</script><p>$Q$为转移矩阵，$q$为转移概率。为了强行让它相等，即满足细致平稳条件，则设计一个$\alpha$（称作跳转的<strong>接受率</strong>）使得$\alpha(i,j)=p(j)q(j,i),\alpha(j,i)=p(i)q(i,j)$（对称性）</p>
<script type="math/tex; mode=display">
p(i)q(i,j)\alpha(i,j)=p(j)q(j,i)\alpha(j,i)</script><p>$\hat{Q}(i,j)=q(i,j)\alpha(i,j),\hat{Q}(j,i)=q(j,i)\alpha(j,i)$</p>
<p>$q$称为<strong>提议概率</strong>，$Q$称为提议转移矩阵，<strong>自己选择一种简单的分布即可</strong></p>
<p>于是原来的转移矩阵$Q$变成了现在可以保证细致平稳条件的转移矩阵$\hat{Q}$，此转移矩阵的平稳分布就是$p(x)$了</p>
<p>以上称为Metropolis抽样</p>
<p><strong>那么$\alpha$该如何更好地取值呢？</strong>太小的话会导致拒绝率太高，收敛速度太慢。发现如果在等式两边同时扩大相同的倍数，等式依然成立，于是想到将等式两边同比例放大使得最大的一边放大到1（概率最大为1），即</p>
<script type="math/tex; mode=display">
\alpha^*(i,j)=\min\{\frac{\alpha(j,i)}{\alpha(i,j)},1\}=\min\{\frac{p(j)q(j,i)}{p(i)q(i,j)},1\}</script><p>（这里的推导：当$\alpha(i,j)&gt;\alpha(j,i),则\alpha(i,j)先到1，\alpha^<em>(j,i)=\frac{1}{\alpha(i,j)}·\alpha(j,i)&lt;1$ <em>*缩放</em></em></p>
<p>当$\alpha(j,i)&gt;\alpha(i,j),则\alpha(j,i)先到1，\alpha^<em>(i,j)=\frac{\alpha(i,j)}{\alpha(j,i)}$ <em>*缩放</em></em></p>
<p>整合上两式记得上面的等式）</p>
<p><strong>于是</strong>$p(x)$是<strong>目标平稳概率分布，自设已知</strong>；$q(x)$为<strong>提议概率分布，自设已知</strong>，那么就可以求出<strong>转移概率</strong>$\alpha$了</p>
<p>从$uniform(0,1)$中采样$u$，如果$u&lt;\alpha(i,j)$，（相当于在拒绝采样中，随机采样点落入函数范围内），则该跳转成功，否则该跳转失败，以此迭代（这里使用<strong>接受-拒绝采样算法的思想</strong>，用提议转移矩阵$Q$去求得转移矩阵$\hat{Q}$）</p>
<p>这就是Metropolis Hasting采样算法</p>
<p>算法如下：</p>
<p><img src="//aisakaki.com/2019/10/12/蒙特卡罗方法/0.png" alt="0"></p>
<h2 id="Gibbs采样（深度学习中的最佳选择）"><a href="#Gibbs采样（深度学习中的最佳选择）" class="headerlink" title="Gibbs采样（深度学习中的最佳选择）"></a>Gibbs采样（深度学习中的最佳选择）</h2><p>针对高维的情形，发现在高维情况下自然成立一个式子使得细致平稳条件成立，也就可以不拒绝，使得收敛迅速。Gibbs采样每一步都只更新变量的一个小部分</p>
<p>对平面上任意两点$X,Y$</p>
<script type="math/tex; mode=display">
p(X)=Q(X,Y)=p(Y)Q(Y,X)</script><p><img src="//aisakaki.com/2019/10/12/蒙特卡罗方法/1.jpg" alt="0"></p>
<p>​    <img src="//aisakaki.com/2019/10/12/蒙特卡罗方法/2.jpg" alt="0"></p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>采样</tag>
        <tag>马尔科夫链</tag>
        <tag>数学</tag>
        <tag>统计数学</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习中的结构化概率模型</title>
    <url>/2019/10/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><em>本文为 Deep Learning Ch.16 学习后整理的笔记</em></p>
<h2 id="结构化概率模型"><a href="#结构化概率模型" class="headerlink" title="结构化概率模型"></a>结构化概率模型</h2><p>概率图模型（PGM）描述概率有助于减少表示概率分布，学习和推断的成本。间接表示间接关系而不是直接表示</p>
<h2 id="有向图模型-信念网络-贝叶斯网络"><a href="#有向图模型-信念网络-贝叶斯网络" class="headerlink" title="有向图模型=信念网络=贝叶斯网络"></a>有向图模型=信念网络=贝叶斯网络</h2><p>方向仅表示依赖关系而不表明如何依赖</p>
<p>通过有向无环图和一系列<strong>局部条件概率分布</strong>定义</p>
<script type="math/tex; mode=display">
p(x)=\prod_ip(x_i|P(x_i))</script><p>其中$P(x_i)$表示结点$x_i$的所有父节点。</p>
<h2 id="无向图模型-马尔可夫随机场-马尔科夫网络"><a href="#无向图模型-马尔可夫随机场-马尔科夫网络" class="headerlink" title="无向图模型=马尔可夫随机场=马尔科夫网络"></a>无向图模型=马尔可夫随机场=马尔科夫网络</h2><p>对无向模型$M$中的一个团$C$称为一个<strong>因子</strong>$\phi(C)$，也叫<strong>团势能</strong>，<strong>势能函数</strong></p>
<p>它们一起定义了<strong>未归一化概率函数</strong>：</p>
<script type="math/tex; mode=display">
p(\hat{x})=\prod_{C∈M}\phi(C)</script><p>(图的一个团是图中结点的一个子集，并且其中的点是全连接的)</p>
<p>为了使得未归一化概率函数归一化，我们需要使用对应的归一化概率分布</p>
<script type="math/tex; mode=display">
p(x)=\frac{1}{Z}\hat{p(x)}</script><p>其中$Z$是使得所有概率之和或者积分为1的常数，且满足</p>
<script type="math/tex; mode=display">
Z=\int \hat{p}(x)dx</script><p>归一化常数$Z$被称为<strong>配分函数</strong>。计算$Z$需要对$x$的所有可能状态求联合概率分布，所以通常非常难计算，于是可以用一些近似方法求得。</p>
<p>但有时候积分是发散的，不存在一个$F(x)$，这时候$Z$就不存在</p>
<p>但注意如果指定发散函数的某定义域内是收敛的，那是OK的</p>
<p>无向图在<strong>表示上</strong>存在模糊性，即“多大的团？”，这时候可以引入<strong>因子图</strong>解决，它将随机变量绘为圆形，将未归一化概率函数因子$\phi$绘为方形，仅当随机变量对应该函数因子的时候存在连接，连接该函数的随机变量构成一个团</p>
<h2 id="基于能量的模型-Energy-Based-model-EBM"><a href="#基于能量的模型-Energy-Based-model-EBM" class="headerlink" title="基于能量的模型(Energy-Based model,EBM)"></a>基于能量的模型(Energy-Based model,EBM)</h2><p>无向模型依赖一个假设$\forall x,\hat{p}(x)&gt;0$，使得这个条件满足的一个简单方式是使用EBM</p>
<script type="math/tex; mode=display">
\hat{p}(x)=e^{-E(x)}</script><p>服从该形式的任意分布都是<strong>玻尔兹曼分布</strong>的一个实例，也因此我们把许多基于能量的模型成为<strong>玻尔兹曼机</strong></p>
<p>$E(x)$被称作<strong>能量函数</strong>(energy function)</p>
<p>由于$e^{(a+b)}=e^a·e^b$，于是可以发现无向模型中不同的团对应于能量函数的不同项，也就是说<strong>EBM只是一种特殊的马尔科夫网络</strong>，这种网络满足求幂使能量函数中的每项对应于不同团的一个影子。</p>
<p>比如对于一个MAP d-a-b-e,b-e,e-f(只写了连接关系)，通过为每个团选择适当的能量函数$E(a,b,c,d,e,f)$可以写成$E_{a,b}(a,b)+E_{b,c}(b,c)+E_{a,d}(a,d)+E_{b,e}(b,e)+E_{e,f}(e,f)$</p>
<p>能量函数可以视为<strong>专家之积</strong>，其中每一项看作决定一个特定的软约束是否满足的“专家”</p>
<p>公式中幂的负号只是为了保持机器学习文献与物理学文献之间的兼容性（能量无符号），对于机器学习来说可以自由决定符号</p>
<p>很多对概率模型进行操作的算法是计算$\log p(x)$的，于是对于具有潜变量$h$的EBM，这些算法有时会将该量的负数称为<strong>自由能</strong>(free energy)：</p>
<script type="math/tex; mode=display">
F(x)=-\log \sum_h e^{-E(x,h)}</script> <a id="more"></a>
<h2 id="分离与d-分离—条件独立"><a href="#分离与d-分离—条件独立" class="headerlink" title="分离与d-分离—条件独立"></a>分离与d-分离—条件独立</h2><p>无向图中隐含的条件独立性称为<strong>分离</strong>，有向图中则被称为<strong>d-分离</strong>。（d代表依赖）</p>
<p>如何判断哪些变量子集（d-）分离/彼此条件独立？</p>
<p> ①两个随机变量之间没有路径，或</p>
<p> ②两个随机变量之间<strong>所有路径</strong>都包含<strong>可观测变量</strong></p>
<p>举个例子：一个房子的好坏（C）是由大小（A）和装潢（B）决定的，此时的图结构为A-&gt;C,B-&gt;C，如果我们知道了这个房子是好房子，也就是C为可观测变量（条件），那么<strong>A和B是C条件下的独立随机变量</strong></p>
<p>记$a⊥b|c$表示给定$c$条件下$a$与$b$条件独立</p>
<blockquote>
<p>关于图模型条件独立的推导可以看这篇文章 <a href="https://my.oschina.net/liyangke/blog/2986515" target="_blank" rel="noopener">https://my.oschina.net/liyangke/blog/2986515</a></p>
</blockquote>
<h2 id="有向图和无向图的转化"><a href="#有向图和无向图的转化" class="headerlink" title="有向图和无向图的转化"></a>有向图和无向图的转化</h2><ol>
<li><p>有向模型和无向模型的一个重要区别在于有向模型是通过从起始点的概率分布直接定义的，而无向模型的定义显得更加宽松，通过$\phi$函数转化为概率分布定义</p>
</li>
<li><p>有向图可以使用<strong>不道德图结构</strong>而无向图不行</p>
<p>将有向模型图转换为无向模型图：①有向边变无向边   ②对于<strong>不道德</strong>（immorality)情况(a$\to$c，b$\to$c）需要在不道德的节点互相连线，变成<strong>道德图</strong>。由于道德化的过程中会加入很多边，因而会损失一些独立性条件</p>
</li>
<li><p>无向图可以使用<strong>环</strong>结构而有向图不行</p>
<p>将环结构的无向图转化为有向图需要添加<strong>弦</strong>（环序列中任意两个非连续变量的连接），转化后的图称为<strong>弦图</strong>或<strong>三角形化图</strong>。但如果存在长度大于3的环，则转化过来会损失独立性条件。（注意不能出现有向环，否则无法定义有效的有向概率模型）</p>
</li>
</ol>
<h2 id="从图模型中采样"><a href="#从图模型中采样" class="headerlink" title="从图模型中采样"></a>从图模型中采样</h2><ol>
<li><p>有向图：原始采样，根据拓扑排序顺序采样。</p>
<p>缺点：不是每次采样都是条件采样操作</p>
</li>
<li><p>无向图：①转化为有向图作原始采样</p>
<p>​                ②Gibbs采样</p>
</li>
</ol>
<hr>
<p>有已知值的变量被称为显变量，而值未被观察到的变量被称为隐变量</p>
<p>深度学习模型可以看作一类特殊的图概率模型，拥有大量的<strong>潜变量</strong>，且在设计的时候不表示任何特定含义；而传统模型大多使用高阶项和结构学习来捕获变量之间复杂的非线性作用，即使有潜变量，数量也通常很少，且会被赋予特定的含义</p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>Autoencoder</title>
    <url>/2019/10/09/Autoencoder/</url>
    <content><![CDATA[<h2 id="Autoencoder"><a href="#Autoencoder" class="headerlink" title="Autoencoder"></a>Autoencoder</h2><p>AE可以看为一个单隐藏层的NN</p>
<p>目标函数为重构误差（reconstruction error)，目标是使得解码器的输出与编码器的输入同分布</p>
<p><strong>隐藏层单元数&lt;输入层单元数</strong>即可用于降维，如果编码的激活函数为线性函数就成为了<strong>PCA</strong></p>
<p>但现在一般<strong>隐藏层单元数&gt;=输入层单元数</strong>比较多，这样可以挖掘更多高维特征，但容易造成神经网络的输出为输入的直接“复制”，为了解决这个问题，引入了<strong>正则</strong>和<strong>随机性</strong>等等，且可以组合使用</p>
<h2 id="Regularized-Autoencoder"><a href="#Regularized-Autoencoder" class="headerlink" title="Regularized Autoencoder"></a>Regularized Autoencoder</h2><p>正则项自编码器</p>
<p>神经网络的输入直接“复制”输出的一个具体表现就在于一些神经元权重过大，使得神经网路直接变成直连通路</p>
<p>于是可以直接向损失函数正则项</p>
<script type="math/tex; mode=display">
L(x,g(f(x)))+\Omega(h)</script><p><strong>实现方法</strong>：使用传统的加入正则项实现方法</p>
<h2 id="Sparse-Autoencoder"><a href="#Sparse-Autoencoder" class="headerlink" title="Sparse Autoencoder"></a>Sparse Autoencoder</h2><p>稀疏自编码器</p>
<p>使得参数变得稀疏，避免过多神经元被激活</p>
<p>引入稀疏度公式</p>
<script type="math/tex; mode=display">
\hat{\rho}_j = \frac{1}{N} \Sigma_{i=1}^N h_j(x^{(i)})</script><p>此公式计算了第$j$个神经元在训练集$\{x^{i}\}$上激活度的平均值，那么就可以取一个足够小的$\rho$，保证$\hat{\rho}_j=\rho,j=1,2,3,\cdots$</p>
<p>对于$\hat{\rho}_j&gt;&gt;\rho$，对其使用KL散度进行惩罚，KL散度可以用于衡量两个分布的相似度（在前面这篇论文的阅读笔记：<a href="https://aisakaki.com/2019/07/30/Examples/">Explaining and Harnessing Adversarial Examples</a>中使用到了这个数学工具。</p>
<p>向损失函数中加入KL散度</p>
<script type="math/tex; mode=display">
J=L(x,g(f(x)))+\Sigma_{j=1}^mKL(\hat{\rho}_j||\rho)</script><script type="math/tex; mode=display">
KL(\hat{\rho}_j||\rho)=\rho·\log \frac{\rho}{\hat{\rho}_j}+(1-\rho)·\log \frac{1-\rho}{1-\hat{\rho}_j}</script><p><strong>实现方法</strong>：可以设置一个三维矩阵，第一维为$||\{x^{(i)}\}||$，第二和第三维对应神经网络每一个神经元。然后在数据流经一次模型后抽取出每一层神经元的参数，作平均。抽取方法可以用我以前写的<a href="https://aisakaki.com/2019/07/10/pytorch获取中间层参数、输出与可视化/">pytorch获取中间层参数、输出与可视化/</a>一文中提到的中间层参数可视化方法</p>
<h2 id="Denoising-Autoencoder"><a href="#Denoising-Autoencoder" class="headerlink" title="Denoising Autoencoder"></a>Denoising Autoencoder</h2><p>降噪自编码器（DAE）</p>
<p>向输出加入噪声$\hat{x}$，并设置损失函数尽量减少输出的噪声，目标使得模型学习<strong>重构分布</strong>$p_{decoder}(x|\hat{x})$，增强模型健壮性</p>
<p>最小化</p>
<script type="math/tex; mode=display">
L(x,g(f(\hat{x})))</script><p>也就是要<strong>使得正确输入与加噪声的输入经过模型后还原得到的输出尽量一样</strong></p>
<p><strong>实现方法：</strong>加入噪声的方法可以有多种，比如增加高斯分布随机扰动$x\to x+\epsilon,\epsilon ～ N(μ,\sigma^2)$，也可以使用掩码方法遮蔽部分特征</p>
<blockquote>
<p>补充：得分匹配是最大似然的代替。它提供了概率分布的一致性估计，使得模型在各个数据点$x$上获得与数据分布相同的得分，在这种情况下，得分是一个特定的梯度场：</p>
</blockquote>
<script type="math/tex; mode=display">
\nabla_x\log p(x)</script><p>DAE的训练目标可以使得AE学到能估计数据分布得分的向量场$(g(f(x))-x)$</p>
<h2 id="Contractive-Autoencoder"><a href="#Contractive-Autoencoder" class="headerlink" title="Contractive Autoencoder"></a>Contractive Autoencoder</h2><p>收缩自编码器(CAE)</p>
<p>是正则自编码器的一个变形，将正则项设置为惩罚导数——隐藏层函数对输入求导，也即其Jacobi矩阵$J_h$</p>
<script type="math/tex; mode=display">
J=L(x,g(f(x)))+\lambda\Sigma_i||\nabla_xh_i||_F^2</script><p>注意这里是矩阵的F-范数，即矩阵每项平方求和</p>
<p>可以看出收缩惩罚目标是使得学习到的参数在所有方向上不变，而是在整体上进行参数的缩放，其使得函数梯度很小，所以能够很好的学习到流形结构，（而使得$J_x$很大的方向$x$，会快速改变$h$，则很可能是近似流形切平面的方向）</p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>自编码器</tag>
      </tags>
  </entry>
  <entry>
    <title>行って、振り向かないで</title>
    <url>/2019/10/03/%E4%B8%8D%E8%A6%81%E5%9B%9E%E5%A4%B4%EF%BC%8C%E4%B8%80%E7%9B%B4%E5%90%91%E5%89%8D/</url>
    <content><![CDATA[<p><img src="//aisakaki.com/2019/10/03/不要回头，一直向前/0.png" alt="Snipaste_2019-10-04_08-27-03"></p>
<p><div style="text-align: center"><i>“不要回头，一直向前 ”</i></div></p>
<p><div style="text-align: right"><i>——《千与千寻的神隐》</i></div></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=578090&auto=0&height=66"></iframe>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>另一种提取中间层输出的办法与风格迁移的改进</title>
    <url>/2019/09/30/%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%8F%90%E5%8F%96%E4%B8%AD%E9%97%B4%E5%B1%82%E8%BE%93%E5%87%BA%E7%9A%84%E5%8A%9E%E6%B3%95%E4%B8%8E%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB%E7%9A%84%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<h2 id="提取中间层输出"><a href="#提取中间层输出" class="headerlink" title="提取中间层输出"></a>提取中间层输出</h2><p>除了在我前面的文章<a href="https://aisakaki.com/2019/07/10/pytorch获取中间层参数、输出与可视化/">pytorch获取中间层参数、输出与可视化</a></p>
<p>提到的使用hook函数获取中间层输出以外，还可以用更直接的办法，不使用hook函数</p>
<p><strong>方法一：将model中的每层拆解出来依次在监控下让数据流过</strong><br>可以借助<code>isinstance(layer, nn.Conv2d)</code>判断层类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_layers</span><span class="params">(layers,img,model)</span>:</span></span><br><span class="line">    layer_index = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> layer <span class="keyword">in</span> model:</span><br><span class="line">        <span class="keyword">if</span> layer_index == <span class="number">0</span>:</span><br><span class="line">            out = layer(img)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            out = layer(out)</span><br><span class="line">        <span class="keyword">if</span> layer_index <span class="keyword">in</span> layers:</span><br><span class="line">            res.append(out)</span><br><span class="line">        layer_index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>方法二：直接在定义模型的时候输出中间层数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.linear1 = nn.Linear(<span class="number">64</span>,<span class="number">32</span>)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">32</span>,<span class="number">16</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,input)</span>:</span></span><br><span class="line">        linear1_out = self.linear1(input)</span><br><span class="line">        linear2_out = self.linear2(linear1_out)</span><br><span class="line">        <span class="keyword">return</span> linear1_out,linear2_out</span><br></pre></td></tr></table></figure>
<h2 id="对于噪点的改进-降噪"><a href="#对于噪点的改进-降噪" class="headerlink" title="对于噪点的改进-降噪"></a>对于噪点的改进-降噪</h2><p>修改方程，向方程中加入总变差损失(total variation denoising)</p>
<script type="math/tex; mode=display">
L_{total}(S,C,G) = \alpha L_{content}(C,G)+\beta L_{style} (S,G)+\gamma L_{noise}(C,G)</script><script type="math/tex; mode=display">
L_{noise}(C,G)=\Sigma_{i,j}|x_{i,j}-x_{i+1,j}|+|x_{i,j}-x_{i,j+1}|</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TotalVariationLoss</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,weight)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.weight = weight</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,inputs)</span>:</span></span><br><span class="line">        <span class="comment">#矩阵计算，一步到位</span></span><br><span class="line">        loss = <span class="number">0.5</span>*((inputs[:, :, <span class="number">1</span>:, :]-inputs[:, :, :<span class="number">-1</span>, :]).abs().mean()+(inputs[:, :, :, <span class="number">1</span>:]-inputs[:, :, :, :<span class="number">-1</span>]).abs().mean())</span><br><span class="line">        <span class="keyword">return</span> loss * self.weight</span><br></pre></td></tr></table></figure>
<p> 在<code>loss function</code>中对应作修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#总变差损失计算</span></span><br><span class="line">    noise_loss = TotalVariationLoss(noise_weight)</span><br><span class="line">    noise_loss_this = noise_loss(input_param)</span><br><span class="line">    </span><br><span class="line">    loss = style_loss_this + content_loss_this + noise_loss_this</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="风格迁移的其它损失函数优化算法"><a href="#风格迁移的其它损失函数优化算法" class="headerlink" title="风格迁移的其它损失函数优化算法"></a>风格迁移的其它损失函数优化算法</h2><p>我最先采用的LBFGS算法是因为原论文是使用的该算法，使用LBFGS的优点在于能够快速收敛，但缺点也很明显，非常耗显存，图片大一点的话泰坦的12G显存迅速被耗尽</p>
<p>另外以下为两种优化算法对同样风格层迁移效果的对比</p>
<p>原图：<br><img src="//aisakaki.com/2019/09/30/另一种提取中间层输出的办法与风格迁移的改进/原图.jpg" alt="原图"><br>风格图：<img src="//aisakaki.com/2019/09/30/另一种提取中间层输出的办法与风格迁移的改进/style.png" alt="style"></p>
<p>LBFGS：<br><img src="//aisakaki.com/2019/09/30/另一种提取中间层输出的办法与风格迁移的改进/result_LBFGS.jpg" alt="result_LBFGS"><br>Adam：<br><img src="//aisakaki.com/2019/09/30/另一种提取中间层输出的办法与风格迁移的改进/result3_Adam_10020.jpg" alt="result3_Adam_10020"></p>
<p>Denoise Adam：</p>
<p>加入降噪训练之后效果好很多</p>
<p><img src="//aisakaki.com/2019/09/30/另一种提取中间层输出的办法与风格迁移的改进/result_Adam_TVDnoise.jpg" alt="result_Adam_TVDnoise"></p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>风格迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>拟牛顿法</title>
    <url>/2019/09/26/%E6%8B%9F%E7%89%9B%E9%A1%BF%E6%B3%95/</url>
    <content><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>牛顿法中最困难的部分在于计算$H$和$H^{-1}$</p>
<p>拟牛顿法的思想就是不用二阶偏导数而构造出可以<strong>近似</strong>$H$和$H^{-1}$的正定对称矩阵，在拟牛顿的条件下优化目标函数。但是不可能随便一个矩阵都能近似$H$，所以我们要给近似矩阵开一个条件，也就是下面的拟牛顿条件</p>
<h2 id="拟牛顿条件"><a href="#拟牛顿条件" class="headerlink" title="拟牛顿条件"></a>拟牛顿条件</h2><p>由上一篇我写的文章可知（依然省略掉高阶导数无穷项，实际上应该用$≈$，为了方便这里都用$=$了</p>
<script type="math/tex; mode=display">
\nabla f(x)=g_{k+1}+H_{k+1}(x-x_{k+1})</script><p>设$x=x_k$</p>
<p>记$s_k=x_{k+1}-x_k,y_k=g_{k+1}-g_k$</p>
<p>$\therefore y_k=H_{k+1}\cdot s_k$</p>
<p>或$s_k=H^{-1}_{k+1}\cdot y_k$</p>
<p>此即为拟牛顿条件</p>
<p>选择合适的$B_{k+1}$做$H_{k+1}$的近似，合适的$D_{K+1}$做$H^{-1}_{k+1}$的近似，使他们满足拟牛顿条件即可</p>
<p>相当于给拟合$H，H^{-1}$做了一个约束，使得在$f(x_k)与f(x_{k+1})$拟合矩阵与真实矩阵的一阶导相等</p>
<p>以下不同的算法实际上就是<strong>设计拟合矩阵</strong>的算法</p>
<h2 id="DFP算法"><a href="#DFP算法" class="headerlink" title="DFP算法"></a>DFP算法</h2><p>DFP算法通过迭代的方法对$D_{K+1}$做$H^{-1}_{k+1}$的近似</p>
<p>主要设置$D_k$待定形式为</p>
<script type="math/tex; mode=display">
\Delta D_k=\alpha uu^T+\beta vv^T</script><p>推导过程类似BFGS算法，略，见下</p>
<script type="math/tex; mode=display">
D_{k+1}=D_{k}+\frac{s_ks_k^T}{s_k^Ty_k}-\frac{D_ky_ky_k^TD_k}{y_k^TD_ky_k},k=0,1,2,\cdots</script><p>一般$D_0=I$</p>
<h2 id="BFGS算法"><a href="#BFGS算法" class="headerlink" title="BFGS算法"></a>BFGS算法</h2><p>BFGS算法通过迭代的方法对$B_{K+1}$做$H_{k+1}$的近似，直接逼近Hessian矩阵</p>
<p>采用迭代法</p>
<script type="math/tex; mode=display">
B_{k+1}=B_k+\Delta B_k,k=0,1,2,\cdots</script><p>一般$B_0=I$</p>
<p>设置$B_k$的待定形式</p>
<script type="math/tex; mode=display">
\Delta B_k=\alpha uu^T+\beta vv^T</script><p>$uu^T$和$vv^T$正好构成对称矩阵</p>
<p>代入$y_k=H_{k+1}\cdot s_k$中（$B_{k+1}$逼近$H_{k+1}$）得</p>
<script type="math/tex; mode=display">
y_k=(B_k+\alpha uu^T+\beta vv^T)\cdot s_k</script><script type="math/tex; mode=display">
=B_ks_k+\alpha u^Ts_k\cdot u+\beta v^ts_k\cdot v</script><p>$u^Ts_k$和$v^Ts_k$都是常数，不妨令$\alpha u^Ts_k=1,\beta v^ts_k=-1,u=y_k,v=B_ks_k$,</p>
<script type="math/tex; mode=display">
\therefore \alpha=\frac{1}{y_k^Ts_k},\beta=-\frac{1}{s_k^TB_ks_k}</script><script type="math/tex; mode=display">
\therefore \Delta B_k=\frac{y_ky_k^T}{y_k^Ts_k}-\frac{B_ks_ks_k^TB_k}{s_k^TB_ks_k}</script><p>但由于必须储存$D$，使得储存开销很大，不适用大数据大型模型</p>
<h2 id="LBFGS算法"><a href="#LBFGS算法" class="headerlink" title="LBFGS算法"></a>LBFGS算法</h2><p>通过避免储存完整的Hessian逆运算近似$D$,降低BFGS的储存代价</p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
  </entry>
  <entry>
    <title>牛顿法求解非线性优化</title>
    <url>/2019/09/26/%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E8%A7%A3%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><em>前面在风格迁移的时候用到了LBFGS，很好奇只需要设置一个闭包迭代即可，不需要像动量算法等一阶优化算法一样设置步长学习率等，于是系统地去了解了一下牛顿法与拟牛顿法</em></p>
<h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p>首先回想起泰勒展开，此式子即为$f(x)$在$x_k$附近的二阶泰勒展开式</p>
<script type="math/tex; mode=display">
\phi(x) =f(x_k)+f'(x_k)(x-x_k)+\frac{1}{2}f''(x_k)(x-x_k)^2+O</script><p>令导数为0即可求得最值</p>
<script type="math/tex; mode=display">
\phi'(x)=0</script><p>省略掉高阶项，则</p>
<script type="math/tex; mode=display">
f'(x_k)+f''(x_k)(x-x_k)=0</script><p>$\therefore$</p>
<script type="math/tex; mode=display">
x = x_k-\frac{f'(x_k)}{f''(x_k)},k=0,1,2,···</script><p>于是我们就可以从初始$x_0$值开始用此式进行迭代来逼近极小值点，其逼近就是<strong>在每次迭代的时候直接跳到近似函数的最小点</strong></p>
<p>那么对于高维度的情形，原泰勒公式就可以表示为</p>
<script type="math/tex; mode=display">
\phi(X) = \nabla f(X_k)·(X-X_k)+\frac{1}{2}(X-X_k)^T·\nabla^2f(X_k)·(X-X_k)</script><p>这里的$\nabla^2 f(X_k)$即为Hessian矩阵，其实就是二阶梯度</p>
<script type="math/tex; mode=display">
\nabla^2 f(X_k)=
\begin{bmatrix}
{\frac{\partial^2 f}{\partial x_1^2}}&{\frac{\partial^2 f}{\partial x_1\partial x_2}}&{\cdots}&{\frac{\partial^2 f}{\partial x_1\partial x_n}}\\
{\frac{\partial^2 f}{\partial x_2\partial x_1}}&{\frac{\partial^2 f}{\partial x_2^2}}&{\cdots}&{\frac{\partial^2 f}{\partial x_2\partial x_n}}\\
{\vdots}&{\vdots}&{\ddots}&{\vdots}\\
{\frac{\partial^2 f}{\partial x_n\partial x_1}}&{\frac{\partial^2 f}{\partial x_2^2}}&{\cdots}&{\frac{\partial^2 f}{\partial x_n\partial x_n}}\\
\end{bmatrix}</script><p>$\nabla f(X_k)$就是一阶梯度，不展开了</p>
<p>因为Hessian矩阵是实对称矩阵，我们可以将其分解为一组实特征值和一组特征向量的正交基。在特定方向$d$的二阶导数可以写成$d^THd$。</p>
<p>当$d$是$H$的一个特征向量的时候，这个方向的二阶导数就是对应的特征值。对于其他方向$d$，方向二阶导数是所有特征值的加权平均，权重在0和1之间，且与$d$夹角越小的特征值权重越大。最大特征值确定最大二阶导数，最小特征值确定最小二阶导数。</p>
<p>记$g_k=\nabla f(X_k)$,$H_k=\nabla^2 f(X_k)$，</p>
<script type="math/tex; mode=display">
\nabla \phi(X)=0</script><p>则</p>
<script type="math/tex; mode=display">
g_k+H_k(X-X_k)=0</script><p>$H_k$必为非奇异矩阵（满秩矩阵）</p>
<p>$\therefore$</p>
<script type="math/tex; mode=display">
X = X_k-H_k^{-1}·g_k ,k=0,1,2,\cdots</script><p>此即为牛顿法的迭代式，$d_k=-H_k^{-1}·g_k$称为<strong>牛顿方向</strong></p>
<p>牛顿法求出的方向是一个逼近，因为其省略了泰勒的高阶展开项（但如果是二次函数，那就不是逼近了，这时候Hessian矩阵退化为常数矩阵，只需要一次运算即可到达最优点）</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ol>
<li><p>使用牛顿法可以比一阶优化算法更快的收敛，因为每次它都是直接跳到近似函数的最小点（对于二次函数，直接一步收敛），但是这种特性在<strong>鞍点</strong>附近会造成病态。</p>
</li>
<li><p>会造成<strong>局部收敛</strong></p>
</li>
<li><p>Hessian矩阵的计算量是其它一阶优化方法的平方倍，所以对硬件计算负担要求极高</p>
</li>
<li><p>由于步长是定的，所以牛顿方向$-H_k^{-1}·g_k$并不能保证稳定下降，其并不是梯度下降算法</p>
</li>
<li><p>函数必须二阶可导，Hessian矩阵必须为正定矩阵</p>
</li>
</ol>
<p>   <em>深度学习通常都有很多局部极值，鞍点，且计算量巨大，所以很少在深度学习中使用牛顿法</em></p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ol>
<li><p>针对第四个缺陷，可以对其进行改进，加入<strong>线搜索</strong>，称作<strong>阻尼牛顿法</strong>，这个思想和动量算法思想一样</p>
<p>仍然用$d_k$在方向上进行迭代，但是每次迭代的时候需要进行一次线搜索，寻求最优步长因子$\lambda_k $</p>
<p>$d_k\to\lambda_k d_k$</p>
<p>$\lambda_k=arg\min f(x_k+\lambda_k d_k)$</p>
</li>
<li><p>可以通过多种手段避免直接对Hessian矩阵求逆</p>
<p>比如共轭梯度法（PCG），代数多重网格法（AMG）等</p>
<p>补充PCG思想：结合梯度下降与牛顿法，在一个方向上用牛顿法，一次性迭代完，理论上N个方向N次即可收敛</p>
</li>
<li><p>拟牛顿法</p>
</li>
</ol>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>非线性优化</tag>
      </tags>
  </entry>
  <entry>
    <title>骚动时节的少女们啊</title>
    <url>/2019/09/25/%E9%AA%9A%E5%8A%A8%E6%97%B6%E8%8A%82%E7%9A%84%E5%B0%91%E5%A5%B3%E4%BB%AC%E5%95%8A/</url>
    <content><![CDATA[<p>应该是老马失蹄的最惨的一次</p>
<p>没想到后半段开始一路血崩…</p>
<p>这就是部青春期性教育重要性的宣传片.. 前八集非常不错，冈妈将细腻与敏感的初春体现的淋漓尽致</p>
<p>但是第八集之后，至少我是理解不能…… </p>
<p>冈妈把关于性和爱的模糊不清的这种情感无限夸大 ，然后非常魔幻地表达出来，造成一种非常尴尬的效果，把非常抽象的东西用现实的手段生硬地表现出来造成了极强的违和感</p>
<p>还有白毛和矮子这俩能不能删了orz</p>
<p>前8集9分 ，后几集2分 ，加权一下，6.7分</p>
]]></content>
      <categories>
        <category>Anime</category>
      </categories>
      <tags>
        <tag>新番</tag>
      </tags>
  </entry>
  <entry>
    <title>IOS开发小记</title>
    <url>/2019/09/25/XCODE%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>最近老师想要给一个去中心链的IM开发几个功能，安卓端有人做，但我们实验室没人开发过IOS，老师想起我面试的时候提到过我大二做过IOS开发，就让我这个月搞出来，然后…</p>
<p>不愧是世界上最难用的IDE，回想起了大二被XCODE支配的恐惧</p>
<p>因为当时没用pods管理第三方库…以下踩坑记录</p>
<ol>
<li><p>使用CocoaPod管理依赖的项目，XCode只能使用workspace编译项目，如果还只打开以前的xcodeproj文件进行开发，编译会失败。新增的workspace文件会引用原有的应用主工程，还会引用新增的Pods工程</p>
</li>
<li><p>如果   PODS生成的静态链接库没有被主工程target链接，要自己手动建立链接</p>
</li>
<li><p>在头文件搜索路径里 xxx/xxx/<em> re… 别忘了加\</em>并设置迭代搜索</p>
</li>
<li><p>build后修改代码，需要build clean再重新build，不然会报上次一样的错</p>
</li>
<li><p>要检查头文件路径是否正确<xxx xxx="">，或者直接写”.h”，则xcode会直接在头文件搜索路径里搜索</xxx></p>
</li>
<li><p>mac自带的ruby权限较小，开发不要用这个。我们要自己安装rvm并创建ruby环境，随后我们的cocoapods是在这个环境使用的</p>
</li>
</ol>
]]></content>
      <categories>
        <category>开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>IOS</tag>
        <tag>XCODE</tag>
      </tags>
  </entry>
  <entry>
    <title>神经风格迁移</title>
    <url>/2019/09/21/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h2 id="风格迁移"><a href="#风格迁移" class="headerlink" title="风格迁移"></a>风格迁移</h2><script type="math/tex; mode=display">
L_{total}(S,C,G) = \alpha L_{content}(C,G)+\beta L_{style} (S,G)</script><p>内容图像（C）,生成的图像（G ）,样式图像（S）</p>
<p>合成图像为唯一需要学习（更新）的参数（视为模型参数），也是生成的结果，而不是VGG</p>
<p>输入：C</p>
<p>初始化：可以选择让G=C，也可以随机初始化一个G</p>
<p>这个算法里面的参数(也就是是合成图片里面的每个像素点，我们可以将内容图片直接 copy 成合成图片，<strong>然后训练使得他的风格和我们的风格图片相似，同时也可以随机化一张图片作为合成图片（两种初始化）</strong>，然后训练他使得他与内容图片以及风格图片具有相似性。特征的提取</p>
<h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><p>这里不训练模型，直接使用预训练的vgg来提取特征</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span><span class="params">()</span>:</span></span><br><span class="line">    vgg = models.vgg19(pretrained=<span class="keyword">True</span>).features</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> vgg.parameters():</span><br><span class="line">        param.requires_grad = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> vgg</span><br></pre></td></tr></table></figure>
<h2 id="extract-loss"><a href="#extract-loss" class="headerlink" title="extract loss"></a>extract loss</h2><p>这里使用以前用过的register_forward_hook()函数来hook</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayerActivations</span><span class="params">()</span>:</span></span><br><span class="line">    features = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,model,layer_nums)</span>:</span></span><br><span class="line">        <span class="comment">#这里要hook多层，要保存多层钩子</span></span><br><span class="line">        self.hooks = []</span><br><span class="line">        <span class="keyword">for</span> layer_num <span class="keyword">in</span> layer_nums:</span><br><span class="line">            self.hooks.append(model[layer_num].register_forward_hook(self.hook_fn))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hook_fn</span><span class="params">(self,module,input,output)</span>:</span></span><br><span class="line">        self.features.append(output)</span><br><span class="line">    <span class="comment">#捕捉完输出后不能忘掉remove方法，否则所有输入都累加在一起会内存溢出 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> hook <span class="keyword">in</span> self.hooks:</span><br><span class="line">            hook.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment">#该函数用于将图片输入进模型，经过钩子获取指定多层的特征输出      </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_layers</span><span class="params">(layers,img,model)</span>:</span></span><br><span class="line">    la = LayerActivations(model=model,layer_nums=layers)</span><br><span class="line">    <span class="comment">#清空缓存</span></span><br><span class="line">    la.features=[]</span><br><span class="line">    <span class="comment">#运行模型，开钩</span></span><br><span class="line">    out = model(img)       </span><br><span class="line">    <span class="comment">#已经获取到特征，这是我们关注的东西，然后注销钩子</span></span><br><span class="line">    la.remove()</span><br><span class="line">    <span class="comment">#注意这里返回的是列表，一次性钩了多层</span></span><br><span class="line">    <span class="keyword">return</span> la.features</span><br></pre></td></tr></table></figure>
<h2 id="定义损失"><a href="#定义损失" class="headerlink" title="定义损失"></a>定义损失</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># content loss</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContentLoss</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,weight)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.mseloss = nn.MSELoss()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,inputs,targets)</span>:</span></span><br><span class="line">        out = self.mseloss(inputs,targets)</span><br><span class="line">        <span class="keyword">return</span> out * self.weight</span><br></pre></td></tr></table></figure>
<p>衡量风格损失使用的是Gram Matrix，对于$k$个向量$\alpha_1,\alpha_2,\cdots,\alpha_k$</p>
<script type="math/tex; mode=display">
G=
\begin{bmatrix}
{(\alpha_1,\alpha_1)}&{(\alpha_1,\alpha_2)}&{\cdots}&{(\alpha_1,\alpha_k)}\\
{(\alpha_2,\alpha_1)}&{(\alpha_2,\alpha_2)}&{\cdots}&{(\alpha_2,\alpha_k)}\\
{\vdots}&{\vdots}&{\ddots}&{\vdots}\\
{(\alpha_k,\alpha_1)}&{(\alpha_k,\alpha_2)}&{\cdots}&{(\alpha_k,\alpha_k)}\\
\end{bmatrix}</script><p>把特征提取输出变换为$k$行$h*w$列的矩阵$X$，那么$X=&lt;\alpha_1,\alpha_2,\cdots,\alpha_k&gt;$，其中向量$x_i$代表了通道$i$上的样式特征，于是Gram矩阵实际上计算出了各个通道的两两相关性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># style loss</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GramMatrix</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,inputs)</span>:</span></span><br><span class="line">        b,c,h,w = inputs.size()</span><br><span class="line">        <span class="comment">#hw维度扁平化</span></span><br><span class="line">        features = inputs.view(b,c,h*w)</span><br><span class="line">        <span class="comment">#bmm(A) =  AxA^T</span></span><br><span class="line">        gram_matrix = torch.bmm(features,features.transpose(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">        <span class="comment">#为防止值过大，做归一化</span></span><br><span class="line">        gram_matrix.div_(h*w)</span><br><span class="line">        <span class="keyword">return</span> gram_matrix</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StyleLoss</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,weight)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.gramfunc = GramMatrix()</span><br><span class="line">        self.mseloss = nn.MSELoss()</span><br><span class="line">        self.weight = weight</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,inputs,targets)</span>:</span></span><br><span class="line">        gram_inputs = self.gramfunc(inputs)</span><br><span class="line">        gram_targets = self.gramfunc(targets)</span><br><span class="line">        out = self.mseloss(gram_inputs,gram_targets)</span><br><span class="line">        <span class="keyword">return</span> out * self.weight</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># loss function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_fn</span><span class="params">(content_layers,style_layers,content_weight,style_weight,content_img,style_img,model,input_param,times)</span>:</span></span><br><span class="line">    loss = <span class="number">0</span> </span><br><span class="line">    <span class="comment">#提取风格图片的特征并计算,注意这里是提取input（合成）和风格/内容的，都要提取</span></span><br><span class="line">    style_features = extract_layers(style_layers,style_img,model)  </span><br><span class="line">    input_features = extract_layers(style_layers,input_param,model) </span><br><span class="line">    <span class="keyword">for</span> style_layer_index <span class="keyword">in</span> range(len(style_layers)):</span><br><span class="line">        style_loss = StyleLoss(style_weight)</span><br><span class="line">        style_loss_this = style_loss(input_features[style_layer_index],style_features[style_layer_index])      </span><br><span class="line">        </span><br><span class="line">    <span class="comment">#提取内容图片的特征并计算   </span></span><br><span class="line">    content_features = extract_layers(content_layers,content_img,model)</span><br><span class="line">    input_features = extract_layers(content_layers,input_param,model)     </span><br><span class="line">    <span class="keyword">for</span> content_layer_index <span class="keyword">in</span> range(len(content_layers)):</span><br><span class="line">        content_loss = ContentLoss(content_weight)</span><br><span class="line">        content_loss_this = content_loss(input_features[content_layer_index],content_features[content_layer_index])    </span><br><span class="line">    </span><br><span class="line">    loss = style_loss_this+content_loss_this</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> times % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'style loss:&#123;:.4f&#125; , content loss:&#123;:.4f&#125;'</span>.format(style_loss_this,content_loss_this))</span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure>
<h2 id="TRAIN"><a href="#TRAIN" class="headerlink" title="TRAIN"></a>TRAIN</h2><p>使用LBGFS作为优化函数，LBFGS使用的时候就需要用到闭包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(Epoch,input_img,</span></span></span><br><span class="line"><span class="function"><span class="params">          content_weight,style_weight,content_img,style_img,</span></span></span><br><span class="line"><span class="function"><span class="params">          content_layers=[<span class="number">21</span>],style_layers=[<span class="number">1</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">20</span>,<span class="number">25</span>])</span>:</span></span><br><span class="line">    <span class="comment">#默认vgg模型</span></span><br><span class="line">    model = get_model().cuda()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#初始化合成图片，将input_img作为初始的合成图片并参数化</span></span><br><span class="line">    input_param = nn.Parameter(input_img.data)    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#初始化优化器</span></span><br><span class="line">    optimizer = torch.optim.LBFGS([input_param])</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(Epoch):</span><br><span class="line">        print(<span class="string">'epoch:&#123;&#125;'</span>.format(epoch))</span><br><span class="line">        <span class="comment">#开始训练</span></span><br><span class="line">        <span class="keyword">global</span> times</span><br><span class="line">        times=<span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">closure</span><span class="params">()</span>:</span></span><br><span class="line">            optimizer.zero_grad() <span class="comment">#勿忘</span></span><br><span class="line">            <span class="keyword">global</span> times</span><br><span class="line">            times+=<span class="number">1</span></span><br><span class="line">            loss = loss_fn(content_layers,style_layers,content_weight,style_weight,content_img,style_img,model,input_param,times)</span><br><span class="line">            loss.backward() </span><br><span class="line">            <span class="keyword">return</span> loss</span><br><span class="line">        optimizer.step(closure) </span><br><span class="line">    <span class="keyword">return</span> input_param.data </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showImg</span><span class="params">(res)</span>:</span></span><br><span class="line">    img = res[<span class="number">0</span>]</span><br><span class="line">    img = img.cpu()</span><br><span class="line">    img = transforms.ToPILImage()(img) </span><br><span class="line">    plt.imshow(img)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>风格迁移</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>Adversary Resistant Deep Neural Networks with an Application to Malware Detection</title>
    <url>/2019/09/19/toMalwareDetection/</url>
    <content><![CDATA[<blockquote>
<p>《Adversary Resistant Deep Neural Networks with an Application to Malware Detection》<br>    Qinglong Wang ,Wenbo Guo,Kaixuan Zhang,AlexanderG.OrorbiaII, Xinyu Xing,Xue Liu,C.LeeGiles<br>    KDD 2017（CCF-A）</p>
</blockquote>
<h2 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h2><ul>
<li><p>deep neural networks(DNNs) could help turn the tide in the war against malware infection</p>
</li>
<li><p>However, DNNs are vulnerable to adversarial samples</p>
</li>
<li>Past research in developing defense mechanisms relies on strong assumptions,which typically do not hold in many real-world scenarios. Also,these proposed techniques can only be empirically validated and do not provide any theoretical guarantees. This is particularly disconcerting when they are applied to security-critical applications such as malware detection. </li>
</ul>
<h2 id="Why-It-Works？"><a href="#Why-It-Works？" class="headerlink" title="Why It Works？"></a>Why It Works？</h2><ul>
<li>随机性的引入使得attackers不容易发现DNN的”blind spots”（也就是AEs）</li>
<li>这个adversary-resistant DNNs 只需要一点微小的工作，且可以维持分类的表现</li>
<li>从理论上来说，本文的方法可以保证对AE的抵抗性</li>
</ul>
<p>该方法也可以应用在图像等其他DNN模型适用效果较好的领域</p>
<h2 id="Related-Works"><a href="#Related-Works" class="headerlink" title="Related Works"></a>Related Works</h2><ul>
<li><p><strong>Data Augmentation</strong></p>
<p>Explaining and harnessing adversarial examples. arXiv preprint arXiv:1412.6572 (2014).</p>
<p>Towards deep neural network architectures robust to adversarial examples. arXiv:1412.5068 [cs] (2014). </p>
<p>Unifying Adversarial Training Algorithms with Flexible Deep Data Gradient Regularization. arXiv:1601.07213 [cs] (2016).</p>
<p>增强数据，主要是通过将潜在AEs与普通样本进行训练（<strong>对抗训练</strong>）以增加对AEs的鲁棒性，对抗训练已被证明很有用</p>
<p>作者指出的问题：blind spots空间太大，不可能去覆盖一个infinite space，且attackers也可以对对抗训练模型本身进行攻击（<em>how</em>），考虑到无限空间，每一次遇到AEs就必须再次训练对抗训练模型，如此反复迭代</p>
</li>
<li><p><strong>Enhancing Model Complexity</strong></p>
<p>增加模型复杂度</p>
<p>Towards deep neural network architectures robust to adversarial examples. arXiv:1412.5068 [cs] (2014).</p>
<p>Distillation as a defense to adversarial perturbations against deep neural networks. arXiv preprint arXiv:1511.04508 (2015).  （防御蒸馏机制，将第一个深度神经网络输出的软标签输入到第二个网络中进行训练，降低模型对微小扰动的敏感度。第一个模型的软标签熵编码了类之间的相对差异）</p>
<p>作者指出的问题：攻击者可以使用两个近似性能的DNN来拟合整个机制（该论文作者承认了此机制很容易被拟合）</p>
<p>同时该机制实际上是一个<strong>梯度掩码</strong>模型，并无法抵抗JSMA的攻击</p>
</li>
</ul>
<h2 id="Random-Feature-Nullification"><a href="#Random-Feature-Nullification" class="headerlink" title="Random Feature Nullification"></a>Random Feature Nullification</h2><p>  we introduce random feature nullification to both the training and testing phases of DNN models, making the architectures non-deterministic. </p>
<p>  引入随机性，对行为特征进行随机失活，看起来像是一种特殊的dropout正则</p>
<p>  但区别在于dropout仅仅在训练的时候对神经元随即失活，而本文的方法是在train和test的时候都执行</p>
<p><img src="//aisakaki.com/2019/09/19/toMalwareDetection/1.png" alt="1"></p>
<p>作者在input与hidden之间加了一层<strong>Nullification层</strong></p>
<p>超参数：$μ_p,\sigma^2_p $</p>
<h2 id="Model-Description"><a href="#Model-Description" class="headerlink" title="Model Description"></a>Model Description</h2><p>$X\in R^{N*M}$ ($N$ 个样本，$M$维特征)</p>
<p>$\hat{I}_p\in R^{N*M}$ (mask matrix)</p>
<p>Nullification来源于$X$与$\hat{I}_p$按位乘</p>
<p>经验证在Random Nullification中会损失有用的分类特征信息，于是为了解决这个问题，本文为每个样本引入了<strong>Nullification Rate</strong>：$p^i$，且不仅哪个神经元失活是随机的，失活神经元的数量也是随机的</p>
<p>单个输入$x_i$对应一个$I_{p^i}$，后者是一个二进制向量，0的数量取决于$p^i$，且随机分布。作者使用了高斯分布和均匀分布。</p>
<p>$⌈M·p^i⌉$ :$I_{p^i}$中随机分布的0的个数，$p^i$是从高斯分布$N(μ_p,\sigma^2_p)$中的一次采样样本</p>
<p>于是DNN的目标函数定义为</p>
<script type="math/tex; mode=display">
\min_\theta \Sigma^N_{i=1} L(f(x_i,I_{p^i};\theta),y_i)</script><p>随机特征失活过程（random feature nullification process）表示为$q(x_i,I_{p^i})=x^i⊙I_{p^i}$</p>
<p>(⊙为Hadamard product，一种特殊的矩阵乘法，同阶矩阵，$c_{ij}=a_{ij}*b_{ij}$)</p>
<p>于是$f(x_i,I_{p^i};\theta)=f(q(x_i,I_{p^i});\theta)$</p>
<p>在训练中使用SGD求解目标函数，但这里不同之处在于$I_{p^i}$在<strong>一个</strong>样本的前向传播和反向传播过程中是固定的，这使得容易计算$L(f(x_i,I_{p^i};\theta),y_i)$的导数</p>
<p>在测试中由于参数固定，使用高斯分布$N(μ_p,\sigma^2_p)$的期望作为辅助的随机变量$p^i$</p>
<h2 id="Analysis-Model-Resistance-to-Adversaries"><a href="#Analysis-Model-Resistance-to-Adversaries" class="headerlink" title="Analysis: Model Resistance to Adversaries"></a>Analysis: Model Resistance to Adversaries</h2><p><strong>攻击防御：</strong></p>
<p>对抗攻击需要求解如下导数($\hat{x}$是任一测试样本)</p>
<script type="math/tex; mode=display">
J_L(\hat{x})=\frac{\partial L(f(x_i,I_{p^i};\theta),\hat{y})}{\partial \hat{x}}</script><script type="math/tex; mode=display">
=J_L(q)·\frac{\partial q(\hat{x},I_p)}{\partial \hat{x}}</script><p>where $J_L(q)=\partial L(f(x_i,I_{p^i};\theta),\hat{y})/\partial q(\hat{x},I_p)$，$I_p$是在测试中使用的mask matrix</p>
<p>只要此式子求解，攻击者便可以生成AE发动攻击$\hat{x} \to\hat{x}+ \phi sign(J_L(\hat{x}))$</p>
<p>但此时由于乘随机变量$I_p$的存在，使得攻击者无法轻易算出$J_L(q)$</p>
<p>这里作者说明了如果$I_p$是加随机变量的话$J_L(q)$将可以被轻易求解</p>
<p><strong>模拟攻击：</strong></p>
<p>因此，攻击者要想攻击此模型的最佳办法就算去拟合$I_p$.</p>
<p>作者假设 $I^*_p$ 为 $I_p$ 的最佳拟合，DNNs为黑盒，最佳的扰动为 $\delta\hat{x}$ </p>
<p>则最佳合成攻击样本为 $\hat{x}+\delta\hat{x}⊙I^*_p$ </p>
<p>假设攻击者用此来攻击下面图2中的系统</p>
<p><img src="//aisakaki.com/2019/09/19/toMalwareDetection/2.png" alt="2"></p>
<p>如图可以看到，<strong>攻击必须经过feature nullification layer才能抵达实际的DNN</strong>，由如下式子表示</p>
<script type="math/tex; mode=display">
(\hat{x}+\delta\hat{x}⊙I^*_p)⊙I_p=(\hat{x}⊙I_p)+\delta\hat{x}⊙I^*_p⊙I_p</script><p>式子中 $\hat{x}⊙I_p$ 即为一个真实的nullified样本，$\delta\hat{x}⊙I^*_p⊙I_p$ 就是发动攻击的添加的扰动</p>
<p>这里可以看到，尽管 $\delta\hat{x}$ 是非常有效的扰动，但 $I^*_p⊙I_p$ 的存在使得该扰动大幅减弱</p>
]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>对抗样本</tag>
        <tag>智能对抗</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>云雀</title>
    <url>/2019/09/18/%E4%BA%91%E9%9B%80/</url>
    <content><![CDATA[<p><img src="//aisakaki.com/2019/09/18/云雀/64633930_p0.png" alt="64633930_p0"></p>
<div style="text-align: center"><i>懐かしくあどけない　悲しみを捨ててゆこう</i></div>
<div style="text-align: center"><i>ひとすじ空へ舞い上がる　翼に心をのせて</i></div>
<div style="text-align: center"><i>ねえ　本当はいつだって　一人は寂しいからね</i></div>
<div style="text-align: center"><i>大事なものは　ひとつじゃないの</i></div>
<div style="text-align: center"><i>呼び合っているような　雲雀の声だけ遠く</i></div>
<div style="text-align: center"><i>雲の向こうへ　草原に優しい影を残して</i></div>
<div style="text-align: center"><br> <br>  </div>
<div style="text-align: center"><i>将让人留恋的天真与悲伤都舍弃掉吧</i></div>
<div style="text-align: center"><i>任凭羽翼在碧空中划出舞蹈般的痕迹</i></div>
<div style="text-align: center"><i>其实无论何时 孤独一人终会感到寂寞</i></div>
<div style="text-align: center"><i>珍贵的宝物并非是唯一的</i></div>
<div style="text-align: center"><i>如同呼唤彼此的云雀般 只有遥远的啼鸣</i></div>
<div style="text-align: center"><i>在云之彼方的草原上 留下优雅的掠影</i></div>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>some papers about GAN and AEs in model security</title>
    <url>/2019/09/18/security/</url>
    <content><![CDATA[<p><div style="text-align: center"><i>mainly collected from security conferences and journals，aiming at machine learning model security</i></div><br><a id="more"></a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>year</th>
<th>conf/jour</th>
<th>zone</th>
<th>title</th>
<th>topic</th>
</tr>
</thead>
<tbody>
<tr>
<td>2017</td>
<td>ESORICS</td>
<td>CCF-B</td>
<td>Adversarial examples for malware detection</td>
<td>AE</td>
</tr>
<tr>
<td>2017</td>
<td></td>
<td></td>
<td>Evading machine learning malware detection</td>
<td></td>
</tr>
<tr>
<td>2017</td>
<td></td>
<td></td>
<td>Generating adversarial malware examples for black-box attacks   based on GAN</td>
<td>GAN</td>
</tr>
<tr>
<td>2017</td>
<td>KDD</td>
<td>CCF-A</td>
<td>Adversary resistant deep neural networks with an application   to malware detection</td>
<td>AE</td>
</tr>
<tr>
<td>2018</td>
<td></td>
<td></td>
<td>Adversarial Malware   Binaries: Evading Deep Learning for Malware Detection in Executables</td>
<td></td>
</tr>
<tr>
<td>2018</td>
<td>CoRR</td>
<td></td>
<td>Deceiving end-to-end deep learning malware detectors using   adversarial examples</td>
<td>AE</td>
</tr>
<tr>
<td>2017</td>
<td>RAID</td>
<td>CCF-B</td>
<td>Generic Black-Box   End-to-End Attack Against State of the Art API Call Based Malware   Classifiers</td>
<td></td>
</tr>
<tr>
<td>2018</td>
<td></td>
<td>CCF-B</td>
<td>Zero-day malware   detection using transferred generative adversarial networks based on deep   autoencoders</td>
<td></td>
</tr>
<tr>
<td>2019</td>
<td>USENIX Securit</td>
<td>CCF-A</td>
<td>CT-GAN: Malicious Tampering of 3D Medical Imagery using Deep   Learning</td>
<td>GAN</td>
</tr>
<tr>
<td>2019</td>
<td>USENIX Securit</td>
<td>CCF-A</td>
<td>Misleading Authorship Attribution of Source Code using   Adversarial Learning</td>
<td>AE</td>
</tr>
<tr>
<td>2019</td>
<td>USENIX Securit</td>
<td>CCF-A</td>
<td>Why Do Adversarial   Attacks Transfer? Explaining Transferability of Evasion and Poisoning Attacks</td>
<td></td>
</tr>
<tr>
<td>2018</td>
<td>USENIX Securit</td>
<td>CCF-A</td>
<td>AttriGuard: A Practical   Defense Against Attribute Inference Attacks via Adversarial Machine Learning</td>
<td></td>
</tr>
<tr>
<td>2018</td>
<td>USENIX Securit</td>
<td>CCF-A</td>
<td>A4NT: Author Attribute   Anonymity by Adversarial Training of Neural Machine Translation</td>
<td></td>
</tr>
<tr>
<td>2018</td>
<td>USENIX Securit</td>
<td>CCF-A</td>
<td>Formal Security Analysis of Neural Networks using Symbolic   Intervals</td>
<td>AE</td>
</tr>
<tr>
<td>2016</td>
<td>USENIX Securit</td>
<td>CCF-A</td>
<td>Stealing Machine Learning Models via Prediction APIs</td>
<td></td>
</tr>
<tr>
<td>2019</td>
<td>USENIX Securit</td>
<td>CCF-A</td>
<td>Seeing is Not Believing: Camouflage Attacks on Image Scaling   Algorithms</td>
<td>AE,IMAGE</td>
</tr>
<tr>
<td>2019</td>
<td>TIFS</td>
<td>CCF-A</td>
<td>GANobfuscator: Mitigating Information Leakage Under GAN via   Differential Privacy.</td>
<td>GAN,PI</td>
</tr>
<tr>
<td>2019</td>
<td>TIFS</td>
<td>CCF-A</td>
<td>FV-GAN: Finger Vein Representation Using Generative   Adversarial Networks</td>
<td>GAN,IMAGE</td>
</tr>
<tr>
<td>2018</td>
<td>TIFS</td>
<td>CCF-A</td>
<td>CNN-Based Adversarial Embedding for Image Steganography</td>
<td>AE,IMAGE</td>
</tr>
<tr>
<td>2017</td>
<td>TIFS</td>
<td>CCF-A</td>
<td>No Bot Expects the   DeepCAPTCHA! Introducing Immutable Adversarial Examples, With Applications to   CAPTCHA Generation</td>
<td></td>
</tr>
<tr>
<td>2017</td>
<td>TIFS</td>
<td>CCF-A</td>
<td>A Game-Theoretic Analysis of Adversarial Classification</td>
<td>AE</td>
</tr>
<tr>
<td>2018</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Yet Another Text Captcha   Solver: A Generative Adversarial Network Based Approach</td>
<td></td>
</tr>
<tr>
<td>2018</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Machine Learning with Membership Privacy using Adversarial   Regularization</td>
<td>AE,PI</td>
</tr>
<tr>
<td>2018</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Tutorials:Wild Patterns: Ten Years After the Rise of   Adversarial Machine Learning</td>
<td>AE</td>
</tr>
<tr>
<td>2018</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Towards Understanding the Dynamics of Adversarial Attacks</td>
<td>AE</td>
</tr>
<tr>
<td>2018</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Adversarial Product Review Generation with Word Replacements</td>
<td>AE,NLP</td>
</tr>
<tr>
<td>2018</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Spartan Networks:   Self-Feature-Squeezing Networks for Increased Robustness in Adversarial   Settings</td>
<td></td>
</tr>
<tr>
<td>2017</td>
<td>CCS</td>
<td>CCF-A</td>
<td>DolphinAttack: Inaudible Voice Commands</td>
<td>AE</td>
</tr>
<tr>
<td>2017</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Evading Classifiers by Morphing in the Dark</td>
<td>AE</td>
</tr>
<tr>
<td>2017</td>
<td>CCS</td>
<td>CCF-A</td>
<td>MagNet: A Two-Pronged Defense against Adversarial Examples</td>
<td>AE</td>
</tr>
<tr>
<td>2017</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Practical Attacks Against Graph-based Clustering</td>
<td>AE,IMAGE</td>
</tr>
<tr>
<td>2017</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Automated Crowdturfing Attacks and Defenses in Online Review   Systems</td>
<td>AE,NLP</td>
</tr>
<tr>
<td>2017</td>
<td>CCS</td>
<td>CCF-A</td>
<td>POISED: Spotting Twitter Spam Off the Beaten Paths</td>
<td>AE,NLP</td>
</tr>
<tr>
<td>2017</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Poster: Adversarial Examples for Classifiers in   High-Dimensional Network Data.</td>
<td>AE</td>
</tr>
<tr>
<td>2017</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Deep Models Under the   GAN: Information Leakage from Collaborative Deep Learning</td>
<td></td>
</tr>
<tr>
<td>2016</td>
<td>CCS</td>
<td>CCF-A</td>
<td>Tutorials:Adversarial Data Mining: Big Data Meets Cyber   Security.</td>
<td>AE</td>
</tr>
<tr>
<td>2016</td>
<td>S&amp;P</td>
<td>CCF-A</td>
<td>Distillation as a Defense to Adversarial Perturbations Against   Deep Neural Networks</td>
<td>AE</td>
</tr>
<tr>
<td>2019</td>
<td>AAAI</td>
<td>CCF-A</td>
<td>MIGAN: Malware Image Synthesis Using GANs.</td>
<td>GAN</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>GAN</tag>
        <tag>AE</tag>
        <tag>model-security</tag>
      </tags>
  </entry>
  <entry>
    <title>个人NAS计划</title>
    <url>/2019/08/28/%E4%B8%AA%E4%BA%BANAS%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>眼看着google drive容量即将撑爆..而且9月13号到期<img src="//aisakaki.com/2019/08/28/个人NAS计划/1.png" alt="1"><br>然后一看续费扩容计划…<br> <a id="more"></a><br><img src="//aisakaki.com/2019/08/28/个人NAS计划/2.png" alt="2"></p>
<p>99.99$/1T emmm，家境贫寒，告辞</p>
<p>于是目光投向微软<img src="//aisakaki.com/2019/08/28/个人NAS计划/3.png" alt="3"></p>
<p>。。。。。<br><img src="//aisakaki.com/2019/08/28/个人NAS计划/7.png" alt="7"><br>。<br>。<br>。<br>。<br>。<br>。<br>。<br>。</p>
<p><img src="//aisakaki.com/2019/08/28/个人NAS计划/4.png" alt="4"><br>谷歌我不做人辣！！！</p>
<p>那。。那就组个NAS吧！<br><img src="//aisakaki.com/2019/08/28/个人NAS计划/5.png" alt="5"></p>
<p>学校里有千兆网，还可以秒掉gdrive和onedrive的龟速<br>正好用上以前大二买的台式机淘汰下来的硬件，先记录一下各个组件</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组件</th>
<th>具体型号</th>
<th>价格(元)</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU</td>
<td>9100f</td>
<td>503</td>
</tr>
<tr>
<td>GPU</td>
<td>亮机卡</td>
<td>18</td>
</tr>
<tr>
<td>主板</td>
<td>影驰b360m.2</td>
<td>280</td>
</tr>
<tr>
<td>固态</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>内存</td>
<td>8g+8g(ddr4 2400)</td>
<td>现成</td>
</tr>
<tr>
<td>散热器</td>
<td>ID-COOLING</td>
<td>现成</td>
</tr>
<tr>
<td>硬盘支架</td>
<td></td>
<td>要买</td>
</tr>
<tr>
<td>机箱</td>
<td>Q300L</td>
<td>现成</td>
</tr>
<tr>
<td>电源</td>
<td>VS450</td>
<td>现成</td>
</tr>
<tr>
<td>初始硬盘</td>
<td>WD1T</td>
<td>现成</td>
</tr>
<tr>
<td>数据硬盘</td>
<td>东芝 P300</td>
<td>448</td>
</tr>
<tr>
<td>网线</td>
<td>千兆</td>
<td>现成</td>
</tr>
<tr>
<td>合计</td>
<td></td>
<td>1249</td>
</tr>
</tbody>
</table>
</div>
<p>然后就可以享受千兆上传下载，无缝同步，超大容量的个人云端硬盘了，爽到<br><img src="//aisakaki.com/2019/08/28/个人NAS计划/9.png" alt="9"></p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>高达升级</title>
    <url>/2019/08/16/%E9%AB%98%E8%BE%BE%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p>这个月又对我的台式机PC电脑的几个零件进行了升级，主要是更换了CPU，添加了固态硬盘，而且把原来CPU的单风扇120水冷换成了双风扇夹汉堡。</p>
<p>9900k这货实在是个大火炉，发热量太大了。后来我才发现我忘了设置SYS_FAN的温度检测区域，导致CPU或GPU都热爆了风扇却不全速转起来。</p>
<p>以下为升级后现在的配置：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>硬件</th>
<th></th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU</td>
<td>Inter i9 9900K</td>
<td>主频3.6GHz，睿频5GHz</td>
</tr>
<tr>
<td>CPU散热</td>
<td>恩杰 海妖 X62</td>
<td>280冷排，双AER2 风扇</td>
</tr>
<tr>
<td>内存</td>
<td>海盗船LPX 32G</td>
<td>16G*2  3000GHz</td>
</tr>
<tr>
<td>主板</td>
<td>华擎 Z390 Gaming Phantom</td>
<td>ITX主板</td>
</tr>
<tr>
<td>显卡</td>
<td>Inno RTX 2080Ti</td>
<td>-</td>
</tr>
<tr>
<td>显卡散热</td>
<td>Alphacool 北极狼水冷</td>
<td>240冷排，四be quiet风扇</td>
</tr>
<tr>
<td>硬盘</td>
<td>NVME 固态硬盘：三星970evo Plus</td>
<td>1T</td>
</tr>
<tr>
<td></td>
<td>NVME 固态硬盘：海康威视C2000Pro</td>
<td>2T</td>
</tr>
<tr>
<td></td>
<td>SATAIII 固态硬盘：西部数码 蓝盘</td>
<td>2T</td>
</tr>
<tr>
<td></td>
<td>SATAIII 固态硬盘：英睿达 BX300</td>
<td>0.5T    (MLC颗粒)</td>
</tr>
<tr>
<td></td>
<td>机械硬盘：希捷酷鱼</td>
<td>1T</td>
</tr>
<tr>
<td></td>
<td>机械硬盘：西部数码</td>
<td>1T</td>
</tr>
<tr>
<td>电源</td>
<td>振华 冰山金蝶GX650</td>
<td>650W</td>
</tr>
<tr>
<td>机箱</td>
<td>NZXT MANTA 白色</td>
<td>-</td>
</tr>
<tr>
<td>其他风扇</td>
<td>乔思伯 日食 Plus</td>
<td>后置位一个</td>
</tr>
<tr>
<td>显示器</td>
<td>DELL U2718QM</td>
<td>4K 27英寸</td>
</tr>
<tr>
<td>鼠标</td>
<td>罗技 G903</td>
<td>-</td>
</tr>
<tr>
<td>键盘</td>
<td>IKBC W200</td>
<td>红轴，霜冻之蓝键帽</td>
</tr>
<tr>
<td>机箱手办</td>
<td>美柑</td>
<td>老婆</td>
</tr>
<tr>
<td>耳机</td>
<td>1000XM2</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p>以后考虑上sunmilo T03那款机箱，那个就得改用itx板子（必须双m2位），电源改sfx（+1000），CPU风扇用风冷。现在暂时先不折腾了</p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
  </entry>
  <entry>
    <title>再见，夏天</title>
    <url>/2019/08/11/summer/</url>
    <content><![CDATA[<p><img src="//aisakaki.com/2019/08/11/summer/F845CF3DE17D87ACAEB421026508A8A1.jpg" alt="F845CF3DE17D87ACAEB421026508A8A1"></p>
<div style="text-align: center">朝着大海的列车，在书香，旋律与橘子芬香中，驶向夏天的终点 </div>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>夏天</tag>
      </tags>
  </entry>
  <entry>
    <title>夏休</title>
    <url>/2019/08/05/JSY/</url>
    <content><![CDATA[<p>这个暑假应该是人生最短的一次暑假了</p>
<p>傍晚回到了中学时期住过的小区去看看，保卫大叔竟然一眼认出了我，还和我聊了些以前的事情</p>
<p>我很惊讶那些小事他都记得，</p>
<p>而且明明5年都没有回去过了。</p>
<p>走出大门，蝉鸣声依然密密麻麻。渐行渐远，不一会儿变得窸窸窣窣。</p>
<p>大叔叫我多回来玩，可我回来能去哪呢？</p>
<p>蝉鸣声声响，可夏日并不长。</p>
<p><img src="//aisakaki.com/2019/08/05/JSY/E9C4B851D57299086E6779C064F6C5B6.png" alt="E9C4B851D57299086E6779C064F6C5B6"></p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>Explaining and Harnessing Adversarial Examples</title>
    <url>/2019/07/30/Examples/</url>
    <content><![CDATA[<blockquote>
<p>《Explaining and Harnessing Adversarial Examples》<br>   Ian J. Goodfellow, Jonathon Shlens &amp; Christian Szegedy<br>   ICLR 2015</p>
</blockquote>
<h2 id="为什么会产生对抗样本？"><a href="#为什么会产生对抗样本？" class="headerlink" title="为什么会产生对抗样本？"></a>为什么会产生对抗样本？</h2><p>以前的观点： extreme nonlinearity of DNN and insufﬁcient model averaging and insufﬁcient regularization of the purely supervised learning problem</p>
<p>本文的观点：<strong>Linear behavior</strong> in <strong>high-dimensional spaces</strong> is sufﬁcient to cause adversarial examples</p>
<h2 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h2><ol>
<li><p>Box-constrained L-BFGS can reliably ﬁnd adversarial examples.</p>
</li>
<li><p>On some datasets, such as ImageNet (Deng et al., 2009), the adversarial examples were so close to the original examples that the differences were indistinguishable to the human eye.</p>
</li>
<li><p>The same adversarial example is often misclassiﬁed by avariety of classiﬁers with different architectures or trained on different subsets of the training data.</p>
</li>
<li><p>Shallow softmax regression models are also vulnerable to adversarial examples. </p>
</li>
<li><p>Training on adversarial examples can regularize the model —however , this was not practical at the time due to the need for expensive constrained optimization in the inner loop</p>
</li>
</ol>
<p>这就引起我们怀疑即便当前最好的模型是否只是虚有其表，并没有真正学习到内在的语义信息。仅仅能够fit现有样本，无法泛化。</p>
<h2 id="对抗样本的线性解释"><a href="#对抗样本的线性解释" class="headerlink" title="对抗样本的线性解释"></a>对抗样本的线性解释</h2><p>本文提出了对对抗样本产生原因的线性解释.设置扰动$\eta,\epsilon$为一个小到可以被分类器忽略的值</p>
<p>$\hat{x} = x+\eta$ ，若$||\eta||_\infty&lt;\epsilon$，分类器将无法将$x$与$\hat{x}$分开</p>
<p>则$w^T\hat{x}=w^T(x+\eta)=w^Tx+w^T\eta$</p>
<p>若维度很高，则即使$\eta$很小，也会使得$w^T\eta$非常大，影响分类器的判断</p>
<p>令$\eta=sign(w)$即可使得$w^T\eta$最大</p>
<h2 id="非线性模型的线性扰动"><a href="#非线性模型的线性扰动" class="headerlink" title="非线性模型的线性扰动"></a>非线性模型的线性扰动</h2><p>对于现在的神经网络都有很强的线性性质以至于无法抵抗对抗攻击，如 LSTMs (Hochreiter &amp; Schmidhuber, 1997), ReLUs (Jarrett et al., 2009; Glorot et al., 2011),  maxout networks (Goodfellow et al., 2013c) 都设计得具有很强的线性性质，所以也方便优化。FGSM将损失函数近似线性化，从而获取$||\eta||_\infty&lt;\epsilon$的最优扰动。</p>
<p><strong>Fast Gradient Sign Method(FGSM)</strong></p>
<script type="math/tex; mode=display">
\eta = \epsilon sign(\nabla_xJ(\theta,x,y))​</script><script type="math/tex; mode=display">
\hat{x} = x+\epsilon sign(\nabla_xJ(\theta,x,y))</script><p>注意这里$y=y_{true}$</p>
<p>通过实验证明，作者的假设产生对抗样本的原因是由于模型的线性特性是正确的。这种方法也可以作为一种快速生成对抗样本的方法（即FGSM）</p>
<h2 id="线性模型的对抗训练"><a href="#线性模型的对抗训练" class="headerlink" title="线性模型的对抗训练"></a>线性模型的对抗训练</h2><p>在Logistics Regression上应用FGSM方法 ，$label\in\lbrace1,-1\rbrace$</p>
<p>$P(y=1|x)=\sigma(w^Tx+b),\sigma(z)=softmax(z)$   </p>
<p>$\therefore J = E{x,y \tilde{} p_{data}}[(-\frac{1+y}{2})\ln P(y=1|x)-\frac{1-y}{2}\ln P(y=-1|x)]$</p>
<p>设$p=P(y=1|x),f=w^Tx+b$</p>
<p>$\therefore J=-\frac{1}{2}\ln p-\frac{y}{2}\ln p-\frac{1}{2}\ln (1-p)+\frac{y}{2}\ln (1-p)$</p>
<p>$=-\frac{1}{2}\ln p（1-p)-\frac{y}{2}\ln \frac{p}{1-p} $</p>
<p>$= \frac{1}{2}(f-yf) + \ln(1+e^{-f})$</p>
<p>$=\begin{cases} \ln(1+e^{-f}),y=1\\ f+\ln(1+e^{-f})=\ln e^f+\ln(1+e^{-f})=\ln(1+e^f),y=-1\end{cases}$</p>
<p>$= \ln(1+e^{-yf})$</p>
<p>$=\zeta(-yf)=E{x,y \tilde{} p_{data}}\zeta(-y(w^Tx+b)),\zeta(z) = \ln(1+e^z)$  </p>
<p>$\therefore \eta=\epsilon sign(\nabla_xJ(\theta,x,y))$</p>
<p>$=\epsilon sign(\nabla_x\zeta(-y(w^Tx+b)))$</p>
<p>$= \epsilon sign(\frac{\partial \ln(1+e^{-y(w^Tx+b)})}{\partial x})$</p>
<p>$=\epsilon sign(\frac{1}{1+e^{-y(w^Tx+b)}} ×(-e^{-y(w^Tx+b)})×(yw^T))$</p>
<p>$=\epsilon sign(\frac{e^{-yf}}{1+e^{-yf}}×(-y)w)$</p>
<p>$=\epsilon sign(-w)=-\epsilon sign(w)$</p>
<p>$\because w^Tsign(w)=||w||_1，\hat{x}=x+\eta,\eta=\epsilon-sign(w)$</p>
<p>$\therefore \hat{J}=E{x,y \tilde{} p_{data}}\zeta(y(\epsilon||w||_1 -w^Tx-b))$</p>
<p>可以看到类似于$L^1$正则，不过是减去$L^1$惩罚项。当置信度很高，$w^Tx+b$足够大的时候，$\epsilon||w||_1$几乎不起作用，但是当模型欠拟合的时候，则会更加欠拟合</p>
<h2 id="深度网络的对抗训练"><a href="#深度网络的对抗训练" class="headerlink" title="深度网络的对抗训练"></a>深度网络的对抗训练</h2><p>相比于纯线性模型，深度网络可以在训练网络过程中来抵御对抗攻击。</p>
<script type="math/tex; mode=display">
\hat{J}= \alpha J(\theta,x,y)+(1-\alpha)J(\theta,x+\epsilon sign(\nabla_xJ(\theta,x,y)))</script><p>这种方法在训练中不断更新对抗样本，同时训练。</p>
<h2 id="对抗样本的泛化原因"><a href="#对抗样本的泛化原因" class="headerlink" title="对抗样本的泛化原因"></a>对抗样本的泛化原因</h2><p>根据线性解释，FGSM可以在连续空间上生成对抗样本，而不是特定的点。作者通过取不同的$\epsilon$值证实了这一点。</p>
<p>为什么不同的分类器会将对抗样本误分到同一类？因为作者假设的模型都在训练集的不同子集上训练，模型泛化后学得的参数差不多，具有一定的稳定性，导致对抗样本也具有稳定性。</p>
]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>对抗样本</tag>
        <tag>智能对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>Pray for Kyoto Animation</title>
    <url>/2019/07/27/Animation/</url>
    <content><![CDATA[<p><img src="//aisakaki.com/2019/07/27/Animation/QQ图片20190726230738.jpg" alt="QQ图片20190726230738"></p>
<div style="text-align: center">你们一直伴随着我的青春时光，生命却止步于此。 </div>

<div style="text-align: center">R.I.P. 为动画世界奉献了青春的你们。 </div>



]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>京阿尼</tag>
      </tags>
  </entry>
  <entry>
    <title>mini-batch 在网络里的并行计算</title>
    <url>/2019/07/26/mini-batch/</url>
    <content><![CDATA[<p>使用小批量可以</p>
<p>①<strong>提高模型的训练速度，不用过于频繁地计算参数</strong>。通过经验风险最小化由一组样本并行计算并共同决定这批数据的梯度方向</p>
<p> ②<strong>引入随机性以避免陷入局部极值</strong></p>
<p>具体到设计网络，以RNN为例（RNN与CNN相比的输入是反常的）</p>
<p>输入节点为$x$,隐藏层节点为$h$，输出节点为$o$。设vec_size = v, hidden_size = h, batch_size = 2,则设定参数矩阵(省略偏移)</p>
<script type="math/tex; mode=display">W_{xh}=W_{v*h} , W_{hh}=W_{h*h}, W_{ho}=W_{h*o} ， seq_a = [a_0,a_1,a_2],seq_b = [b_0,b_1,b_2]</script><p>于是一个mini-batch为<script type="math/tex">[[a_0,b_0],[a_1,b_1],[a_2,b_2]]_{3*2*v}</script></p>
<p>对其进行迭代，则$t_0$时刻输入矩阵<script type="math/tex">X^{t_0}=[a_0,b_0]=[a^{t_0}_{1*v},b^{t_0}_{1*v}]</script></p>
<p>注意这里在python中的表示用数学表示形式是一个二维矩阵，</p>
<script type="math/tex; mode=display">
Input=
X^{t_0} = X_{2*v} = 
\begin{bmatrix}
{a_{1*v}}\\{b_{1*v}}
\end{bmatrix}</script><p>于是一次循环：</p>
<script type="math/tex; mode=display">
Hidden=
\sigma (X^{t_0}×W_{xh} + H^{(t_0-1)}×W_{hh})=\sigma(X_{2*v}×W_{v*h}+ H^{(t_0-1)}_{2*h}×W_{h*h})</script><script type="math/tex; mode=display">
= \sigma(
\begin{bmatrix}
a^{t_0}_{1*v}×W_{v*h}\\  
b^{t_0}_{1*v}×W_{v*h}
\end{bmatrix}
+
\begin{bmatrix}H^{(t_0-1)}_{1*h}×W_{h*h}\\ 
H^{(t_0-1)}_{1*h}×W_{h*h}
\end{bmatrix}
)</script><script type="math/tex; mode=display">
=
\begin{bmatrix}
{h^{a_0}_{1*h}}\\{h^{b_0}_{1*h}}
\end{bmatrix}
=H^{(t_0)}_{2*h}</script><script type="math/tex; mode=display">
Output=
H^{(t_0)}_{2*h}×W_{h*o} = 
\begin{bmatrix}
{h^{a_0}_{1*h}×W_{h*o}}\\
{h^{b_0}_{1*h}×W_{h*o}}
\end{bmatrix}</script><script type="math/tex; mode=display">
=
\begin{bmatrix}
{o^{a_0}_{1*o}}\\{o^{b_0}_{1*o}}
\end{bmatrix}
=O^{t_0}_{2*o}</script><p>由此可看出，在矩阵相乘的规则下，相当于将不同的$seq$样本同时加载进网络中同时并行计算。</p>
<p>通过一段时间将mini-batch全部加载进循环神经网络，通过loss function再平均作为mini-batch的loss，再作BPTT，就可以求出此mini-batch的梯度。</p>
<p>对于CNN，也是一样的原理同时处理一个mini-batch的所有图片，只不过其输入方式与处理方式有所不同。</p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>mini-batch</tag>
      </tags>
  </entry>
  <entry>
    <title>RNN做批</title>
    <url>/2019/07/25/RNN%E5%81%9A%E6%89%B9/</url>
    <content><![CDATA[<p>输入RNN的是时间序列，与CNN是<strong>反过来</strong>的。CNN的输入是输入(batch_size,$C_{in},H_{in},W_{in}$)，而RNN的输入是(seq_len, batch_size, input_size)，batch_size位于第二维度。</p>
<p>在CNN中我们是要在同一时间里输入batch里每张图，而在RNN里我们是要在同一时刻输入一个batch里每个序列的同一个位置。</p>
<p>训练每个batch后，使用ERM进行BP计算，与CNN一样</p>
<p>以下画图理解，注意紫色是实体结构</p>
<p><img src="//aisakaki.com/2019/07/25/RNN做批/0.png" alt="0"></p>
<p>于是对于一个可迭代的dataloader</p>
<p><img src="//aisakaki.com/2019/07/25/RNN做批/RNN输入结构2.png" alt="RNN输入结构2"></p>
<p>对语料矩阵进行转置后可以更快捷方便生批</p>
<p><img src="//aisakaki.com/2019/07/25/RNN做批/RNN快捷生批.png" alt="RNN快捷生批"></p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>我永远喜欢间桐樱</title>
    <url>/2019/07/15/%E6%88%91%E6%B0%B8%E8%BF%9C%E5%96%9C%E6%AC%A2%E9%97%B4%E6%A1%90%E6%A8%B1-jpg/</url>
    <content><![CDATA[<p><img src="//aisakaki.com/2019/07/15/我永远喜欢间桐樱-jpg/53357546_p0.png" alt="53357546_p0"></p>
]]></content>
      <categories>
        <category>Anime</category>
      </categories>
      <tags>
        <tag>老婆</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch获取中间层参数、输出与可视化</title>
    <url>/2019/07/10/pytorch%E8%8E%B7%E5%8F%96%E4%B8%AD%E9%97%B4%E5%B1%82%E5%8F%82%E6%95%B0%E3%80%81%E8%BE%93%E5%87%BA%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h2 id="获取模型中间层的权重和其他参数"><a href="#获取模型中间层的权重和其他参数" class="headerlink" title="获取模型中间层的权重和其他参数"></a>获取模型中间层的权重和其他参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先设定如下网络</span></span><br><span class="line"><span class="comment">#定义网络结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">	    self.c1 = nn.Sequential(</span><br><span class="line">	    nn.Conv2d(<span class="number">3</span>,<span class="number">16</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>), </span><br><span class="line">	    nn.ReLU()</span><br><span class="line">	        ) </span><br><span class="line">	    self.c2 = nn.Sequential(</span><br><span class="line">	        nn.Conv2d(<span class="number">16</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>), </span><br><span class="line">	        nn.ReLU(),</span><br><span class="line">	    )</span><br><span class="line">	    self.fc = nn.Linear(<span class="number">2097152</span>,<span class="number">2</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">	    x = self.c1(x)</span><br><span class="line">	    x = self.c2(x)</span><br><span class="line">	    x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>) </span><br><span class="line">	    x = self.fc(x) </span><br><span class="line">	    <span class="keyword">return</span> x    </span><br><span class="line">model = net()</span><br><span class="line">model = model.cuda()</span><br><span class="line"><span class="comment">#载入先前训练好并保存的模型权重</span></span><br><span class="line">model.load_state_dict(torch.load(<span class="string">'model_wts.pkl'</span>))</span><br><span class="line"><span class="comment">#此时网络的结构为</span></span><br><span class="line">model</span><br><span class="line">&gt;&gt;</span><br><span class="line">net(</span><br><span class="line">  (c1): Sequential(</span><br><span class="line">    (<span class="number">0</span>): Conv2d(<span class="number">3</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">    (<span class="number">1</span>): ReLU()</span><br><span class="line">  )</span><br><span class="line">  (c2): Sequential(</span><br><span class="line">    (<span class="number">0</span>): Conv2d(<span class="number">16</span>, <span class="number">32</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">    (<span class="number">1</span>): ReLU()</span><br><span class="line">  )</span><br><span class="line">  (fc): Linear(in_features=<span class="number">2097152</span>, out_features=<span class="number">2</span>, bias=<span class="keyword">True</span>)</span><br><span class="line">)</span><br><span class="line">	</span><br><span class="line"><span class="comment">#获取某一层</span></span><br><span class="line">model.c1</span><br><span class="line">&gt;&gt;</span><br><span class="line">Sequential(</span><br><span class="line">  (<span class="number">0</span>): Conv2d(<span class="number">3</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">  (<span class="number">1</span>): ReLU()</span><br><span class="line">)</span><br><span class="line">model.fc</span><br><span class="line">&gt;&gt;</span><br><span class="line">Linear(in_features=<span class="number">1048576</span>, out_features=<span class="number">2</span>, bias=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment">#获取Sequential里的子层</span></span><br><span class="line">model.c1[<span class="number">0</span>]</span><br><span class="line">&gt;&gt;</span><br><span class="line">Conv2d(<span class="number">3</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">#获得某层的权重</span></span><br><span class="line">model.c1[<span class="number">0</span>].weight</span><br><span class="line">&gt;&gt;</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([[[[ <span class="number">2.7182e-03</span>, <span class="number">-8.7767e-03</span>,  <span class="number">3.2988e-02</span>, <span class="number">-1.0006e-01</span>, <span class="number">-1.1177e-01</span>],</span><br><span class="line">          [<span class="number">-2.9155e-02</span>, <span class="number">-6.2152e-02</span>,  <span class="number">4.1465e-02</span>, <span class="number">-4.5812e-02</span>,  <span class="number">6.7885e-02</span>],</span><br><span class="line">          [<span class="number">-1.0680e-01</span>, <span class="number">-1.0023e-01</span>, <span class="number">-1.7158e-02</span>, <span class="number">-1.3828e-02</span>,  <span class="number">5.7319e-02</span>],</span><br><span class="line">          [ <span class="number">5.1668e-02</span>, <span class="number">-4.2982e-02</span>,  <span class="number">2.7770e-02</span>, <span class="number">-1.1801e-01</span>,  <span class="number">7.9863e-02</span>],</span><br><span class="line">          [ <span class="number">1.1050e-01</span>,  <span class="number">2.4979e-02</span>,  <span class="number">5.1047e-03</span>, <span class="number">-4.6120e-02</span>, <span class="number">-9.9121e-02</span>]],</span><br><span class="line">··························<span class="comment">#省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line">model.c1[<span class="number">0</span>].parameters()为该层的参数，包含梯度等等</span><br><span class="line">parameters()输出的参数在训练的时候需要传入优化器，比如在训练网络的时候，model的所有参数</span><br><span class="line">都要传入优化器，则是 optimizer = torch.optim.Adam(model.parameters(),lr=LR)</span><br><span class="line">又如下面一条迁移学习，只要训练最后一层，就只将最后一层的参数传入了优化器</span><br><span class="line"></span><br><span class="line"><span class="comment">#层的迭代器</span></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> model.SequentialName.children():</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="comment">#应用方法可以见下面迁移学习部分</span></span><br></pre></td></tr></table></figure>
 <a id="more"></a>
<h2 id="所以如果要进行迁移学习"><a href="#所以如果要进行迁移学习" class="headerlink" title="所以如果要进行迁移学习"></a>所以如果要进行<strong>迁移学习</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以VGG举例</span></span><br><span class="line">VGG的结构为</span><br><span class="line">VGG&#123;</span><br><span class="line">(features):Sequential(....略....)</span><br><span class="line">(classifier):Sequntial(....略.........(6)Linear(4096-&gt;1000))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里采用预训练的，[创建vgg网络实例]</span></span><br><span class="line">vgg = models.vgg16(pretrained=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment">#[设置冻结层](只改变classifier里的最后一个线性层，特征提取层不变）</span></span><br><span class="line"><span class="comment">#冻结住特征提取层(vgg取名叫features)的参数</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> vgg.features.parameters():</span><br><span class="line">	param.requires_grad=<span class="keyword">False</span></span><br><span class="line"><span class="comment">#[微调模型]（只改变最后一层fc层，将1000类分类变为我想要的2类分类）</span></span><br><span class="line"><span class="comment">#注意如果用vgg.classifier[6].out_features = 2的话以后会遇到问题，输出还是1000种类</span></span><br><span class="line">   vgg.classifier[<span class="number">6</span>] = nn.Linear(<span class="number">4096</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#优化器设置 （由于我们直接用预训练的权重，所以只需要训练分类器的参数，所以只将最后一个分类器层的classifier.parameters传入优化器）</span></span><br><span class="line">optimizer = optim.SGD(vgg.classifier.parameters(),lr=<span class="number">0.0001</span>,momentum=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#还可以继续对模型进行一些修改，比如修改最后一层中的dropout</span></span><br><span class="line"><span class="comment">#这里使用了迭代器</span></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> vgg.classifier.children():</span><br><span class="line">	<span class="keyword">if</span> (type(layer) == nn.Dropout):</span><br><span class="line">		layer.p=<span class="number">0.2</span></span><br></pre></td></tr></table></figure>
<h2 id="使用pytorch-hook进行中间层输出与可视化"><a href="#使用pytorch-hook进行中间层输出与可视化" class="headerlink" title="使用pytorch hook进行中间层输出与可视化"></a>使用pytorch hook进行中间层输出与可视化</h2><p>（这里hook上面第一节中创建的网络）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义用于hook的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayerActivations</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment">#定义这个变量用于储存结果</span></span><br><span class="line">	features = <span class="keyword">None</span></span><br><span class="line">	<span class="comment">#类初始化。当前向传播的时候（即图像数据通过层传输的时候），调用register_forward_hook方法。</span></span><br><span class="line">	<span class="comment">#register_forward_hook方法即为[钩子]，此方法返回一个句柄保存到self.hook</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,model,layer_num)</span>:</span></span><br><span class="line">		self.hook = model[layer_num].register_forward_hook(self.hook_fn)</span><br><span class="line">	<span class="comment">#hook函数具体执行的方法，即hook方法</span></span><br><span class="line">	<span class="comment">#register_forward_hook将三个参数传入hook_fn方法内</span></span><br><span class="line">	<span class="comment">#module:允许访问层本身 input:流进层的数据 output:层变换后的流出的数据或激活</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">hook_fn</span><span class="params">(self,module,input,output)</span>:</span></span><br><span class="line">		<span class="comment">#将输出保存到[自己设置的features变量中]</span></span><br><span class="line">		self.features = output.cpu()</span><br><span class="line">	<span class="comment">#注销句柄self.hook</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.hook.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义hook类实例</span></span><br><span class="line">conv_out = LayerActivations(model.c1,<span class="number">0</span>)</span><br><span class="line"><span class="comment">#运行模型</span></span><br><span class="line">output = model(img)</span><br><span class="line"><span class="comment">#注销函数</span></span><br><span class="line">conv_out.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在hook class中被保存到了features变量的即为输出，自己定义的</span></span><br><span class="line">activations = conv_out.features</span><br><span class="line"></span><br><span class="line"><span class="comment">#activations 即为层输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对其进行可视化</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>,<span class="number">50</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0</span>,right=<span class="number">1</span>,bottom=<span class="number">0</span>,top=<span class="number">0.8</span>,hspace=<span class="number">0</span>,wspace=<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">ax = fig.add_subplot(<span class="number">12</span>,<span class="number">5</span>,i+<span class="number">1</span>,xticks=[],yticks=[])</span><br><span class="line">ax.imshow(activations[<span class="number">0</span>][i].detach().numpy())</span><br></pre></td></tr></table></figure>
<h2 id="中间层参数可视化"><a href="#中间层参数可视化" class="headerlink" title="中间层参数可视化"></a>中间层参数可视化</h2><p>有两种方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法一</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> nn.parameters():</span><br><span class="line">	xxx</span><br><span class="line"><span class="comment">#方法二</span></span><br><span class="line">weight = model.state_dict()[<span class="string">'features.0.weight'</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>n-gram实践</title>
    <url>/2019/05/29/n-gram%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>对于加固的应用，可以用通过在沙箱穷举各种可能操作返回的API操作序列来建立模型，处理API序列可以用N-gram来分析语义。</p>
<p>发现网上好像很少有用中文说明具体使用，所以记录一下。</p>
<p>n-gram处理之后，实际上是把句子<strong>划分为</strong>不同的gram！</p>
<p>以2元词 2-gram（bigram为例）</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">class Phrases(sentences=None, min_count=5, threshold=10.0, max_vocab_size=40000000, delimiter=None, progress_per=10000, scoring="default", common_terms=frozenset)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">corpusList = [<span class="string">'我'</span>,<span class="string">'爱'</span>,<span class="string">'你'</span>,<span class="string">'爱'</span>,<span class="string">'你'</span>,<span class="string">'我'</span>,<span class="string">'爱'</span>],[<span class="string">'我'</span>,<span class="string">'也'</span>,<span class="string">'爱'</span>,<span class="string">'你'</span>]</span><br><span class="line">bigram = Phrases(corpusList, min_count=<span class="number">1</span>, threshold=<span class="number">0.01</span>, delimiter=<span class="string">b'~'</span>)</span><br><span class="line"></span><br><span class="line">texts = [bigram[line] <span class="keyword">for</span> line <span class="keyword">in</span> corpusList]</span><br><span class="line">dictionary = corpora.Dictionary(texts)</span><br><span class="line">corpus = [dictionary.doc2bow(text) <span class="keyword">for</span> text <span class="keyword">in</span> texts]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出划分结果</span></span><br><span class="line">corpus</span><br><span class="line">&gt;&gt;[[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>)], [(<span class="number">2</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">1</span>)]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出标签</span></span><br><span class="line">dictionary.token2id</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#123;<span class="string">'也'</span>: <span class="number">3</span>, <span class="string">'你'</span>: <span class="number">0</span>, <span class="string">'我'</span>: <span class="number">4</span>, <span class="string">'我~爱'</span>: <span class="number">1</span>, <span class="string">'爱~你'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<p>处理过程<br>①对语料库corpusList（<strong>document</strong>）内每个句子（<strong>text</strong>）以大小为2的窗口进行滑动，</p>
<p>句子1：我爱 爱你 你爱 爱你 你我 我爱</p>
<p>句子2：我也 也爱 爱你</p>
<p>统计两两出现次数（整个语料库），得到<br>我爱：2   爱你：3   你爱：1   你我：1   我也：1   也爱：1</p>
<p>（<strong>delimiter</strong>=b’~’参数规定了2-gram的命名方式，两个词以<code>~</code>为连接符号。这里后面就省略连接符号方便看）</p>
<p>②<strong>min_count</strong>:Ignore <strong>all words and bigrams</strong> with <strong>total collected</strong> count <strong>lower than</strong> this value.</p>
<p>表示一个2-gram<strong>最少必须大于</strong>的频数，频数<strong>小于等于2 的</strong>2-gram就不以此为划分，于是变成<br>我爱：2   爱你：3 </p>
<p><strong>threshold</strong>:  Represent a <strong>score threshold</strong> for forming the phrases (higher means fewer phrases)</p>
<p>score评分方法见 附录[1]，这里设置threshold为0.01非常小的目的就是不考虑阈值参数</p>
<p>于是“我~爱”将被ignore，“爱~我”能够保留</p>
<p>③开始划分<br>句子1：<u>我爱</u> 你 <u>爱你</u> <u>我爱</u><br>句子2：我 也 <u>爱你</u></p>
<p><strong>未被划分到2-gram的，就是单字频数</strong></p>
<p>于是用<strong>doc2bow</strong>转换为词袋后，词频列表为</p>
<p>句子1：  我爱：2，爱你：1，你：1</p>
<p>句子2：  爱你：1，我：1，也：1</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol>
<li>这个score有两种计算公式，默认使用Efficient Estimaton of Word Representations in Vector Space算法</li>
</ol>
<script type="math/tex; mode=display">
\frac{(count(worda\quad followed\quad by\quad wordb) - mincount) * N }{(count(worda) * count(wordb))} > threshold, where\quad N\quad is\quad the\quad total\quad vocabulary\quad size.</script><p>，另一种是npmi(ormalized pointwise mutual information, from “Normalized (Pointwise) Mutual)</p>
<p>可以通过设置score参数选择评价方式</p>
]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>n-gram</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>训练集增补后两个非常诡异的错误</title>
    <url>/2019/05/08/Pytorch-cuda-runtime-error-59-device-side-assert-triggered-at-pytorch-aten-src-THC-generic-THCT-%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>这错误原因说了等于没说，完全不知道问题出在哪，只能靠 <code>想 象 力</code></p>
<ol>
<li><p><code>Pytorch: cuda runtime error (59) : device-side assert triggered at /pytorch/aten/src/THC/generic/THCT........</code>错误</p>
<p>在新增了一个类别进入训练集之后（5+1）出现了非常奇怪的CUDA报错</p>
<p>这个错误原因一般是①网络输出的label和标签（训练集种类）数量应该相同</p>
<p>②是否存在-1标签</p>
<p>我的最后一层应该<code>nn.Linear(32768, 5)</code>改为<code>nn.Linear(32768, 6)</code></p>
<p>很容易忽略很隐蔽的错误！而且这个错误定位并不准。找了我半天时间，</p>
</li>
<li><p><code>DataLoader worker (pid 20991) is killed by signal: Killed.</code></p>
<p>检查内存，CPU %MEM一直在增加，跑了很多次都同样出错</p>
<p><code>Out of memory</code>了</p>
<p>查阅了很多资料，github上有些人也遇到这个问题，有说是因为后台线程设置太多，也以后说enumerate写法问题，还有个说是pytorch的问题</p>
<blockquote>
<p> a lot of those issues are because of third party libraries not being fork safe. One alternative resolution might be to use the spawn start method.</p>
</blockquote>
<p>最后将子线程设置为1解决</p>
<p><code>N M B</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>fixed不生效</title>
    <url>/2019/04/19/fixed%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<p>&#160; &#160; &#160; &#160;在ios上，<code>background-attachment: fixed;</code>标签失效，导致背景图无法自适应屏幕。</p>
<p>&#160; &#160; &#160; &#160;解决办法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">' '</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(/images/4.jpg) center <span class="number">0</span> no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序语言</category>
        <category>HTML/JS/CSS</category>
      </categories>
      <tags>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>塞尔达传说：荒野之息</title>
    <url>/2019/04/15/%E5%A1%9E%E5%B0%94%E8%BE%BE%E4%BC%A0%E8%AF%B4%EF%BC%9A%E8%8D%92%E9%87%8E%E4%B9%8B%E6%81%AF/</url>
    <content><![CDATA[<h2 id="传奇的诞生"><a href="#传奇的诞生" class="headerlink" title="传奇的诞生"></a>传奇的诞生</h2><p>&#160; &#160; &#160; &#160;这款游戏一出生，就轰动了整个游戏界。</p>
<p>&#160; &#160; &#160; &#160;几乎所有重要游戏媒体都给出满分评价，在mc（metacritic，综合所有游戏媒体给出综合平均分）上获取高达98分的平均分。在人类游戏史上排名第二（并列），毫无悬念地摘获了2017年由TGA（The Game Awards，游戏界的奥斯卡）颁发的GOTY（Game Of The Year，年度最佳游戏），同时斩获TGA最佳游戏设计、TGA最佳动作冒险游戏，GS年度最佳游戏，EDGE年度最佳游戏，GDC最佳游戏音效奖、最佳游戏设计奖和年度游戏奖，SXSW最佳游戏性奖、最佳游戏设计奖和年度最佳游戏。</p>
<p><img src="//aisakaki.com/2019/04/15/塞尔达传说：荒野之息/1.jpg" alt="1"><br> <a id="more"></a></p>
<p>&#160; &#160; &#160; &#160;媒体，玩家，游戏界一致好评的背后，是游戏设计理念的极致，是任天堂的无数心血——<br><img src="//aisakaki.com/2019/04/15/塞尔达传说：荒野之息/2.jpg" alt="2"></p>
<h2 id="重新定义开放世界"><a href="#重新定义开放世界" class="headerlink" title="重新定义开放世界"></a>重新定义开放世界</h2><p>&#160; &#160; &#160; &#160;公式化开放世界大行其道，玩家已经开始产生厌倦。公式化开放世界的意思就是流水化式地生产出一个开放世界，整个游戏的设计就有寥寥几种模式，而且这几种模式的变化很小，内容填充少。比如说任务类型就是跟踪、刺杀、跑路这几种，演出就几段毫无营养的对话和随便的故事背景。游戏内容看似很多，但其实大多都是重复（说你呢某球），玩家就在不断重复地玩游戏，像做作业一样慢慢清点清任务。<br>&#160; &#160; &#160; &#160;然而荒野之息打破了这种模式。那么任天堂是如何让玩家在开放世界中不感到乏味呢？</p>
<h2 id="互动与自由"><a href="#互动与自由" class="headerlink" title="互动与自由"></a>互动与自由</h2><p><img src="//aisakaki.com/2019/04/15/塞尔达传说：荒野之息/3.jpg" alt="3"><br>&#160; &#160; &#160; &#160;无数的互动，你想得到的想不到的，让塞尔达这个世界仿佛和真实世界一般自然。<br>&#160; &#160; &#160; &#160;塞尔达中的互动实在过多，这里以火举例子。<br>&#160; &#160; &#160; &#160;在塞尔达中，你可以用木棒去引火而得到火，也可以靠铁质的武器打打火石来生火。火可以用来作为照明，也可以用来点燃一切草木以及木材做的东西（也很容易不小心就点燃到易燃物）。在寒冷之地，火可以暖身子，融化冰块，可以生火来烤熟食物。<br>&#160; &#160; &#160; &#160;你以为这样就足够了吗？<br>&#160; &#160; &#160; &#160;在荒野之息中，火还具有传递性。如果你在森林里放一把火，那可能你扭头一会儿，会发现一片森林被你烧了。如果此时有大风吹过的话，火势会蔓延地更快（放火烧山牢底坐穿（））<br>&#160; &#160; &#160; &#160;不仅如此，如果你点燃了大片的草地，可以制造出上升气流，这时候你打开降落伞，就可以随着上升气流飞到空中（然后就可以空中偷袭敌人，或者说到高处去（当然塞尔达的任何悬崖峭壁都可以直接攀爬））<br>&#160; &#160; &#160; &#160;不仅如此，你甚至可以通过火苗的摆动来判别风向和风力，借此来判断如何射弓箭能够射的更准（塞尔达的弓箭会根据被风向和风力干扰，会受重力干扰）。如果你的弓箭上带火焰，那被弓箭射杀的动物将会直接被烤熟（然后就可以直接吃，塞尔达的很多肉类不能生吃需要料理加工）<br>&#160; &#160; &#160; &#160;不仅如此，如果敌人举着木盾，你拿个火把（火在武器上燃火或火剑）甚至能够将敌人的木盾给烧起来，当然如果你自己的武器烧起来也会被烧成灰烬。<br>&#160; &#160; &#160; &#160;以上仅仅为举了一个小小的火为例，荒野之息的世界中还有无数多的细节和互动，比如天气系统，冷热饥饿，敌人的AI，料理系统等等…<br>&#160; &#160; &#160; &#160;仿佛这个世界中的所有的东西之间都能互相影响，各种物理化学原理，在荒野之息显得格外真实。</p>
<h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>&#160; &#160; &#160; &#160;对于开放世界游戏来说，如何让玩家获得探索的乐趣极为重要。荒野之息在这点上可谓做到了精妙的地步。<br>&#160; &#160; &#160; &#160;对于荒野之息探索与内容设计这块，可以从非常专业的角度来分析，比如参考这篇文章<a href="https://www.iyingdi.com/web/article/search/62084?remark=user" target="_blank" rel="noopener">https://www.iyingdi.com/web/article/search/62084?remark=user</a> 这里我仅仅以玩家的角度来举例说明————<br>&#160; &#160; &#160; &#160;荒野之息给人的感觉就是一个时时刻刻都充满未知的游戏。<br>&#160; &#160; &#160; &#160;你可能在路上看到个蔬菜，然后自己放点配菜瞎炒一下，竟然做出了一道新菜。<br>&#160; &#160; &#160; &#160;你可能走着走着天空中突然出现了一条雷龙，俯冲过你头上，你甚至还能攻击它。<br>&#160; &#160; &#160; &#160;你可能发现一座无名小山，你好奇的上去看，竟然在上面发现了一个花园。<br>&#160; &#160; &#160; &#160;你可能不小心把农民的地烧了，回头发现农民伤心的哭了..<br>&#160; &#160; &#160; &#160;你可能发现你把骷髅兵的头打掉了之后，骷髅兵到处乱跑 找到了自己的头又装上了<br>&#160; &#160; &#160; &#160;……<br>&#160; &#160; &#160; &#160;如此种种，实在是太多了无法列举。而这些，没有人强迫你去看，他们都等着你自己主动（一不小心）就发现。所以在塞尔达的世界里，想做什么就去做吧，不要被传统游戏的经验所束缚，你会收获很多惊喜。<br>&#160; &#160; &#160; &#160;在旅途中，你将会一直接触新鲜事物，即使你游山玩水慢慢打，100多个小时你也会全程保持新鲜和探索欲望。<br><img src="//aisakaki.com/2019/04/15/塞尔达传说：荒野之息/4.jpg" alt="4"></p>
<h2 id="关卡设计"><a href="#关卡设计" class="headerlink" title="关卡设计"></a>关卡设计</h2><p>任天堂的脑洞无可质疑，过于牛逼，无法表达。</p>
<h2 id="美术风格"><a href="#美术风格" class="headerlink" title="美术风格"></a>美术风格</h2><p><img src="//aisakaki.com/2019/04/15/塞尔达传说：荒野之息/5.jpg" alt="5"><br><img src="//aisakaki.com/2019/04/15/塞尔达传说：荒野之息/6.jpg" alt="6"><br><img src="//aisakaki.com/2019/04/15/塞尔达传说：荒野之息/7.jpg" alt="7"><br><img src="//aisakaki.com/2019/04/15/塞尔达传说：荒野之息/8.jpg" alt="8"><br>&#160; &#160; &#160; &#160;看图，过于美丽，无法表达。</p>
<h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>&#160; &#160; &#160; &#160;如果你是塞尔达系列的老玩家，你期盼一个比前作更强的解密的话，你可能会略微失望，荒野之息的大迷宫只有4个，小迷宫倒是有120个遍布世界各地，谜题的难度和设计上确实是没有前作塞尔达厉害，毕竟荒野之息相比前作塞尔达是完全的革新。但是与解密游戏来说，已经属于极为优秀了。</p>
<h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><p>&#160; &#160; &#160; &#160;大部分曲目采用了钢琴为主，但所有曲目的共同点就是，如同荒野之息这个游戏一样，给人以如同看到辽阔无人的荒野一般的感受。与环境配合恰到好处。对于音乐部分也可以开一个专栏赏析，这里就不作过多分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&#160; &#160; &#160; &#160;<strong>8说了，说就是天下第一。</strong></p>
<p><em>此文同步发布在社团公众号</em></p>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>天下第一</tag>
      </tags>
  </entry>
  <entry>
    <title>古都</title>
    <url>/2019/04/12/%E5%8F%A4%E9%83%BD/</url>
    <content><![CDATA[<blockquote>
<p>“对美的幻影，总没有厌倦的时候吧。幻影是不能践踏的，践踏了只能自食其果。”</p>
<p align="right">——《古都》 川端康成 </p>

</blockquote>
<p>&#160; &#160; &#160; &#160;川端先生不愧是日本传统美学的集大成者。</p>
<p>&#160; &#160; &#160; &#160;18~20岁是第一次真正的感受到半遮面的现实的年纪。这些脆弱而细腻，复杂但单纯的情感，在川端先生的笔下如泉水一般汨汨而出，交织出一首含蓄的诗。好像每一句话都氤氲着回音。</p>
<p>&#160; &#160; &#160; &#160;自在飞花轻似梦，无边细雨思如愁。</p>
<p>&#160; &#160; &#160; &#160;在最美好的年纪，一切都终将会消散。纵使韶华易逝，但美犹存。是幻影，是执念。</p>
<p>&#160; &#160; &#160; &#160;无论是千重子，还是雪，亦或是古都——</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>川端康成</tag>
      </tags>
  </entry>
  <entry>
    <title>Word2Vec</title>
    <url>/2019/04/10/%E8%AF%8D%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<h2 id="什么是词向量"><a href="#什么是词向量" class="headerlink" title="什么是词向量"></a>什么是词向量</h2><p>一种词的表示方法。通常NLP中使用one-hot或词向量表示</p>
<p>one-hot即为一维一词，占用空间大，且无法体现词之间的关联性</p>
<p>于是使用词向量可以包含更多信息，且使得向量在空间的表示更稠密。</p>
<h2 id="如何生成词向量"><a href="#如何生成词向量" class="headerlink" title="如何生成词向量"></a>如何生成词向量</h2><h3 id="基于统计"><a href="#基于统计" class="headerlink" title="基于统计"></a>基于统计</h3><p>略。</p>
<h3 id="语言模型生成词向量"><a href="#语言模型生成词向量" class="headerlink" title="语言模型生成词向量"></a>语言模型生成词向量</h3><ul>
<li><p>NNLM（neural network language model）</p>
<p><img src="//aisakaki.com/2019/04/10/词向量/0.png" alt="0"></p>
<p>目标函数</p>
<p>$L=\frac{1}{T}\Sigma^T_{t=1}f(w_t,w_{t-1},…,w{t-n+1})$</p>
<p>这个函数即目标将每一步的文档集的平均输出概率最大化。</p>
<p>但是这个模型在softmax层占用过多资源（与词表长度成正比）。</p>
<p>这个模型虽然现在不使用了，但是却提出了一个很有意义的思路，embedding层，中间层，softmax层（除外）。后面word2vec会详细展开。</p>
</li>
<li><p>C&amp;W</p>
<p>基于NNLM改变了目标函数，$L=max(0,1-(g_{\theta,E}(s)-g_{\theta,E}(z)))$</p>
<p>原NNLM 模型的目标是构建一个语言概率模型 ，而 C&amp;W 则是以生成词向量为目标的模型。 在 NNLM 模型的求解中，最费时的部分当属隐藏层到输出层的权重计算(softmax层)。由于C&amp;W 模型没有采用语言模型的方式去求解词语上下文的条件概率，而是直接对 n 元短语打分，这是一种更为快速获取词向量的方式。C&amp;W 模型的核心机理是 : 如果 n 元短语在语料库中出现过，那么模型会给该短语打高分;如果是未出现在语料库中的短语则会得到较低的评分，将这两者的输出值差异最大化。</p>
</li>
<li><p><strong>Word2Vec</strong></p>
<p>其中包含①CBoW ②skip gram</p>
<ul>
<li><p>CBoW</p>
<p>输入为<strong>上下文（窗口）的one-hot</strong><br>比如我们要预测 <em>i love eating coffee</em>里的<em>eating</em><br>则one hot编码： <em>i</em> :0001  <em>love</em>:0010  <em>eating</em>:0100  <em>coffee</em>:1000<br>我们要输入eating的前后文（选择窗口），那么输入网络的就是 0001,0010,1000（对应三个块）</p>
<p><img src="//aisakaki.com/2019/04/10/词向量/word2vec.png" alt="word2vec"></p>
<p>中间那块儿projection layer得到的向量就是词向量，训练矩阵，我们保存了$W$矩阵（训练得到的权重）之后，以后再输入上下文one-hot就能得到对应的词向量了。</p>
<p><strong>由输入层到映射层，降低维度的过程($k \to N$)，就是将one-hot转变为词向量的过程，也就是 word embedding（词嵌入）</strong><br><strong>之所以词向量能够保留上下文信息，就是因为在训练输入的时候，输入了其上下文信息</strong></p>
</li>
<li><p>skip gram</p>
<p>  输入为一个词的one-hot，输出为多个词的one-hot（上下文），然后BP训练即可，相当于CBoW结构反过来，学的依然是$W$权重</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>词向量</tag>
        <tag>word2vec</tag>
      </tags>
  </entry>
  <entry>
    <title>百年孤独</title>
    <url>/2019/04/09/%E7%99%BE%E5%B9%B4%E5%AD%A4%E7%8B%AC/</url>
    <content><![CDATA[<blockquote>
<p>“多年以后，面对行刑队，奥雷里亚诺·布恩迪亚上校将会回想起父亲带他去见识冰块的那个遥远的下午。”</p>
<p>“同一血脉的两个孤独者之间的接近与友谊无涉，却有助于他们承受将两人分离又联合的神秘孤独。”</p>
<p>“奥雷里亚诺平生从未像此刻一般清醒，他忘却了家中的死者，忘却了死者的痛苦，用费尔南达留下的十字木条再次钉死门窗，远离世间一切干扰，因为他知道梅尔基亚德斯的羊皮卷上记载着自己的命运。他发现史前的植物、湿气蒸腾的水洼、发光的昆虫已将房间内一切人类踪迹消除净尽，但羊皮卷仍安然无恙。他顾不得拿到光亮处，就站在原地，仿佛那是用卡斯蒂利亚语写就，仿佛他正站在正午明亮的光线下阅读，开始毫不费力地大声破译。那是他家族的历史，连最琐碎的细节也无一遗漏，百年前由梅尔基亚德斯预先写出。他以自己的母语梵文书写，偶数行套用奥古斯都大帝的私人密码，奇数行择取斯巴达的军用密码。而最后一道防线，奥雷里亚诺在迷上阿玛兰妲·乌尔苏拉时就已隐隐猜到，那便是梅尔基亚德斯并未按照世人的惯常时间来叙述，而是将一个世纪的日常琐碎集中在一起，令所有事件在同一瞬间发生。奥雷里亚诺为这一发现激动不已，逐字逐句高声朗读教皇谕令般的诗行，当年阿尔卡蒂奥曾从梅尔基亚德斯口中听闻，却不知道那是关于自己死亡的预告。他读到羊皮卷中预言世上最美的女人的诞生，她的灵魂与肉身正一起向天飞升；他读到那对遗腹孪生子的来历，他们放弃破译羊皮卷不仅因为缺乏才能和毅力，更是因为时机尚未成熟。读到这里，奥雷里亚诺急于知道自己的身世，跳过几页。此时微风初起，风中充盈着过往的群声嘁喳，旧日天竺葵的昵喃窸窣，无法排遣的怀念来临之前的失望叹息。他对此毫无察觉，因为他发现了关于自己身世的初步线索。他读到一位好色的祖父一时迷了心窍穿越幻象丛生的荒野，寻找一个不会令他幸福的美女。奥雷里亚诺认出了他，沿着亲缘的隐秘小径追寻下去，找到了自己被赋予生命的一刻，那是在一间昏暗的浴室里，蝎子和黄蝴蝶的环绕间，一个工匠在一个因反叛家庭而委身于他的少女身上满足了欲望。他读得如此入神，仍未发觉风势又起，飓风刮落了门窗，掀掉了东面长廊的屋顶，拔出了房屋的地基。到这时，他才发现阿玛兰妲·乌尔苏拉不是他的姐妹，而是他的姨妈，而当年弗朗西斯·德雷克袭击里奥阿查不过是为了促成他们俩在繁复错综的血脉迷宫中彼此寻找，直到孕育出那个注定要终结整个家族的神话般的生物。当马孔多在《圣经》所载那种龙卷风的怒号中化作可怕的瓦砾与尘埃旋涡时，奥雷里亚诺为避免在熟知的事情上浪费时间又跳过十一页，开始破译他正度过的这一刻，译出的内容恰是他当下的经历，预言他正在破解羊皮卷的最后一页，宛如他正在会言语的镜中照影。他再次跳读去寻索自己死亡的日期和情形，但没等看到最后一行便已明白自己不会再走出这房间，因为可以预料这座镜子之城——或蜃景之城——将在奥雷里亚诺·巴比伦全部译出羊皮卷之时被飓风抹去，从世人记忆中根除，羊皮卷上所载一切自永远至永远不会再重复，因为注定经受百年孤独的家族不会有第二次机会在大地上出现。”</p>
</blockquote>
<p>​     “生命从来不曾离开过孤独而独立存在。无论是我们出生、我们成长、我们相爱、还是我们成功失败，直到最后的最后，孤独犹如影子一样存在于生命一隅。”<br>​    百年孤独。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch中自定义Dataset和Dataloader总结</title>
    <url>/2019/04/05/Pytorch%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89Dataset%E5%92%8CDataloader/</url>
    <content><![CDATA[<h2 id="Dataset自定义数据集与DataLoader-数据集加载器"><a href="#Dataset自定义数据集与DataLoader-数据集加载器" class="headerlink" title="Dataset自定义数据集与DataLoader 数据集加载器"></a>Dataset自定义数据集与DataLoader 数据集加载器</h2><p><strong>Dataset定义了数据集的存在，其中包含了每个数据的路径和标签</strong>,<em>dataset类型不是拿来保存的！它只是相当于一个数据集索引器！并没有加载数据或封装数据！</em></p>
<p><strong>Dataloader则定义了指定数据集的加载方法</strong></p>
<p><strong>在对Dataloader进行迭代的时候，Dataset指向的数据集才正式被加载</strong></p>
<h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p>Dataset 定义并加载自己的数据集<br><strong>继承自Dataset</strong>并<strong>必须重写三个函数</strong>：<br><code>__init__(self, )</code>：将任何需要的初始化,比如读取全部数据路径等，不限制参数个数<br><code>__getitem__(self,index)</code>：根据每次调用时的index返回对应元素和标签<br><code>__len__(self)</code>：负责返回数据集中的元素个数</p>
<p>以加载图片数据集为例<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="comment">#结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="comment">#self, 代表可以补充其他自定参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,  )</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#返回最大长度</span></span><br><span class="line">        <span class="keyword">return</span> len</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,index)</span>:</span></span><br><span class="line">        <span class="comment">#返回每次应读取的单个数据</span></span><br><span class="line">        <span class="keyword">return</span> data,label</span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,root,transform=None)</span>:</span></span><br><span class="line">        <span class="comment"># 所有图片的绝对路径</span></span><br><span class="line">        imgs=os.listdir(root)</span><br><span class="line">        <span class="comment">#这句话可以使用glob快速加载 见66.</span></span><br><span class="line">        self.imgs=[os.path.join(root,k) <span class="keyword">for</span> k <span class="keyword">in</span> imgs]</span><br><span class="line">        self.transforms=transform</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        img_path = self.imgs[index]</span><br><span class="line">        pil_img = Image.open(img_path)</span><br><span class="line">        pil_img = pil_img.convert(<span class="string">"RGB"</span>)</span><br><span class="line">    <span class="keyword">if</span> self.transforms:</span><br><span class="line">            data = self.transforms(pil_img)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        pil_img = np.asarray(pil_img)</span><br><span class="line">            data = torch.from_numpy(pil_img)</span><br><span class="line">            label = xxxxx(这里省略，总之是得到这个图的标签）</span><br><span class="line">        <span class="keyword">return</span> data,label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.imgs)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据集实例并初始化</span></span><br><span class="line">dataSet=FlameSet(<span class="string">'./test'</span>,transform = transform)</span><br><span class="line"><span class="comment">#依然用Dataloader加载数据集</span></span><br><span class="line">data = torch.utils.data.DataLoader(myDataset,batch_size=BATCH_SIZE,shuffle=<span class="keyword">True</span>,num_workers=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>DataLoader将数据集对象和不同的取样器联合，如<code>SequentitalSampler</code>和<code>RandomSampler</code>，并使用单进程或多线程的迭代器，为我们提供批量数据。取样器是为算法提供数据的不同策略。<br><code>dataloader = torch.utils.data.DataLoader(trainSet,batch_size=BATCH_SIZE,shuffle=True，num_workers=0,collate_fn=fn)</code><br>Dataloader的储存数据形式是一个batch一个batch存，取也是一个batch一个batch取，每组数据的内容分别为<strong>一组</strong>batch的input和该组batch每个数据对应的label<strong>组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> phase:</span><br><span class="line">    inputs,label = data</span><br></pre></td></tr></table></figure>
<p> 注意: <code>datalodaer.__len__()</code>得到的是<strong>batch（分组）总数</strong>而不是数据总数<br><code>dataset.__len__</code>得到的是数据总数</p>
<p><strong>自定义DataLoader：</strong> </p>
<p><strong>collate_fn</strong>是非常重要的，如nlp中经常在里面做padding<br>collate_fn是<strong>自定义函数来设计数据收集的方式</strong>，意思是已经通过上面的Dataset类中的<strong>getitem</strong>函数采样了batch_size数据，以一个包的形式传递给collate_fn所指定的函数<br>collate_fn的输入是一个list，list的长度是一个batch_size，list中的每个u岸数都是<strong>getitem</strong>得到的结果</p>
<p><strong>以我一次项目中加载NLP数据集写的代码为例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成datasets</span></span><br><span class="line"><span class="comment"># 不进行转置，直接在网络中输入的时候调用RNN的函数进行转置</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">textDataset</span><span class="params">(dataset.Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data,label)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.label = label</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.data)</span><br><span class="line">    <span class="comment">#在取数据的时候调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,index)</span>:</span></span><br><span class="line">        data = torch.Tensor(self.data[index])</span><br><span class="line">        <span class="comment"># 这里是在getitem的时候才会转化为long</span></span><br><span class="line">        <span class="comment">#注意这里在转tensor的时候必须得是list格式，然后转成了之后再取出第0项即为单tensor元素</span></span><br><span class="line">        label = torch.LongTensor([self.label[index]])[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> data,label</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span><span class="params">(batch_data)</span>:</span></span><br><span class="line">    max_seq_size = <span class="number">30</span> <span class="comment">#最大句长 （看清楚这里处理的句子是，分割or。分割）</span></span><br><span class="line">    vec_size = <span class="number">200</span></span><br><span class="line">    <span class="comment">#经过dataloader调用__getitem__方法从dataset取得的数据是这样的形式(dataset[0],dataset[1],xxxx)一个batch长度，</span></span><br><span class="line">    <span class="comment">#也就是相当于((data0,label0),(data1,label1),xxx)，所以用zip分别提取出来形成(data,label)</span></span><br><span class="line">    <span class="comment">#zip(*zipped) 是逆zip    </span></span><br><span class="line">    datas,labels = zip(*batch_data)</span><br><span class="line">    </span><br><span class="line">    corpus_vec_resize = list()</span><br><span class="line">    <span class="comment">#遍历每一行（每一个seq）</span></span><br><span class="line">    <span class="keyword">for</span> corpus_vec <span class="keyword">in</span> datas:</span><br><span class="line">        <span class="comment">#这里对每个data中的句子做padding   #【也可以使用掩码的方式做padding，生成掩码矩阵 应该有更简单的方法或工具】</span></span><br><span class="line">        <span class="comment">#将处理后的全部转为Tensor，如果转成narray再弄会出错</span></span><br><span class="line">        <span class="comment">#若长度过小,则从句尾开始填充</span></span><br><span class="line">        <span class="keyword">if</span> len(corpus_vec) &lt; max_seq_size:</span><br><span class="line">            pad_num = max_seq_size-len(corpus_vec) </span><br><span class="line">            padding = list([[<span class="number">0</span>]*vec_size]*pad_num)</span><br><span class="line">            seq_padded = np.append(corpus_vec,padding,axis=<span class="number">0</span>)</span><br><span class="line">            seq_padded = torch.Tensor(seq_padded)</span><br><span class="line">            corpus_vec_resize.append(seq_padded)</span><br><span class="line">            <span class="comment">#若长度过长,则依次从句头和句末开始修剪</span></span><br><span class="line">        <span class="keyword">if</span> len(corpus_vec) &gt; max_seq_size:</span><br><span class="line">            cut_num = len(corpus_vec)-max_seq_size</span><br><span class="line">            <span class="comment">#句头剪cut_num//2 句尾剪cut-num-cut_num//2</span></span><br><span class="line">            seq_cut = corpus_vec[cut_num//<span class="number">2</span>:len(corpus_vec)-(cut_num-cut_num//<span class="number">2</span>)] </span><br><span class="line">            seq_cut = torch.Tensor(seq_cut)</span><br><span class="line">            corpus_vec_resize.append(seq_cut)</span><br><span class="line">        <span class="keyword">if</span> len(corpus_vec) == max_seq_size:</span><br><span class="line">            corpus_vec = torch.Tensor(corpus_vec)</span><br><span class="line">            corpus_vec_resize.append(corpus_vec)   </span><br><span class="line">    <span class="comment">#将datas转变为tensor   </span></span><br><span class="line">    datas = torch.stack(corpus_vec_resize) </span><br><span class="line"></span><br><span class="line">    <span class="comment">#合并处理labels</span></span><br><span class="line">    label_res = list()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> labels:</span><br><span class="line">        <span class="comment">#处理打错的标签(非0和1)</span></span><br><span class="line">        <span class="keyword">if</span> i.item()!=<span class="number">0</span> <span class="keyword">and</span> i.item()!=<span class="number">1</span>:</span><br><span class="line">            label_res.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label_res.append(i.item())</span><br><span class="line">    labels = torch.LongTensor(label_res)</span><br><span class="line"><span class="comment">#     print(labels)</span></span><br><span class="line"><span class="keyword">return</span> datas,labels</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#封装与加载</span></span><br><span class="line">corpus_dataset = textDataset(data=corpus_vec,label=labels)</span><br><span class="line"><span class="comment">#这里定义了加载的具体方法：preprocess</span></span><br><span class="line">textDataloader = dataloader.DataLoader(corpus_dataset,batch_size=batch_size,shuffle=<span class="keyword">False</span>,num_workers=<span class="number">1</span>,collate_fn=preprocess)</span><br></pre></td></tr></table></figure>
<p>dataloader参数的更多详细资料还可以参考下面资料：</p>
<p><a href="https://www.jianshu.com/p/8ea7fba72673" target="_blank" rel="noopener">https://www.jianshu.com/p/8ea7fba72673</a><br><a href="https://www.jianshu.com/p/bb90bff9f6e5" target="_blank" rel="noopener">https://www.jianshu.com/p/bb90bff9f6e5</a></p>
<p><a href="https://blog.csdn.net/weixin_30241919/article/details/95184794" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30241919/article/details/95184794</a></p>
<p><strong>dataloader的num_work子线程尽量数量开多点！不要让大量时间用去读数据.一般子线程设和核的个数相同</strong></p>
<h2 id="getitem"><a href="#getitem" class="headerlink" title="getitem()"></a><strong>getitem</strong>()</h2><p>如果类中定义了<strong>getitem</strong>()方法,那么它的实例对象（假设为P）就可以P[Key]这样取值。当实例对象做P[Key]运算的时候就会调用<strong>getitem</strong>()方法，返回的就是这个方法的return</p>
<p>dataset里有这个方法，当dataloader加载dataset的时候就会自动调用</p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title>重新打理BLOG</title>
    <url>/2019/03/27/%E9%87%8D%E6%96%B0%E6%89%93%E7%90%86BLOG/</url>
    <content><![CDATA[<p>前段时间因为繁忙，没时间打理个人网站</p>
<p>现在打算开始整理一下，逐步也把评论系统，目录之类的插件给搞定</p>
<p>把绝大部分日记都迁出去了，以后这里主要是..啥都有</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>HEXO遇到的坑</title>
    <url>/2019/03/27/HEXO%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<ol>
<li><p>source文件夹下面新建一个叫CNAME的文件填上网址</p>
<p>才能由自定义域名访问自己的github.io</p>
</li>
<li><p>安装了图片插件但是图片依然无法显示问题</p>
<p>①可能是图片路径出错导致</p>
<p>要在_config.yml中修改url为自己的域名！</p>
<p>②后缀名要注意大小写！ 路径和名称大小写要统一！</p>
</li>
<li><p>hexo改标题出现乱码</p>
<p><code>language: zh-Hans</code></p>
</li>
<li><p>配置文件要保存为UTF-8格式，不然会乱码</p>
</li>
<li><p>语法上的坑</p>
<ul>
<li>HEXO 表格与正文之间需要两个空行</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title>WE NEED R!G!B!</title>
    <url>/2019/02/27/R-G-B/</url>
    <content><![CDATA[<p>北极狼和北极熊水冷性能虽然很强，但是他们有个缺点就是没有RGB————</p>
<p>这怎么行呢。</p>
<p>RGB化改造迫在眉睫</p>
<p>于是我买了HALOS圣环，自己定做了显卡侧灯板</p>
 <a id="more"></a>
<p>改装之前——————</p>
<p><img src="//aisakaki.com/2019/02/27/R-G-B/IMG_2469.jpg" alt="改装之前"></p>
<p>改装之后——————</p>
<p><img src="//aisakaki.com/2019/02/27/R-G-B/IMG_3998.jpg" alt="改装后"></p>
<p>动图：</p>
<p><img src="//aisakaki.com/2019/02/27/R-G-B/final.gif" alt="改装后动态图"></p>
<p>愉快打电动~</p>
<p><img src="//aisakaki.com/2019/02/27/R-G-B/IMG_4064.JPG" alt="电动"></p>
<p>这中间遇到个小插曲</p>
<p>那块显卡侧灯右边漏光的一条是因为…</p>
<p>我定做的时候 尺寸量错了，多度了半厘米。</p>
<p>于是只能用刀片来削….</p>
<p>然后就成这样了</p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>神说，要有光</tag>
      </tags>
  </entry>
  <entry>
    <title>imageTest</title>
    <url>/2019/01/16/imageTest/</url>
    <content><![CDATA[<p>图片测试</p>
<p> <a id="more"></a> <img src="//aisakaki.com/2019/01/16/imageTest/5474960.png" alt="5474960"></p>
]]></content>
  </entry>
  <entry>
    <title>2080Ti上一体式水冷</title>
    <url>/2019/01/16/2080Ti%E4%B8%8A%E4%B8%80%E4%BD%93%E5%BC%8F%E6%B0%B4%E5%86%B7/</url>
    <content><![CDATA[<p>前段时间买了非公的2080Ti，感觉自带的散热不太行，玩游戏温度飙升到84度直接撞温度墙。于是我搞了个 ocool的北极狼一体式水冷（花了我1300大洋，这水冷都够我买一张1060了orz）</p>
<p>自己动手，丰衣足食~</p>
 <a id="more"></a>
<p>这是原装风冷的样子<img src="//aisakaki.com/2019/01/16/2080Ti上一体式水冷/1969.jpg" alt="正面"></p>
<p>首先拆去原装散热器，脱去外套</p>
<p><img src="//aisakaki.com/2019/01/16/2080Ti上一体式水冷/1973.jpg" alt="背部"></p>
<p>可以看到一件暴露的核心和硅脂</p>
<p>然后卸下底板</p>
<p><img src="//aisakaki.com/2019/01/16/2080Ti上一体式水冷/1984.jpg" alt="背部"></p>
<p>这就是PCB背部了</p>
<p>然后就可以把PCB上的均热板给去掉，完整的PCB板子 就暴露在眼前</p>
<p>可以看到11个gddr6显存，11G，下面那个地方缺了一块强迫症就很难受</p>
<p>16相供电，嗯果然是公版PCB</p>
<p>拆解结束~</p>
<p><img src="//aisakaki.com/2019/01/16/2080Ti上一体式水冷/1989.jpg" alt="背部"></p>
<p>擦掉硅脂，裁剪了一堆导热胶，将显存和供电给覆盖住。可以看到核心上的标签写着TU102核心</p>
<p><img src="//aisakaki.com/2019/01/16/2080Ti上一体式水冷/1992.jpg" alt="背部"></p>
<p>涂上祖传的德国暴力熊硅脂</p>
<p><img src="//aisakaki.com/2019/01/16/2080Ti上一体式水冷/1993.jpg" alt="背部"></p>
<p>然后安装好水冷的冷头和底板，这里要注意安装对齐！第一次就没安装好导致水冷头没和核心密切接触使得温度超高。</p>
<p><img src="//aisakaki.com/2019/01/16/2080Ti上一体式水冷/1995.jpg" alt="背部"></p>
<p>然后就结束啦！2080Ti水冷显卡诞生！</p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>显卡</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习实践结构性经验总结</title>
    <url>/2019/01/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E7%BB%93%E6%9E%84%E6%80%A7%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><ul>
<li>定义网络结构</li>
<li>定义数据变换</li>
<li>定义超参数，损失函数，优化方法，自适应学习率等…</li>
<li><p>读取训练集与测试集（自定义数据集，多种读入方式等..）<br><strong>开始训练</strong>：</p>
<ul>
<li><p><strong>训练一个Epoch</strong><br>自适应学习率更新<br><strong>循环：训练一个batch——从dataloader读取一个mini batch</strong></p>
<ul>
<li>转换为cuda变量</li>
<li>梯度清0<br><strong>FORWARD</strong></li>
<li>将数据输入模型得到结果</li>
<li>根据结果得到预测标签</li>
<li>计算train loss<br><strong>BACKWARD</strong></li>
<li>反向计算梯度</li>
<li>优化器更新<br><strong>统计本batch</strong></li>
</ul>
</li>
<li><strong>统计本epoch</strong></li>
</ul>
</li>
</ul>
<p>【注】<br>①如果是<strong>测试</strong>，则取消[自适应学习率更新]和[BACKWARD]的步骤即可<br><strong>训练和测试可以结合起来</strong> train=datalodaer(trainset…),test=dataloader(testset…)<br>则在开始训练一个epoch的时候，加一个循环 <code>for phase in [train,test]</code>即可，后面的在测试不需要的步骤作判断<code>if phase is train: do</code>就行<br>②可以设置一个全局的最优准确率，然后记录下来最佳准确率，并储存当时的<strong>最优模型</strong>权重<br>③注意<strong>设置模型模式</strong>，<code>model.train(True)</code>设置为训练模式<code>model.eval(True)</code>设置为测试模式</p>
<h2 id="定义网络结构"><a href="#定义网络结构" class="headerlink" title="定义网络结构"></a>定义网络结构</h2><p>在定义网络结构的时候,如下形式<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义的网络结构类必须继承自nn.Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># 注意传入参数self到结构函数</span></span><br><span class="line">    <span class="comment"># init中的参数为初始化网络的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__</span><br><span class="line">        <span class="comment"># 定义网络</span></span><br><span class="line">        <span class="comment"># 单个定义</span></span><br><span class="line">        self.s1 = nn.Conv2d(......)</span><br><span class="line">        <span class="comment"># 或集合定义</span></span><br><span class="line">        self.s1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(......),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 全连接层(对于卷积神经网络用于分类）</span></span><br><span class="line">        self.fc = nn.Linear()</span><br><span class="line">    <span class="comment"># 注意传入参数self和x（输入矩阵）！</span></span><br><span class="line">    <span class="comment"># forward中的参数为训练的时候要传入的参数 比如求output = model(x)时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="comment"># 经过特征提取层后，要扁平化才能进入fc层！</span></span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> F.softmax(x)</span><br></pre></td></tr></table></figure></p>
<p>注意，一个误区：定义网络是定义网络的结构！输入一般输入一个batch，对该batch的处理为网络的内容</p>
<p>nn包含了所有的层结构定义组件, F包含了所有的函数, nn中的每个组件都需要添加到nn.Module容器中才能使用. def参数中的self即指向nn.Module(指向本类,而本类继承自nn.Module), 通过定义self.diyiceng = nn.Conv2d(xxx) 即将组件添加到了nn.Module容器中 </p>
<h2 id="nn-Sequential-组合一系列组件定义"><a href="#nn-Sequential-组合一系列组件定义" class="headerlink" title="nn.Sequential 组合一系列组件定义"></a><strong>nn.Sequential</strong> 组合一系列组件定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#eg</span></span><br><span class="line">self.conv2 = nn.Sequential( </span><br><span class="line">	nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>), </span><br><span class="line">	nn.ReLU(),  </span><br><span class="line">	nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">)  </span><br><span class="line"><span class="comment">#这里就将三个组件组合成一个组件了</span></span><br><span class="line"><span class="comment">#注意里面直接写组件组成即可 不是变量定义</span></span><br></pre></td></tr></table></figure>
<h2 id="建立深度学习模型一般实践"><a href="#建立深度学习模型一般实践" class="headerlink" title="建立深度学习模型一般实践"></a>建立深度学习模型一般实践</h2><p><strong>数据预处理与特征工程</strong></p>
<ul>
<li>向量化</li>
<li>值归一化</li>
<li>处理缺省值</li>
<li>特征工程<br><strong>过拟合</strong></li>
<li>获取更多数据、数据增强等</li>
<li>缩小网络规模</li>
<li>应用权重正则化</li>
<li>应用dropout<br><strong>欠拟合</strong></li>
<li>获取更多数据</li>
<li>增加权重</li>
</ul>
<p><strong>一般流程</strong></p>
<ul>
<li>问题定义与数据集创建</li>
<li>选择模型评估标准</li>
<li>评估协议（测试集 验证集）</li>
<li>准备数据</li>
<li>模型基线（创建一个非常简单的模型来打破基线分数 如二分类为0.5)</li>
<li>训练大达到过拟合</li>
<li>应用正则化</li>
<li>学习率选择策略</li>
</ul>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>向目标函数加入正则的具体实现</title>
    <url>/2018/12/01/%E5%90%91%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E5%8A%A0%E5%85%A5%E6%AD%A3%E5%88%99%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<ol>
<li><p>在数据经过模型之后</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1, l2 = torch.tensor(<span class="number">0</span>), torch.tensor(<span class="number">0</span>)</span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">output = model(input)</span><br><span class="line"><span class="keyword">for</span> params <span class="keyword">in</span> model.parameters():</span><br><span class="line">    l1 += torch.norm(param,<span class="number">1</span>)  <span class="comment">#torch.norm(param,1)为求param的l1范数</span></span><br><span class="line">    l2 += torch.norm(param,<span class="number">2</span>)  <span class="comment">#torch.norm(param,2)为求param的l2范数</span></span><br><span class="line">loss_origin = loss(output,label)</span><br><span class="line">loss = loss_origin + l1 + l2</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure>
<p>ATT：<strong>不能</strong>使用在模型中输出！</p>
<p>使用以下这种方法是输出的中间层的输出，而不是参数！</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#错误示范</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.linear1 = nn.Linear(<span class="number">64</span>,<span class="number">32</span>)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">32</span>,<span class="number">16</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,input)</span>:</span></span><br><span class="line">        linear1_out = self.linear1(input)</span><br><span class="line">        linear2_out = self.linear2(linear1_out)</span><br><span class="line">        <span class="keyword">return</span> linear1_out,linear2_out</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用pytorch自带的权重衰减</p>
<p><code>torch.optim</code>自带的参数<code>weight_decay</code>可以设置权值衰减率，即可以实现L2正则化</p>
</li>
</ol>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch中常用的维度变换与torch.max()</title>
    <url>/2018/11/12/Pytorch%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%B4%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8Etorch-max/</url>
    <content><![CDATA[<h2 id="Tensor-view-扁平化"><a href="#Tensor-view-扁平化" class="headerlink" title="Tensor.view() 扁平化"></a>Tensor.view() 扁平化</h2><p>简单说就是一个把tensor 进行reshape的操作。<br>常常配合 <code>a.size(0)</code>来取得某一位的维度数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=torch.randn(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line">b = a.view(<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">print(b.size())</span><br><span class="line">&gt;&gt;torch.Size([<span class="number">1</span>, <span class="number">420</span>])</span><br></pre></td></tr></table></figure>
<p><strong>其中参数-1表示剩下的值的个数一起构成一个维度</strong>。如上例中，第一个参数1将第一个维度的大小设定成1，后一个-1就是说第二个维度的大小=元素总数目/第一个维度的大小，此例中为<code>3*4*5*7/1=420</code>. （由于第一个维度被展为1了，那后面所有元素全部摊开展平了）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第1,2个维度不变（保持原来的维度），第三个位置写-1表示剩下的维度全部扁平化为一个维度</span></span><br><span class="line">d = a.view(a.size(<span class="number">0</span>),a.size(<span class="number">1</span>),<span class="number">-1</span>)</span><br><span class="line">print(d.size())</span><br><span class="line">&gt;&gt;torch.Size([<span class="number">3</span>, <span class="number">4</span>, <span class="number">35</span>])</span><br><span class="line"></span><br><span class="line"> e=a.view(<span class="number">4</span>,<span class="number">-1</span>,<span class="number">5</span>)</span><br><span class="line"> print(e.size())</span><br><span class="line"> &gt;&gt;torch.Size([<span class="number">4</span>, <span class="number">21</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p> 在<strong>扁平化批处理的图片</strong>的时候（CNN中会出现）<br> 为了扁平化每一张图片的数据，又不想把不同图片的数据混在一起扁平，那么就应该</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意：遇到错误</strong><code>RuntimeError: invalid argument 2: view size is not compatible with input tensor&#39;s size and stride (at least one dimension spans across two contiguous subspaces). Call .contiguous() before .view().</code><br>需要让Tensor连续化，即加一步<code>x = x.contiguous()</code><br>原因解释:<a href="https://blog.csdn.net/appleml/article/details/80143212" target="_blank" rel="noopener">https://blog.csdn.net/appleml/article/details/80143212</a>使用torch.view()的条件是Tensor是连续的,在对Tensor进行了transpose等操作之后就会变得不连续，就需要这个函数来连续化</p>
<h2 id="unsqueeze降维-和squeeze升维"><a href="#unsqueeze降维-和squeeze升维" class="headerlink" title="unsqueeze降维 和squeeze升维"></a>unsqueeze降维 和squeeze升维</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对于torch:使用unsqueeze降维 和squeeze升维</span><br><span class="line"><span class="comment">#升维</span></span><br><span class="line">unsqueeze(torch1,<span class="number">0</span>)  <span class="comment">#在第0个位置增加一个值为1的维度</span></span><br><span class="line"><span class="comment">#(2, 2)-&gt;(1,2,2)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#降维</span></span><br><span class="line">squeeze(torch1)  <span class="comment">#squeeze给torch删去值为1的维度</span></span><br><span class="line"><span class="comment">#(2, 2, 1)-&gt;(2, 2)</span></span><br><span class="line">    </span><br><span class="line">比如灰度图像只有<span class="number">2</span>维,这个时候就需要升维</span><br><span class="line">    </span><br><span class="line">对于numpy array,函数不一样:expand_dims 升维 squeeze 降维</span><br><span class="line"><span class="comment">#升维</span></span><br><span class="line">expand_dims(narray1,<span class="number">0</span>) <span class="comment">#在第0个位置增加一个值为1的维度</span></span><br><span class="line">与torch用法一致</span><br></pre></td></tr></table></figure>
<h2 id="torch-max函数"><a href="#torch-max函数" class="headerlink" title="torch.max函数"></a>torch.max函数</h2><p>①torch.max()简单来说是返回一个tensor中的最大值。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">si=torch.randn(<span class="number">4</span>,<span class="number">5</span>)  </span><br><span class="line">print(si)  </span><br><span class="line">&gt;&gt;tensor([[ <span class="number">1.1659</span>, <span class="number">-1.5195</span>, <span class="number">0.0455</span>, <span class="number">1.7610</span>, <span class="number">-0.2064</span>],  </span><br><span class="line">[<span class="number">-0.3443</span>, <span class="number">2.0483</span>, <span class="number">0.6303</span>, <span class="number">0.9475</span>, <span class="number">0.4364</span>],  </span><br><span class="line">[<span class="number">-1.5268</span>, <span class="number">-1.0833</span>, <span class="number">1.6847</span>, <span class="number">0.0145</span>, <span class="number">-0.2088</span>],  </span><br><span class="line">[<span class="number">-0.8681</span>, <span class="number">0.1516</span>, <span class="number">-0.7764</span>, <span class="number">0.8244</span>, <span class="number">-1.2194</span>]])</span><br><span class="line"></span><br><span class="line">print(torch.max(si))  </span><br><span class="line">&gt;&gt;tensor(<span class="number">2.0483</span>) <span class="comment">#输出了最大值</span></span><br></pre></td></tr></table></figure>
<p>②这个函数的参数中还有一个dim参数，使用方法为re = torch.max(Tensor,dim),<strong>返回的res为一个</strong>二维向量<strong>，</strong>其中res[0]为最大值的Tensor，res[1]为Tensor中最大值对应的index**。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(torch.max(si,<span class="number">0</span>))</span><br><span class="line">(tensor([<span class="number">1.1659</span>, <span class="number">2.0483</span>, <span class="number">1.6847</span>, <span class="number">1.7610</span>, <span class="number">0.4364</span>]), tensor([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(torch.max(si,<span class="number">0</span>)[<span class="number">0</span>])  </span><br><span class="line">tensor([<span class="number">1.1659</span>, <span class="number">2.0483</span>, <span class="number">1.6847</span>, <span class="number">1.7610</span>, <span class="number">0.4364</span>])</span><br></pre></td></tr></table></figure>
<p>注意，Tensor的维度从0开始算起。在torch.max()中指定了dim之后，比如对于一个3x4x5的    Tensor，指定dim为0后，得到的结果是维度为0的“每一行”对应位置求最大的那个值，此时输出的Tensor的维度是4x5. （<strong>在这个二维tensor里，dim=0就是求每行最大值</strong>）</p>
<p>对于简单的二维Tensor，如上面例子的这个4x5的Tensor。指定dim为0，则给出的结果是4行做比较之后的最大值；如果指定dim为1，则给出的结果是5列做比较之后的最大值，且此处做比较时是按照位置分别做比较，得到一个新的Tensor。（<strong>在这个二维tensor里，dim=1就是求每列最大值</strong>）</p>
<p>eg<br><code>_, preds = torch.max(outputs.data, 1)</code></p>
<p>输出的outputs也是torch.autograd.Variable格式，得到输出后（网络的全连接层的输出）还希望能到到模型预测该样本属于哪个类别的信息，这里采用torch.max。torch.max()的第一个输入是tensor格式，所以用outputs.data而不是outputs作为输入；第二个参数1是代表dim的意思，也就是取每一行的最大值，<strong>其实就是我们常见的取概率最大的那个index</strong>；第三个参数loss也是</p>
<p>这个函数可以直接处理组</p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>对BP算法的理解</title>
    <url>/2018/11/08/%E5%AF%B9%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>损失函数$J(W_{11},W_{12},\cdots,W_{ij},\cdots,W{mn})$</p>
<p>要计算梯度$\nabla J=\frac{\partial J}{\partial W_{11}}e_{11}+\cdots+\frac{\partial J}{\partial W_{mn}}e_{mn} $，$e_{ij}$为单位正交向量（$J$对每个参数求偏导）</p>
<p>那么使用链式法则，我们可以画出计算图</p>
<p>①先标记出所有中间结点</p>
<p>②对每一个结点，写出<strong>上一层直连结点</strong>（最顶层就是$J$）对该节点求得的偏导式（偏的是本结点中间变量），其他变量都视为常数</p>
<p>③根据计算图，使用链式法则（两个结点之间，偏导式同路径相乘，所有路径相加）</p>
<p>主要理解清，某一个中间结点对另一个邻层中间结点求导，<strong>是对中间变量求导</strong>，只看局部，<strong>其它的变量都视为常数</strong>，都先只计算<strong>邻接层求导</strong>，再分别计算完每个偏导式之后，再运用链式法则根据全路径计算<strong>跨层求导</strong></p>
<p>这样一来会有很多的重复计算（重复路径）。</p>
<p>为了解决这个问题，BP的做法是<strong>自顶向下，逐层反向求导，累计计算</strong></p>
<p>也就是说从<strong>最高层$J$开始</strong>，<strong>按层计算</strong>出该层的偏导式值，然后再把这个值（<strong>是个含变量的表达式，但是对于这个中间层来说是个常数</strong>）发给这个结点下属路径下的每个结点（让他们乘上这个上层来的偏导式），然后再计算下一层的偏导式，如此<strong>迭代到输入层</strong></p>
<p>注意都是先推导式子，最后再代入值计算，比如输入以及真实label都是最后推导完式子后计算的时候的一个常数值</p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>BP</tag>
      </tags>
  </entry>
  <entry>
    <title>notes_1108</title>
    <url>/2018/11/08/notes-1108/</url>
    <content><![CDATA[<ol>
<li><p>NN的输出是一个向量，包含对各个种类的输出值，最后一个层有多少个神经元，输出向量就有多少维，所以在求的时候是矩阵求梯度下降，Loss Function作用于一个矩阵</p>
</li>
<li><p>NN为什么用非线性激活函数</p>
<p>线性函数公式写出来之后 会发现 无论多少层，他都只能生成线性分类器（成为了感知机）<br>无法去拟合绝大多数的真实情况<br>而非线性的组合 就可以去逼近任何函数</p>
</li>
<li><p>关于梯度下降的算法<br>一个训练样本的损失函数就是一个向量，有多少特征就有多少维<br>ML算法中的代价函数通常可以分解成每个样本的代价函数的总和<br>具体求和之后如何求导见1</p>
<p>于是不使用batch的整体梯度下降需要计算($m$为训练集样本个数)。所有样本计算出最终结果来计算梯度。这样对显存的要求就极高（在大样本集上是不可能）</p>
<script type="math/tex; mode=display">
     \nabla_{\theta}J(\theta)=\frac{1}{m}\sum_{i=1}^m\nabla_\theta L(x^{(i)},y^{(i)},\theta)</script><p>如果使用minibatch，则变成（一个batch有$m’$个训练样本） 一个batch计算一个$g$来更新梯度</p>
<script type="math/tex; mode=display">
 g=\frac{1}{m'}\sum_{i=1}^{m'}\nabla_\theta L(x^{(i)},y^{(i)},\theta)</script><p>然后使用如下的梯度下降算法估计梯度</p>
<script type="math/tex; mode=display">
    \theta \leftarrow \theta - \epsilon g</script><p>于是在一轮训练集中，要更新很多次梯度，目标去逼近整体更新梯度的方向<br>在一轮中的几个批次，可能是局部梯度减小，整体损失变大，但是在一轮下来之后，会变成朝着整体减小的方向震荡前进</p>
</li>
<li><p>CNN一个牛逼的地方就在于通过感受野和权值共享减少了神经网络需要训练的参数的个数，所谓权值共享就是同一个Feature Map中神经元权值共享，该Feature Map中的所有神经元使用同一个权值。因此参数个数与神经元的个数无关，只与卷积核的大小及Feature Map的个数相关。但是共有多少个连接个数就与神经元的个数相关了，神经元的个数也就是特征图的大小。</p>
</li>
<li><p>为什么用交叉熵作损失函数？每层怎么做计算<br><a href="https://blog.csdn.net/huwenxing0801/article/details/82791879" target="_blank" rel="noopener">https://blog.csdn.net/huwenxing0801/article/details/82791879</a><br>对于分类问题，用交叉熵损失函数更好，因为交叉熵函数公式可知道，<strong>交叉熵只关心对正确类别的预测概率</strong>，因为只要其值<strong>足够大</strong>，就可以保证分类结果正确。<br>对于回归问题，用平方差损失函数更好，它希望<strong>预测概率尽量完全等于标签概率</strong>。（比交叉熵损失函数严格很多）</p>
</li>
<li><p>前馈神经网络，如BP，RFN</p>
<p>循环神经网络，RNN</p>
</li>
</ol>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
  </entry>
  <entry>
    <title>使用markdown编辑数学公式</title>
    <url>/2018/11/07/%E4%BD%BF%E7%94%A8markdown%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p>Typora是我认为最好用的markdown编辑器，书写直观，数学公式编辑器非常方便，总结一下在上面编辑数学公式的语法。</p>
<p>注意，首先要在文件—偏好设置—Markdown关联语法 里勾选内联公式</p>
<h3 id="创建公式编辑栏的方式"><a href="#创建公式编辑栏的方式" class="headerlink" title="创建公式编辑栏的方式"></a>创建公式编辑栏的方式</h3><ul>
<li>内联公式：两个$之间​</li>
<li>公式块：两个$$之间</li>
<li>ctrl + shift +m</li>
</ul>
<h3 id="常用公式的代码"><a href="#常用公式的代码" class="headerlink" title="常用公式的代码"></a>常用公式的代码</h3><p>   注意，一个块要用{}包裹起来，^_上下标叠着写就行</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">输入</th>
<th style="text-align:center">公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x^2</td>
<td style="text-align:center">$x^2$</td>
</tr>
<tr>
<td style="text-align:center">x_1</td>
<td style="text-align:center">$x_1$</td>
</tr>
<tr>
<td style="text-align:center">\frac{x}{y}</td>
<td style="text-align:center">$\frac{x}{y}$</td>
</tr>
<tr>
<td style="text-align:center">\sqrt[x]{y}</td>
<td style="text-align:center">$\sqrt[x]{y}$</td>
</tr>
<tr>
<td style="text-align:center">\vec{x}</td>
<td style="text-align:center">$\vec{x}$</td>
</tr>
<tr>
<td style="text-align:center">\int_{a}^{b}{x}dx</td>
<td style="text-align:center">$\int_{a}^{b}{x}dx$</td>
</tr>
<tr>
<td style="text-align:center">\cdots</td>
<td style="text-align:center">$\cdots$</td>
</tr>
<tr>
<td style="text-align:center">\sum_{n=1}^{100}{a_n}</td>
<td style="text-align:center">$\sum_{n=1}^{100}{a_n}$</td>
</tr>
<tr>
<td style="text-align:center">\lim_{n\to +\infty}</td>
<td style="text-align:center">$\lim_{n\to +\infty}$</td>
</tr>
<tr>
<td style="text-align:center">\prod_{n=1}^{99}{x_n}</td>
<td style="text-align:center">$\prod_{n=1}^{99}{x_n}$</td>
</tr>
<tr>
<td style="text-align:center">a \quad b</td>
<td style="text-align:center">$a \quad b$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3>   <a id="more"></a>
<p>   希腊字母、三角函数、对数函数直接写转义字符+对应的内容即可，比如</p>
<p>   对于如希腊字母，第一个字母大写就对应其大写字母，小写即对应其小写字母</p>
<p>   \sinx = $\sin x$    \log_2 = $\log_2$</p>
<p>   \lambda=$\lambda$     \theta=$\theta$   \Omega=$\Omega$</p>
<p>   \Delta=$\Delta$</p>
<p>   <strong>梯度\nabla</strong>=$\nabla$</p>
<h3 id="其它特殊符号"><a href="#其它特殊符号" class="headerlink" title="其它特殊符号"></a>其它特殊符号</h3><p>   前三行关系运算符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">输入</th>
<th style="text-align:center">公式</th>
<th style="text-align:center">输入</th>
<th style="text-align:center">公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\pm</td>
<td style="text-align:center">$\pm$</td>
<td style="text-align:center">\cdot</td>
<td style="text-align:center">$\cdot$</td>
</tr>
<tr>
<td style="text-align:center">\div</td>
<td style="text-align:center">$\div$</td>
<td style="text-align:center">\leq</td>
<td style="text-align:center">$\leq$</td>
</tr>
<tr>
<td style="text-align:center">\geq</td>
<td style="text-align:center">$\geq$</td>
<td style="text-align:center">\partial</td>
<td style="text-align:center">$\partial$</td>
</tr>
<tr>
<td style="text-align:center">\in</td>
<td style="text-align:center">$\in$</td>
<td style="text-align:center">\notin</td>
<td style="text-align:center">$\notin$</td>
</tr>
<tr>
<td style="text-align:center">\cup</td>
<td style="text-align:center">$\cup$</td>
<td style="text-align:center">\cap</td>
<td style="text-align:center">$\cap$</td>
</tr>
<tr>
<td style="text-align:center">\subset</td>
<td style="text-align:center">$\subset$</td>
<td style="text-align:center">\subseteq</td>
<td style="text-align:center">$\subseteq$</td>
</tr>
<tr>
<td style="text-align:center">\supset</td>
<td style="text-align:center">$\supset$</td>
<td style="text-align:center">\supseteq</td>
<td style="text-align:center">$\supseteq$</td>
</tr>
<tr>
<td style="text-align:center">\forall</td>
<td style="text-align:center">$\forall$</td>
<td style="text-align:center">\infty</td>
<td style="text-align:center">$\infty$</td>
</tr>
<tr>
<td style="text-align:center">\varnothing</td>
<td style="text-align:center">$\varnothing$</td>
<td style="text-align:center">\exists</td>
<td style="text-align:center">$\exists$</td>
</tr>
<tr>
<td style="text-align:center">\because</td>
<td style="text-align:center">$\because$</td>
<td style="text-align:center">\therefore</td>
<td style="text-align:center">$\therefore$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h3>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c(u)=</span><br><span class="line"></span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line"></span><br><span class="line"> formula1,condition1\\ </span><br><span class="line"></span><br><span class="line">formula2,condition2 </span><br><span class="line"></span><br><span class="line">\end&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<p>   $c(u)=\begin{cases} formula1,condition1\\\ formula2,condition2 \end{cases}$</p>
<p>   <code>以\begin{cases}开始，以\end{cases}结束，中间行间隔用\\，每行的条件和公式之间用逗号相隔</code></p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line">&#123;a_&#123;11&#125;&#125;&amp;&#123;a_&#123;12&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;1n&#125;&#125;\\</span><br><span class="line">&#123;a_&#123;21&#125;&#125;&amp;&#123;a_&#123;22&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;2n&#125;&#125;\\</span><br><span class="line">&#123;\vdots&#125;&amp;&#123;\vdots&#125;&amp;&#123;\ddots&#125;&amp;&#123;\vdots&#125;\\</span><br><span class="line">&#123;a_&#123;m1&#125;&#125;&amp;&#123;a_&#123;m2&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;mn&#125;&#125;\\</span><br><span class="line">\end&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p>   $\begin{bmatrix}<br>   {a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\<br>   {a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\<br>   {\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\<br>   {a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\<br>   \end{bmatrix}$</p>
<p><em>关于HEXO使用mathjax渲染公式的问题见此篇文章<a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">https://www.jianshu.com/p/7ab21c7f0674</a></em></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>更换HEXO框架</title>
    <url>/2018/11/06/%E6%9B%B4%E6%8D%A2HEXO%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>这两天将更换了个人网站的框架</p>
<p>更改框架是个蛮麻烦的过程</p>
<p>其中以前的文章很多格式都乱掉了</p>
<p>而且图片全部没有了…….</p>
<p>只能手动修正了</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch常用模块以及nn.Module</title>
    <url>/2018/10/18/Pytorch%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%BB%A5%E5%8F%8Ann-Module/</url>
    <content><![CDATA[<h2 id="pytroch常用包"><a href="#pytroch常用包" class="headerlink" title="pytroch常用包"></a>pytroch常用包</h2><p>PyTorch框架中有一个很常用的包：<code>torchvision</code><br>torchvision主要由3个子包构成：<code>torchvision.datasets</code>、<code>torchvision.models</code>、<code>torchvision.transforms</code><br><code>torchvision</code>和<code>torchtext</code>基于<code>torch.utils.data.Dataset</code>和<code>torch.utils.data.DataLoder</code>类构建<br><code>nn</code>来源于<code>torch.nn</code><br><code>optim</code>来源于<code>torch.optim</code> 超参数算法都在里面<br><code>lr_scheduler</code>来源于<code>torch.optim.lr_scheduler</code> 自适应学习率算法在里面<br><code>ImageFolder</code>在<code>torchvision.datasets</code>中<br><code>torchvision.models</code>中提供一些现有的流行算法</p>
<p><code>torch.nn.functional</code> 各中层函数的实现，与层类型对应，如：卷积函数、池化函数、归一化函数等等</p>
<h2 id="torch-nn与nn-Module"><a href="#torch-nn与nn-Module" class="headerlink" title="torch.nn与nn.Module"></a>torch.nn与nn.Module</h2><p>torch.nn是专门为神经网络设计的模块化接口。nn构建于autograd之上，可以用来定义和运行神经网络。</p>
<p>torch.nn的核心数据结构是<code>Module</code>，它是一个抽象概念，既可以表示神经网络中的某个层（layer），也可以表示一个包含很多层的神经网络。无需纠结variable和tensor了，0.4版本已经将两个类彻底合并了。</p>
<p>在实际使用中，最常见的做法是<strong>继承</strong><code>nn.Module</code>，撰写自己的网络/层。</p>
<ul>
<li><p>自定义层<code>Linear</code>必须继承<code>nn.Module</code>，并且在其构造函数中需调用<code>nn.Module</code>的构造函数，即<code>super(Linear, self).__init__()</code>  或<code>nn.Module.__init__(self)</code>，推荐使用第一种用法。</p>
</li>
<li><p>在<strong>构造函数<code>__init__</code>中必须自己定义可学习的参数，并封装成<code>Parameter</code></strong>，比如 _FasterRcnn类init中定义了 self.RCNN_loss_cls = 0 和 self.RCNN_loss_bbox = 0 还有在本例中我们把<code>w</code>和<code>b</code>封装成<code>parameter</code>。<strong><code>parameter</code>是一种特殊的<code>Variable</code>，但其默认需要求导</strong>（requires_grad = True）。</p>
</li>
<li><p><code>forward</code>函数实现前向传播过程，其输入可以是一个或多个variable，对x的任何操作也必须是variable支持的操作。</p>
</li>
<li><p><strong>无需写反向传播函数</strong>，<strong>因其前向传播都是对variable进行操作，nn.Module能够利用autograd自动实现反向传播，这点比Function简单许多。 faster rcnn等中反向传播直接写pass的原因。</strong></p>
</li>
<li><p>使用时，直观上可将layer看成数学概念中的函数，调用layer(input)即可得到input对应的结果。它等价于<code>layers.__call__(input)</code>，在<code>__call__</code>函数中，主要调用的是  <code>layer.forward(x)</code>，另外还对钩子做了一些处理。所以在实际使用中<strong>应尽量使用<code>layer(x)</code>而不是使用<code>layer.forward(x)</code></strong>。</p>
</li>
<li><p><code>Module</code>中的<strong>可学习参数</strong>可以<strong>通过<code>named_parameters()</code>或者<code>parameters()</code>返回迭代器</strong>，前者会给每个parameter都附上名字，使其更具有辨识度。</p>
<p>Module能够自动检测到自己的<code>Parameter</code>，并将其作为学习参数。</p>
</li>
</ul>
<h2 id="nn-ReLU和F-ReLU有什么区别"><a href="#nn-ReLU和F-ReLU有什么区别" class="headerlink" title="nn.ReLU和F.ReLU有什么区别?"></a>nn.ReLU和F.ReLU有什么区别?</h2><p>将ReLU层添加到网络有两种不同的实现，即nn.ReLU和F.ReLU两种实现方法。<br>其中nn.ReLU作为一个层结构，必须添加到nn.Module容器中才能使用，而F.ReLU则作为一个函数调用，看上去作为一个函数调用更方便更简洁。具体使用哪种方式，取决于编程风格。在PyTorch中,nn.X都有对应的函数版本F.X，但是并不是所有的F.X均可以用于forward或其它代码段中，因为当网络模型训练完毕时，在存储model时，在forward中的F.X函数中的参数是无法保存的。也就是说，在forward中，使用的F.X函数一般均没有状态参数，比如F.ReLU，F.avg_pool2d等，均没有参数，它们可以用在任何代码片段中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nn.Softmax() = nn.Linear() + forward最后输出的时候调用F.softmax()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN的卷积过程理解</title>
    <url>/2018/10/15/CNN%E7%9A%84%E5%8D%B7%E7%A7%AF%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="CNN的卷积层"><a href="#CNN的卷积层" class="headerlink" title="CNN的卷积层"></a>CNN的卷积层</h2><p>这就涉及到CNNs要做的工作了。每一个卷积核中的数值，都是<strong>算法自己学习来的</strong>，不需要我们费心去设置。<br>【CNN的特征提取部分和FC部分一样，也是需要训练的。训练学得Fliter的具体值，然后学得图像特征<br>相当于Fliter是W，图片是X，最终提取得到的特征是Y 输入进FC里（全连接层）<br>训练过程中，W不断学习得到最佳Fliter<br>（Filter其实就是权值！每个像素的权值！二维的<br>所以在最开始的FIlter时候其实就是权值初始化的问题,后面算法自己会学到）<br>】<br>我们需要做的是设置超参数（学习超参数）</p>
<p><strong>所谓的卷积层conv就是一堆卷积核，卷积层的参数就是卷积核的参数</strong></p>
<p>CONV-&gt;ACTIVATE-&gt;POOL-&gt; XXXXXXXX -&gt;FC</p>
<h2 id="多通道卷积——理解卷积层的工作原理"><a href="#多通道卷积——理解卷积层的工作原理" class="headerlink" title="多通道卷积——理解卷积层的工作原理"></a>多通道卷积——理解卷积层的工作原理</h2><p>非常重要<br><strong>输出的层数必为卷积核的层数，以卷积核的视角来做卷积，一个卷积核生成一个卷积层！</strong></p>
<p><img src="//aisakaki.com/2018/10/15/CNN的卷积过程理解/神经网络实践_多通道卷积.png" alt="神经网络实践_多通道卷积">**</p>
<p><strong>同一个卷积核对所有通道做卷积然后进行求和得到该卷积核对应的卷积层</strong></p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>中秋</title>
    <url>/2018/09/25/%E4%B8%AD%E7%A7%8B/</url>
    <content><![CDATA[<p>中秋到了，月儿圆了。</p>
 <a id="more"></a>
<p>遥想起两年前的中秋节，那时候正还看着动画，正好那天是喜欢的七海死的那集。那段时间开始入了另一个大坑，认识了很多人。</p>
<p>去年的这个时候，因为学业繁忙，甚至都没有时间去赏赏月，吃吃月饼。今年也是把去年的月饼给补上了。</p>
<p>然后这就是两年过去了。跨过了毕业的槛，现在正坐在实验室里，对着面前的数据绞尽脑汁。</p>
<p>经历了动荡的一年，现在，这几天算是终于安稳下来了。有了自由的空间，有了喜欢的研究的东西，电脑也配好了，也能和朋友一起玩了。</p>
<p>即将到来的是9天国庆，又能够好好休息一阵子。</p>
<p>远离了庙会对喧嚣（我也不知道是好是坏，对我来说，也是有两面性的。）也终于能够开始做高中毕业就要想做的那件事了。</p>
<p>さ、はじまるよ</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>DigitalOcean成功迁移Vultr</title>
    <url>/2018/09/13/DigitalOcean%E6%88%90%E5%8A%9F%E8%BF%81%E7%A7%BBVultr/</url>
    <content><![CDATA[<p>新日本东京服务器，平均延迟122ms，联通延迟更低，甚至可以加速器用233</p>
<p>但是pixiv默认ban Vultr IP，这就很蛋疼了…..</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>永无止境的庙会里</title>
    <url>/2018/09/09/%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83%E7%9A%84%E5%BA%99%E4%BC%9A%E9%87%8C/</url>
    <content><![CDATA[<p>永无止境的庙会，我能远离它吗？</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>No title</title>
    <url>/2018/08/25/523/</url>
    <content><![CDATA[<blockquote>
<p>Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma — which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.</p>
<p>By Steve Jobs</p>
</blockquote>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>旅途之后</title>
    <url>/2018/08/15/%E6%97%85%E9%80%94%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<p>从最后一节暑期课，到现在，快一个月了。我的旅途结束了。</p>
<p>走了很多地方，看见了不同的人与景，进入了不同的生活。</p>
<p>旅行也许是改变现在的尝试。回到了家。迷茫与困惑的感觉随之而归。一段旅行的结束，是思考的最好时机。</p>
 <a id="more"></a>
<p>仿佛又如四年前那样。</p>
<p>摆在面前的，是无数的不确定。我不知道，我想要做的，是否正确 ——没有答案，亦或是只有在未来才能知晓那个答案。甚至，我不知道那是不是我内心到底想要做的。</p>
<blockquote>
<p>现在想，高考是人生中最轻松的一次考试，它有答案有老师。</p>
<p>可后来生活里的每一道题，都没有答案。</p>
</blockquote>
<p>我只能用很长的时间，付出最大的辛苦，来给出一个我的答案。</p>
<p>筚路蓝缕，以启山林。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>致过去与未来交界的现在</title>
    <url>/2018/07/01/%E8%87%B4%E8%BF%87%E5%8E%BB%E4%B8%8E%E6%9C%AA%E6%9D%A5%E4%BA%A4%E7%95%8C%E7%9A%84%E7%8E%B0%E5%9C%A8/</url>
    <content><![CDATA[<p>蓝渐白的天幕落下</p>
 <a id="more"></a>
<p>闪烁着一颗星星<br>天空纯粹无暇<br>矮矮的楼房立于两边<br>在天幕下，只显得两道黑影</p>
<p>仰望无暇的星空<br>静静伫立<br>沐浴在着清澈湛蓝的夜空下</p>
<p>脑海里闪过了过去与现在的境像<br>那些情感——激动，难过，感动，兴奋，生气，期待…在心中闪烁，点燃了思绪</p>
<p>不一会儿，在夜空的沐浴下，思绪也归于这夜空的宁静。</p>
<p>致过去与未来交界的现在。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>鱼玄机</title>
    <url>/2018/06/25/%E9%B1%BC%E7%8E%84%E6%9C%BA/</url>
    <content><![CDATA[<p>我憨的这首鱼玄机唱的太好听了 av8444592</p>
]]></content>
      <categories>
        <category>Music</category>
      </categories>
  </entry>
  <entry>
    <title>十字路口</title>
    <url>/2018/06/23/%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>下一站，</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>AS安装实录</title>
    <url>/2018/06/01/AS%E5%AE%89%E8%A3%85%E5%AE%9E%E5%BD%95/</url>
    <content><![CDATA[<p>你墙国还是你墙国</p>
<p>XCode10分钟搞定的事情AS能折腾一年</p>
<p>1/安装SDK问题。<br>离线安装SDK，并修改SDK路径</p>
 <a id="more"></a>
<p>2/无限卡下载SDK<br>在/home/aisaka/android-studio/bin/idea.properties中加入一行<br>disable.android.first.run=true</p>
<p>3/安装gradel问题<br>手动离线安装gradel，讲gradel压缩包放入wrapper里的乱码文件夹里，放一个压缩包和一个文件夹<br>然后在setting里手动设置gradel路径到4.4-all</p>
<p>4/gradel无法同步问题<br><a href="https://www.e-learn.cn/content/wangluowenzhang/28422" target="_blank" rel="noopener">https://www.e-learn.cn/content/wangluowenzhang/28422</a></p>
<p>5/同步gradel速度极慢问题<br>改hosts(ipv6 hosts)<br>关掉gradel代理</p>
<p>6/运行模拟器时无法加载驱动问题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">failed to load driver: nouveau</span><br><span class="line">下午3:55 Emulator: libGL error: unable to load driver: nouveau_dri.so</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: libGL error: driver pointer missing</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: libGL error: failed to load driver: nouveau</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: libGL error: unable to load driver: swrast_dri.so</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: libGL error: failed to load driver: swrast</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: emulator: ERROR: Missing initial data partition file: /home/aisaka/.android/avd/Nexus_5X_API_27.avd/userdata.img</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: X Error of failed request: BadValue (integer parameter out of range for operation)</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: Major opcode of failed request: 155 (GLX)</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: Minor opcode of failed request: 24 (X_GLXCreateNewContext)</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: Value in failed request: 0x0</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: Serial number of failed request: 58</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: Current serial number in output stream: 59</span><br><span class="line"></span><br><span class="line">下午3:55 Emulator: Process finished with exit code 1</span><br><span class="line"></span><br><span class="line">下午3:55 Gradle build finished in 1s 316ms</span><br></pre></td></tr></table></figure></p>
<p>问题解决：<a href="https://kotlintc.com/articles/4062" target="_blank" rel="noopener">https://kotlintc.com/articles/4062</a><br>执行如下命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ cd ~/Android/Sdk/emulator/lib64/libstdc++</span><br><span class="line"></span><br><span class="line">$ mv libstdc++.so.6 libstdc++.so.6.bak</span><br><span class="line"></span><br><span class="line">$ ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6 libstdc++.so.6</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>andoird开发</category>
      </categories>
  </entry>
  <entry>
    <title>分治策略</title>
    <url>/2018/05/27/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>对分治策略的分析见文章[递归分析]<a href="http://aisakaki.com/?p=406">http://aisakaki.com/?p=406</a></p>
<p>1、分解（分）</p>
<p>2、解决（治）</p>
<p>3、合并</p>
<p>一些使用分治策略的算法</p>
<p>①归并排序</p>
<p>T(n)=2T(n/2)+Θ(n)</p>
<p>2为子问题数目，n/2为子问题规模，Θ(n)为附加计算量（分治法运行时间）</p>
<p>通过主定理case2，可以得到其T(n)=O(nlgn)</p>
  <a id="more"></a>
<p>②二分查找</p>
<p>分：二分</p>
<p>治：比较。只在一个子数组中递归</p>
<p>T(n)=1*T(n/2)+Θ(1)</p>
<p>1个子问题</p>
<p>③乘方问题</p>
<p>求x^n</p>
<p>如果用朴素方法，那么T(n)=O(n)</p>
<p>如果采用分治策略，那么T(n)=T(n/2)+Θ(1)=O(lgn) (master method) &lt;O(n)</p>
<p>*注意奇偶n的处理，但其递归式不变</p>
<p>只有一个子问题，画递归树的话就是一条链</p>
<p>④非不拉几数列</p>
<p>Fn=Fn-1 + Fn-2 if n&gt;=2</p>
<p>Fn=0 if n=0</p>
<p>Fn=1 if n=1</p>
<p>1*若采用朴素的递归方式，不停计算Fn-1,Fn-2,触底就返回，那么</p>
<p>T(n)=Ω(φ^n)  φ=(1+√5)/2 （φ为黄金比例，神奇）</p>
<p><strong>子问题的规模仅仅缩小到了n-1，递归树非常庞大</strong></p>
<p>复杂度为指数级，代价很高，所以此种方法不好。</p>
<p><strong>最理想的算法复杂度为多项式级</strong></p>
<p>2*事实上，在建立非不拉几递归树的时候，会发现很多公共子树，这些子树重复计算，产生了大量冗余。</p>
<p>如果<strong>考虑从底向上计算</strong>（线性。依次计算F(1),F(2),F(3),….)，那么其复杂度会是O(n)</p>
<p>3*有一个更简单的办法（数学），F(n)=φ^n/√5并取整至最接近的整数，复杂度即为③中的问题，为O(lgn)</p>
<p>由于φ为浮点数，所以这样不精确且对运算要求极高，在现有机器上无法运行</p>
<p>4*第二种数学方法</p>
<p>Fn-1 Fn        =       1      1   ^n</p>
<p>Fn    Fn-2    =        1       0</p>
<p>（左右皆为矩阵，右边是矩阵的n次幂，待安装数学公式插件再修改）</p>
<p>证明：数学归纳法。比较简单，证略。</p>
<p>其复杂度为O(lgn)</p>
<p>⑤矩阵乘法</p>
<p>朴素方法：三层循环，i对应左行，j对应右列，k对应遍历每个元素。T(n)=O(n^3)</p>
<p>分治方法1：</p>
<p>利用分块矩阵，将母矩阵变成2*2的矩阵</p>
<p>A= A11 A12</p>
<p>A21 A22</p>
<p>B=B11 B12</p>
<p>B21 B22</p>
<p>C=C11 C12</p>
<p>C21 C22</p>
<p>由此可以写得四个表达式</p>
<p>c11=A11<em>B11 + A12</em>B21</p>
<p>C12=A11<em>B12+A12</em>B22</p>
<p>C21=A21<em>B11+A22</em>B22</p>
<p>C22=A21<em>B12+A22</em>B22</p>
<p>由此可得每次递归需要将有八个递归子问题（乘），并加上4次矩阵加法时间</p>
<p>（8个规模为n/2的矩阵乘法（递归）和4个规模为n/2（即合并起来为一个规模为n）的矩阵加法（非递归，常数）</p>
<p>所以其递归表达式为 T(n)=8T(n/2)+Θ(n^2)</p>
<p>由主定理得，T(n)=Θ(n^3)</p>
<p>此方法效率依然很低，和朴素方法没什么区别。</p>
<p>思考：为什么效率低？</p>
<p>因为矩阵乘法是Θ(n^3)级复杂度，而一次递归将产生8个子问题，每个子问题皆矩阵乘法</p>
<p>而矩阵加法是Θ(n^2)级复杂度。<strong>所以为了使递归树变小，我们应尽量减少矩阵乘法，多做矩阵加法。</strong></p>
<p>比如，一次递归产生8个子矩阵乘法问题，递归树太“茂盛”了，我们能否减小到7个？</p>
<p>通过这种思考下去，就想到了第二种方法</p>
<p>分治方法2：Strassen方法</p>
<p>该算法具体内容见<a href="https://blog.csdn.net/qwertyuer/article/details/44255087" target="_blank" rel="noopener">https://blog.csdn.net/qwertyuer/article/details/44255087</a></p>
<p>该算法下，T(n)=7T(n/2)+Θ(n^2)=Θ(n^lg7)&lt;Θ(n^3)</p>
<p>分：将AB 矩阵分为8个子矩阵</p>
<p>治：中间计算过程</p>
<p>合：将子问题的解合并为原问题的解</p>
<p>未完待续</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>C#</title>
    <url>/2018/05/25/c/</url>
    <content><![CDATA[<p>闲暇时间做游戏，在学习Unity</p>
<p>由于U3D需要用C#，所以迅速对比java c了解一下C#的语法特性方便记忆。</p>
<p>——————————————————————————</p>
<p>1、析构函数</p>
<p><code>~object() {}</code></p>
<p>2、重写方法</p>
<p><code>override void method() {}</code></p>
 <a id="more"></a>
<p>3、继承(类与接口）</p>
<p><code>public class son : father {}</code></p>
<p>4、无指针，用引用，同java</p>
<p>5、使用<strong>ref</strong>关键字进行引用传递（必须初始化）</p>
<p>ref关键字放在需要传递的变量面前，把一个输出参数的<strong>内存地址</strong>传递给方法（即传递实参）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public void Grow (int _nSpan, **ref** outCurrentAge)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">this.nAge+=_nSpan;</span><br><span class="line"></span><br><span class="line">nOutCurrentAge=this.nAge;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int nCurrentAge=0;</span><br><span class="line"></span><br><span class="line">s.Grow(3 ,**ref** nCurrentAge)</span><br><span class="line"></span><br><span class="line">Console.WriteLine(nCurrentAge);</span><br></pre></td></tr></table></figure></p>
<p>6、使用<strong>out</strong>关键字进行引用传递（无需初始化）</p>
<p>7、使用<strong>params</strong>关键字传递多个参数</p>
<p>params关键字指明一个输出参数被看作为一个参数数组，这种类型的输出参数只能作为方法的最后一个输入参数</p>
<p>主要用于，在调用一个方法时，预先不能确定参数的数量、数据类型等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setHobby(**params** string[] _setArrHobby)</span><br><span class="line"></span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">主程序：s.setHobby(“reading”,”singing”,”programing”);</span><br></pre></td></tr></table></figure>
<p>8、比较字符串</p>
<p><code>int Compare(strA,strB);</code> 输出为0则相等</p>
<p>亦可用<code>lool Equals</code>，<code>int CompareTo</code></p>
<p>不过，Compare是静态方法，且可重载。</p>
<p><code>CompareTo</code>不是静态方法，且没有重载形式</p>
]]></content>
      <categories>
        <category>程序语言</category>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title>递归分析</title>
    <url>/2018/05/23/%E9%80%92%E5%BD%92%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>1、第一种，代入法（数学归纳）</p>
<p>这里需要用到数学归纳法</p>
<p>对于递归式</p>
<p>T(n) = 4T(n/2) + n</p>
<p>函数增长：</p>
<p>当n乘2的时候，T将乘以4</p>
<p>先考虑求其渐进上界</p>
<p>猜测，为theta(n^3)的时候，满足情况</p>
<p>对k&lt;n</p>
<p>T(k)&lt;=ck^3 (T(k) ∈ O(n^3))</p>
<p>设置一个常量g(n)来替代ck^3 （  g(n) ∈ O(n^3))  ）</p>
<p>用数学归纳法证明：</p>
 <a id="more"></a>
<p>1*  T(1)=O(1)</p>
<p>T(1)=c =O(1)</p>
<p>2* 假设T(n/2) = O((n/2)^3) +n</p>
<p>3<em> T(n) = 1/2</em>g(n) +n</p>
<p>=  g(n) + (n – 1/2g(n))</p>
<p>后部为余项</p>
<p>n -1/2g(n) = n – cn^3 <0 (n="">1)</0></p>
<p>∴ T(n) &lt;= g(n)</p>
<p>= O(n^3) （非对称相等）</p>
<p>猜测，为theta(n^2)的时候，满足情况</p>
<p>同理 设置 g(n) = O(n^2)</p>
<p>用数学归纳法证明：</p>
<p>1*  T(1)=O(1)</p>
<p>2* 假设T(n/2) = O((n/2)^2) + n</p>
<p>3<em> T(n) = 4</em>T(n/2) +n</p>
<p>=  g(n) +n</p>
<p>= g(n) – (-n)</p>
<p>(-n)为余项。此时无法证明-n为非负数</p>
<p>所以需要在原来的假设上进行改进</p>
<p>对T(k)进行更低阶的展开 以凑得一个非负的余项（想法：扩展系数到余项）</p>
<p>【注意这里使用了更强的归纳法，所以需要证明的结论更强了。</p>
<p>在归纳的时候需要归纳到的式子的主部已经变了。这里容易忽略】</p>
<p>对k&lt;n</p>
<p><strong>假设 T(k)&lt;=c1*k^2 – c2*k</strong>    (T(k) ∈ O(n^2))</p>
<p>即令g(n)=c1<em>n^2 – c2</em>n</p>
<p>T(n) = 4*T(n/2)+n</p>
<p>=4(c1<em>(n/2)^2 – c2</em>(n/2) +n)</p>
<p>=c1<em>n^2 – (2c2 -4)</em>n</p>
<p>=c1<em>n^2 – c2</em>n – (c2-1)*n n&gt;0)</p>
<p><strong>余项为(c2-1)*n</strong> </p>
<p>∴当c2-1&gt;0即c2&gt;1时</p>
<p>T(n)&lt;=g(n)</p>
<p>=O(n^2)</p>
<p>对基本情况</p>
<p>为使T(1) = c1- c2 =O(1)成立</p>
<p>即 对于∀c2&gt;1,Ec1&gt;c2</p>
<p>∴c1需要足够大</p>
<p>综上所述，当c1足够大,c2&gt;1,T(n)=O(n^2)</p>
<p>证毕</p>
<p>对于渐进下界Omega同理可证</p>
<p>所以有个很关键的地方，就是要进行合理的猜测。</p>
<p>可以通过经验猜测，也可以通过第二种方法递归树法来猜测</p>
<p>2、递归树法</p>
<p>这个方法不太严谨，但很常用（一般要通过代入法来证明）</p>
<p>ATT：</p>
<p>注意并理解递归树的画法（和式画法），理解递归式每一项的意义</p>
<p>理解<strong>非递归代价，递归代价，总代价。</strong></p>
<p>对于式T(n)=aT(n/b)+f(n)中，f(n)即为非递归代价，n为当层规模，比如第3层所有结点的非递归代价和即为a^2 * f(n/b^3) ，单个结点的非递归代价为 f(n/b^3)。如果算上递归代价，就还需要计算该结点下递归子树的总代价。</p>
<p><strong>f(n)不再递归，反应了该节点的非递归部分的代价。</strong></p>
<p><strong>aT(n/b)反应了函数增长，我们可以在其中看出横向增长(子问题数目）和递归规模（子问题规模）。</strong></p>
<p>注意层数=高度+1 完全N叉树的叶节点=N^高度</p>
<p>网站上不方便画图emmm</p>
<p>所以，图略</p>
<p>分析递归树：</p>
<p>对于T(n)=cn^2+3T(n/4)</p>
<p>纵向分析：</p>
<p>子问题的规模为上一步的1/4</p>
<p>最终问题规模会到达1 （代价:T(1)）</p>
<p>深度为i的结点对应规模为 n/(4^i) 的子问题</p>
<p>所以当触底，子问题规模为1时 ，即 n/(4^i)=1， 递归树有log4(n)+1层（深度为0,1,2…log4(n)）</p>
<p>横向分析：</p>
<p>对于第i层，结点数为3^i</p>
<p>所以对于第i层的代价为 3^i * (n/(4^i))^2</p>
<p>所以对于最后一层，即i=log4(n)，代入即可得 最后一层的代价为 n^log4(3) * T(1)</p>
<p>T(1)为常数,n为常数</p>
<p>所以最后一层的代价为theta(n^log4(3))</p>
<p>经过以上分析，我们可以知道每一层的代价为一个等比级数，用等比级数求和公式即可求出整颗树的总代价。</p>
<p>由于有时候在表示渐进上界的时候并不需要如此严格(精确度不需要这么高），所以可以放缩为比较好处理的级数</p>
<p>3、主方法</p>
<p>主定理(master method)适用于一种形式的递归式</p>
<p>T(n)=aT(n/b)+f(n)</p>
<p>（公式比较复杂，等安装了插件之后再写数学表达式，网页不方便表示）</p>
<p>定理的证明：通过三个引理来证明</p>
<p>1*使用递归树求得代价公式（为一个等比级数和与叶结点代价和之和），</p>
<p>2*考虑f(n)的三种情况，在等比级数上进行变形，推导出简化渐进上界</p>
<p>3*将变形后的等比级数和所求得的简化渐进上界与原来的叶节点代价和相加，得到最终的渐进上界</p>
<p>（具体推导过程略，网站暂时上不方便写太多公式）</p>
<p>主定理对于快速求解非常重要，需要牢记结论</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA的两个问题</title>
    <url>/2018/05/15/JAVA%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在写工厂的时候，对于这样一个语句，遇到了两个问题</p>
<p>mom obj = new son();</p>
<p>以下为源代码</p>
<p><img src="http://aisakaki.com/wp-content/uploads/2018/05/0FEEB447832EE00327DC103C3A4A6B57-278x300.png" alt="0FEEB447832EE00327DC103C3A4A6B57"></p>
<p>输出的结果为</p>
<p>0</p>
<p>Type son</p>
<p>一、</p>
<p>这就很奇怪了。按照已知知识，mom obj = new son();这句话是在堆上新建一个son类型的对象，然后向上转型为mom类型。此时的obj，既是属于son类型，也属于其基类mom类型。这是java多态性的一个具体体现。对象实体是son类型的，那么我在调用son中的方法test的时候，和输出变量a的时候，理想输出应为</p>
 <a id="more"></a>
<p>1</p>
<p>Type son</p>
<p>然而结果却不是。方法调用的是子类的方法，然而成员变量却调用的是基类的变量值。</p>
<p>我又运行了如下代码，更奇怪的事情发生了。</p>
<p>我在son类中加入了一个新方法test2()。在主函数中调用obj中的test2方法。</p>
<p><img src="http://aisakaki.com/wp-content/uploads/2018/05/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-15-%E4%B8%8B%E5%8D%888.49.52-300x253.png" alt="屏幕快照 2018-05-15 下午8.49.52"></p>
<p>更奇怪的事情发生了。</p>
<p><img src="http://aisakaki.com/wp-content/uploads/2018/05/29ECB79D17CD24DFC8F94CD0615777E2-300x91.png" alt="29ECB79D17CD24DFC8F94CD0615777E2"></p>
<p>为什么编译器不认这个儿子了？</p>
<p>经过多次测试，和查阅资料，我终于知道了原因。</p>
<p><strong>首先要知道，java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法否是后期绑定的（动态绑定）。</strong>(final可以关闭动态绑定，但实际上，这对性能提升并不大，所以不要试图用final来提升性能，而是根据设计决定是否使用final）</p>
<p><strong>向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法。也会覆盖与父类中相同的方法–重写。</strong><br>所以obj可以调用的是mom中有的方法，而son中有，mom中却没有的方法，是不能调用的。<br>java 的这种机制遵循一个原则：当超类对象引用变量引用子类对象时,被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法， 但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p>
<p>于是我们可以知道，向上转型机制，实际上遗失了子类的成员变量和基类没有的方法。</p>
<p>这就解释了为什么是这样的结果。</p>
<p>二、</p>
<p>在探究这个语句的执行过程的时候，就又引申出了另一个问题。构造器的继承问题。</p>
<p>对于mom obj = new son();</p>
<p>按照已知知识，mom obj是建立了一个mom类型的引用obj，相当于c中的一个指针。此时由于没有对象实体，其值为null（空指针）。但是当我在执行以下代码的时候，却发生了很奇怪的事情。</p>
<p>对于以下语句</p>
<p><img src="http://aisakaki.com/wp-content/uploads/2018/05/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-15-%E4%B8%8B%E5%8D%888.38.42-300x264.png" alt="屏幕快照 2018-05-15 下午8.38.42"></p>
<p>输出结果为</p>
<p>mom</p>
<p>son</p>
<p>奇怪了，难道是mom obj这个语句的时候就已经进行了对象的创建和初始化？</p>
<p>我试了一下，如果只是</p>
<p><img src="http://aisakaki.com/wp-content/uploads/2018/05/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-15-%E4%B8%8B%E5%8D%888.40.24-300x31.png" alt="屏幕快照 2018-05-15 下午8.40.24"></p>
<p>那么结果为</p>
<p><img src="http://aisakaki.com/wp-content/uploads/2018/05/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-15-%E4%B8%8B%E5%8D%888.40.33-300x59.png" alt="屏幕快照 2018-05-15 下午8.40.33"></p>
<p>说明了mom obj语句并没有创建和初始化对象，只是声明了一个mom类型的引用。</p>
<p>于是我查阅书籍，在《thinking in java》看到了如下几段</p>
<p><strong>“类的代码在初次使用的时候才加载。这通常是指加载发生于创建类的第一个对象之时，但是当访问static域或static方法的时候，也会发生加载（构造器也是static方法，尽管static关键字并没有显示地写出来。因此更准确地讲，类是在其任何static成员被访问的时候加载的。”</strong></p>
<p>所以说实际上，</p>
<p>在加载类的时候，会依次访问加载基类（或叫父类，超类），其中在遇到static对象和代码段的时候，会依程序中的顺序初始化。（而构造器也是static方法，只是没有写出来而已。</p>
<p>所以举例 对继承关系 A-&gt;B-&gt;C-&gt;D</p>
<p>在生成D类对象的时候，会执行构造器且构造器执行顺序为A-&gt;B-&gt;C-&gt;D。</p>
<p>这就解释了为什么是这个结果。</p>
]]></content>
      <categories>
        <category>程序语言</category>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>图书馆</title>
    <url>/2018/05/12/%E5%9B%BE%E4%B9%A6%E9%A6%86/</url>
    <content><![CDATA[<p>一个知道自己有多渺小的地方…</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>多级中文域名解析系统-3</title>
    <url>/2018/04/05/%E5%A4%9A%E7%BA%A7%E4%B8%AD%E6%96%87%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%B3%BB%E7%BB%9F-3%EF%BC%88c%E8%AF%AD%E8%A8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="ROOT-DNS"><a href="#ROOT-DNS" class="headerlink" title="ROOT_DNS"></a>ROOT_DNS</h2><p><em>根服务器的逻辑代码</em></p>
 <a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"defAndTools.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RRFILE <span class="meta-string">"RRroot.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> sendbuf[<span class="number">512</span>];</span><br><span class="line">	<span class="keyword">char</span> recvbuf[<span class="number">512</span>]; </span><br><span class="line">	<span class="keyword">int</span> sendBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	addr.sin_family =AF_INET;</span><br><span class="line">	addr.sin_port =htons(SERVER_PORT);</span><br><span class="line">	addr.sin_addr.s_addr=inet_addr(ROOT_SERVER_IP);   </span><br><span class="line">	</span><br><span class="line">	bind(sockfd,(struct sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(cli);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)   </span><br><span class="line">	&#123;</span><br><span class="line">		recvfrom(sockfd,recvbuf,<span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>,(struct sockaddr*)&amp;cli,&amp;len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n收到本地服务器请求：\n"</span>);</span><br><span class="line">		<span class="comment">//读取，构造包，得到需要找的域名和类型</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">recv_header</span>;</span></span><br><span class="line">		recv_header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">		decode_header(recv_header,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		print_header(recv_header);	</span><br><span class="line">		</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Query</span> *<span class="title">query_section</span>;</span></span><br><span class="line">		query_section = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_QUERY));</span><br><span class="line">		decode_query_section(query_section,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		print_query_section(query_section);      </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//开始查找与写缓冲</span></span><br><span class="line">		<span class="comment">//调用初次搜索函数</span></span><br><span class="line">		<span class="keyword">int</span> over = firstFindRR(query_section,RRFILE,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第一次搜索没有查到结果,开始查询下一个该去哪个服务器</span></span><br><span class="line">		<span class="keyword">if</span>(over==<span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n本服务器没有找到\n"</span>);</span><br><span class="line">			loopFindNS(query_section,RRFILE,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//发送</span></span><br><span class="line">		sendto(sockfd,sendbuf,sendBufferPointer,<span class="number">0</span>,(struct sockaddr*)&amp;cli,len);  </span><br><span class="line">		<span class="comment">//缓冲区重置</span></span><br><span class="line">		sendBufferPointer=<span class="number">0</span>;    </span><br><span class="line">		recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">		<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DNS1"><a href="#DNS1" class="headerlink" title="DNS1"></a>DNS1</h2><p><em>第一级域名解析服务器主逻辑，以下四个中间级服务器逻辑都差不多</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"defAndTools.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">"127.0.0.4"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RRFILE <span class="meta-string">"RRL1.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> sendbuf[<span class="number">512</span>];</span><br><span class="line">	<span class="keyword">char</span> recvbuf[<span class="number">512</span>]; </span><br><span class="line">	<span class="keyword">int</span> sendBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	addr.sin_family =AF_INET;</span><br><span class="line">	addr.sin_port =htons(SERVER_PORT);</span><br><span class="line">	addr.sin_addr.s_addr=inet_addr(SERVER_IP);   </span><br><span class="line">	</span><br><span class="line">	bind(sockfd,(struct sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(cli);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)   </span><br><span class="line">	&#123;</span><br><span class="line">		recvfrom(sockfd,recvbuf,<span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>,(struct sockaddr*)&amp;cli,&amp;len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n收到本地服务器请求：\n"</span>);</span><br><span class="line">		<span class="comment">//读取，构造包，得到需要找的域名和类型</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">recv_header</span>;</span></span><br><span class="line">		recv_header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">		decode_header(recv_header,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		print_header(recv_header);	</span><br><span class="line">		</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Query</span> *<span class="title">query_section</span>;</span></span><br><span class="line">		query_section = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_QUERY));</span><br><span class="line">		decode_query_section(query_section,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		print_query_section(query_section);      </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//开始查找与写缓冲</span></span><br><span class="line">		<span class="comment">//调用初次搜索函数</span></span><br><span class="line">		<span class="keyword">int</span> over = firstFindRR(query_section,RRFILE,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第一次搜索没有查到结果,开始查询下一个该去哪个服务器</span></span><br><span class="line">		<span class="keyword">if</span>(over==<span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n本服务器没有找到\n"</span>);</span><br><span class="line">			loopFindNS(query_section,RRFILE,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//发送</span></span><br><span class="line">		sendto(sockfd,sendbuf,sendBufferPointer,<span class="number">0</span>,(struct sockaddr*)&amp;cli,len);  </span><br><span class="line">		<span class="comment">//缓冲区重置</span></span><br><span class="line">		sendBufferPointer=<span class="number">0</span>;    </span><br><span class="line">		recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">		<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DNS2"><a href="#DNS2" class="headerlink" title="DNS2"></a>DNS2</h2><p><em>第二级域名解析服务器主逻辑</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"defAndTools.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">"127.0.0.5"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RRFILE <span class="meta-string">"RRL2.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> sendbuf[<span class="number">512</span>];</span><br><span class="line">	<span class="keyword">char</span> recvbuf[<span class="number">512</span>]; </span><br><span class="line">	<span class="keyword">int</span> sendBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	addr.sin_family =AF_INET;</span><br><span class="line">	addr.sin_port =htons(SERVER_PORT);</span><br><span class="line">	addr.sin_addr.s_addr=inet_addr(SERVER_IP);   </span><br><span class="line">	</span><br><span class="line">	bind(sockfd,(struct sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(cli);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)   </span><br><span class="line">	&#123;</span><br><span class="line">		recvfrom(sockfd,recvbuf,<span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>,(struct sockaddr*)&amp;cli,&amp;len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n收到本地服务器请求：\n"</span>);</span><br><span class="line">		<span class="comment">//读取，构造包，得到需要找的域名和类型</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">recv_header</span>;</span></span><br><span class="line">		recv_header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">		decode_header(recv_header,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		print_header(recv_header);	</span><br><span class="line">		</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Query</span> *<span class="title">query_section</span>;</span></span><br><span class="line">		query_section = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_QUERY));</span><br><span class="line">		decode_query_section(query_section,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		print_query_section(query_section);      </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//开始查找与写缓冲</span></span><br><span class="line">		<span class="comment">//调用初次搜索函数</span></span><br><span class="line">		<span class="keyword">int</span> over = firstFindRR(query_section,RRFILE,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第一次搜索没有查到结果,开始查询下一个该去哪个服务器</span></span><br><span class="line">		<span class="keyword">if</span>(over==<span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n本服务器没有找到\n"</span>);</span><br><span class="line">			loopFindNS(query_section,RRFILE,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//发送</span></span><br><span class="line">		sendto(sockfd,sendbuf,sendBufferPointer,<span class="number">0</span>,(struct sockaddr*)&amp;cli,len);  </span><br><span class="line">		<span class="comment">//缓冲区重置</span></span><br><span class="line">		sendBufferPointer=<span class="number">0</span>;    </span><br><span class="line">		recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">		<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DNS3"><a href="#DNS3" class="headerlink" title="DNS3"></a>DNS3</h2><p><em>第三级域名解析服务器主逻辑</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"defAndTools.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">"127.0.0.6"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RRFILE <span class="meta-string">"RRL3.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> sendbuf[<span class="number">512</span>];</span><br><span class="line">	<span class="keyword">char</span> recvbuf[<span class="number">512</span>]; </span><br><span class="line">	<span class="keyword">int</span> sendBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	addr.sin_family =AF_INET;</span><br><span class="line">	addr.sin_port =htons(SERVER_PORT);</span><br><span class="line">	addr.sin_addr.s_addr=inet_addr(SERVER_IP);   </span><br><span class="line">	</span><br><span class="line">	bind(sockfd,(struct sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(cli);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)   </span><br><span class="line">	&#123;</span><br><span class="line">		recvfrom(sockfd,recvbuf,<span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>,(struct sockaddr*)&amp;cli,&amp;len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n收到本地服务器请求：\n"</span>);</span><br><span class="line">		<span class="comment">//读取，构造包，得到需要找的域名和类型</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">recv_header</span>;</span></span><br><span class="line">		recv_header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">		decode_header(recv_header,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		print_header(recv_header);	</span><br><span class="line">		</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Query</span> *<span class="title">query_section</span>;</span></span><br><span class="line">		query_section = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_QUERY));</span><br><span class="line">		decode_query_section(query_section,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		print_query_section(query_section);      </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//开始查找与写缓冲</span></span><br><span class="line">		<span class="comment">//调用初次搜索函数</span></span><br><span class="line">		<span class="keyword">int</span> over = firstFindRR(query_section,RRFILE,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第一次搜索没有查到结果,开始查询下一个该去哪个服务器</span></span><br><span class="line">		<span class="keyword">if</span>(over==<span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n本服务器没有找到\n"</span>);</span><br><span class="line">			loopFindNS(query_section,RRFILE,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//发送</span></span><br><span class="line">		sendto(sockfd,sendbuf,sendBufferPointer,<span class="number">0</span>,(struct sockaddr*)&amp;cli,len);  </span><br><span class="line">		<span class="comment">//缓冲区重置</span></span><br><span class="line">		sendBufferPointer=<span class="number">0</span>;    </span><br><span class="line">		recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">		<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DNS4"><a href="#DNS4" class="headerlink" title="DNS4"></a>DNS4</h2><p><em>第四级域名解析服务器主逻辑</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"defAndTools.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">"127.0.0.7"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RRFILE <span class="meta-string">"RRL4.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> sendbuf[<span class="number">512</span>];</span><br><span class="line">	<span class="keyword">char</span> recvbuf[<span class="number">512</span>]; </span><br><span class="line">	<span class="keyword">int</span> sendBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	addr.sin_family =AF_INET;</span><br><span class="line">	addr.sin_port =htons(SERVER_PORT);</span><br><span class="line">	addr.sin_addr.s_addr=inet_addr(SERVER_IP);   </span><br><span class="line">	</span><br><span class="line">	bind(sockfd,(struct sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(cli);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)   </span><br><span class="line">	&#123;</span><br><span class="line">		recvfrom(sockfd,recvbuf,<span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>,(struct sockaddr*)&amp;cli,&amp;len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n收到本地服务器请求：\n"</span>);</span><br><span class="line">		<span class="comment">//读取，构造包，得到需要找的域名和类型</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">recv_header</span>;</span></span><br><span class="line">		recv_header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">		decode_header(recv_header,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		print_header(recv_header);	</span><br><span class="line">		</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Query</span> *<span class="title">query_section</span>;</span></span><br><span class="line">		query_section = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_QUERY));</span><br><span class="line">		decode_query_section(query_section,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		print_query_section(query_section);      </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//开始查找与写缓冲</span></span><br><span class="line">		<span class="comment">//调用初次搜索函数</span></span><br><span class="line">		<span class="keyword">int</span> over = firstFindRR(query_section,RRFILE,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第一次搜索没有查到结果,开始查询下一个该去哪个服务器</span></span><br><span class="line">		<span class="keyword">if</span>(over==<span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n本服务器没有找到\n"</span>);</span><br><span class="line">			loopFindNS(query_section,RRFILE,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//发送</span></span><br><span class="line">		sendto(sockfd,sendbuf,sendBufferPointer,<span class="number">0</span>,(struct sockaddr*)&amp;cli,len);  </span><br><span class="line">		<span class="comment">//缓冲区重置</span></span><br><span class="line">		sendBufferPointer=<span class="number">0</span>;    </span><br><span class="line">		recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">		<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数与设置"><a href="#参数与设置" class="headerlink" title="参数与设置"></a>参数与设置</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL_SERVER_IP <span class="meta-string">"127.0.0.2"</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>多级中文域名解析系统-2</title>
    <url>/2018/04/05/%E5%A4%9A%E7%BA%A7%E4%B8%AD%E6%96%87%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%B3%BB%E7%BB%9F-2%EF%BC%88c%E8%AF%AD%E8%A8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="LOCAL-DNS"><a href="#LOCAL-DNS" class="headerlink" title="LOCAL_DNS"></a>LOCAL_DNS</h2><p><em>local DNS作为本地网络中的逻辑核心非常重要</em></p>
 <a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"defAndTools.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"localServer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHEFILE <span class="meta-string">"localCache.txt"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEnd</span><span class="params">(struct DNS_Header *header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (header-&gt;authorNum!=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//①设置监听</span></span><br><span class="line">	<span class="keyword">int</span> serverSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//发送缓冲区和接收缓冲区</span></span><br><span class="line">	<span class="keyword">char</span> sendbuf[<span class="number">512</span>];</span><br><span class="line">	<span class="keyword">char</span> recvbuf[<span class="number">512</span>]; </span><br><span class="line">	<span class="keyword">int</span> sendBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//初始化缓冲区</span></span><br><span class="line">	<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//声明两个套接字sockaddr_in结构体，分别用于客户端和服务器 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span>  </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span>  </span><br><span class="line">	<span class="keyword">int</span> addr_len = <span class="keyword">sizeof</span>(clientAddr);  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> client;  </span><br><span class="line">	<span class="comment">//初始化服务器端的套接字</span></span><br><span class="line">	bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));  </span><br><span class="line">	server_addr.sin_family = AF_INET;  </span><br><span class="line">	server_addr.sin_port = htons(SERVER_PORT); </span><br><span class="line">	server_addr.sin_addr.s_addr = inet_addr(LOCAL_SERVER_IP);  </span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//绑定套接字</span></span><br><span class="line">	bind(serverSocket, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">	<span class="comment">//设置监听状态</span></span><br><span class="line">	listen(serverSocket, <span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//②循环监听</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"监听端口 ： %d\n"</span>,SERVER_PORT);</span><br><span class="line">		<span class="comment">//调用accept，进入阻塞状态，返回一个client套接字描述符</span></span><br><span class="line">		client = accept(serverSocket, (struct sockaddr*)&amp;clientAddr, (<span class="keyword">socklen_t</span>*)&amp;addr_len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"连接成功\n"</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">c</span>;</span></span><br><span class="line">		<span class="keyword">socklen_t</span> cLen = <span class="keyword">sizeof</span>(c);</span><br><span class="line">		getpeername(client, (struct sockaddr*) &amp;c, &amp;cLen); </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"请求端信息： %s : %d\n"</span>,inet_ntoa(c.sin_addr),ntohs(c.sin_port));	</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//对于TCP，先接收一个两字节的包长度</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">short</span> recv_length;</span><br><span class="line">		recv(client,&amp;recv_length,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		recv_length = ntohs(recv_length);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//接收客户端发来的数据，recv返回值为接收字节数</span></span><br><span class="line">		<span class="keyword">int</span> dataNum = recv(client,recvbuf,recv_length,<span class="number">0</span>);</span><br><span class="line">					</span><br><span class="line">		<span class="comment">//③提取recvbuf，构建DNS包</span></span><br><span class="line">		<span class="comment">//构造DNS包头部，从缓冲区读取一个DNS头部</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">client_query_header</span>;</span></span><br><span class="line">		client_query_header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">		decode_header(client_query_header,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n请求端信息：\n"</span>);</span><br><span class="line">		print_header(client_query_header);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//构造准备发送的DNS头部</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">query_header</span>;</span></span><br><span class="line">		query_header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">		<span class="built_in">memcpy</span>(query_header,client_query_header,<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">		query_header-&gt;queryNum = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//④解析并处理请求</span></span><br><span class="line">		<span class="comment">//有多少个请求，就进行几次循环，每个循环完成一次系统运作</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;client_query_header-&gt;queryNum;i++)   </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//读取解析一个请求部分</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Query</span> *<span class="title">client_query_section</span>;</span></span><br><span class="line">			client_query_section = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_QUERY));</span><br><span class="line">			decode_query_section(client_query_section,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n正在处理第 %d 个请求\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">			print_query_section(client_query_section);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//判断本地缓存中是否存在</span></span><br><span class="line">			<span class="keyword">int</span> findInCache = firstFindRR(client_query_section,CACHEFILE,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (findInCache==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"在本地缓存中找到记录，直接回复请求\n"</span>);</span><br><span class="line">				<span class="keyword">goto</span> findit;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//本地缓存不存在</span></span><br><span class="line">			<span class="keyword">char</span> UDPsendbuf[<span class="number">512</span>];</span><br><span class="line">			<span class="keyword">char</span> UDPrecvbuf[<span class="number">512</span>]; </span><br><span class="line">			<span class="keyword">int</span> UDPsendBufferPointer=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> UDPrecvBufferPointer=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">memset</span>(UDPsendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">			<span class="built_in">memset</span>(UDPrecvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//直接将从客户端接受收的包写入缓冲区</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n发送给根服务器的请求：\n"</span>);</span><br><span class="line">			encode_header(query_header,UDPsendbuf,&amp;UDPsendBufferPointer);</span><br><span class="line">			print_header(query_header);</span><br><span class="line">			encode_query_section(client_query_section,UDPsendbuf,&amp;UDPsendBufferPointer);</span><br><span class="line">			print_query_section(client_query_section);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//定义用于接收的结构。由于根服务器必然不可能返回最终结果，所以不需要构造answer</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">recv_header</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">DNS_RR</span> *<span class="title">recv_answer</span>,*<span class="title">recv_authority</span>,*<span class="title">recv_additional</span>;</span></span><br><span class="line">			recv_header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">			recv_authority = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">			recv_additional = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//与根服务器建立UDP连接</span></span><br><span class="line">			<span class="keyword">int</span> sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">			addr.sin_family =AF_INET;</span><br><span class="line">			addr.sin_port =htons(SERVER_PORT);</span><br><span class="line">			addr.sin_addr.s_addr=inet_addr(ROOT_SERVER_IP);	</span><br><span class="line">			</span><br><span class="line">			bind(sockfd,(struct sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//发送  </span></span><br><span class="line">			sendto(sockfd,UDPsendbuf,UDPsendBufferPointer,<span class="number">0</span>,(struct sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//接收回复</span></span><br><span class="line">			<span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(addr);</span><br><span class="line">			recvfrom(sockfd,UDPrecvbuf,<span class="keyword">sizeof</span>(UDPrecvbuf),<span class="number">0</span>,(struct sockaddr*)&amp;addr,&amp;len);   </span><br><span class="line">			</span><br><span class="line">			<span class="comment">//断开</span></span><br><span class="line">			close(sockfd); </span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n收到根服务器的回复：\n"</span>);</span><br><span class="line">			<span class="comment">//从接收缓冲区解析并构造包结构然后打印</span></span><br><span class="line">			decode_header(recv_header,UDPrecvbuf,&amp;UDPrecvBufferPointer);</span><br><span class="line">			print_header(recv_header);</span><br><span class="line">			 </span><br><span class="line">			decode_resource_record(recv_authority,UDPrecvbuf,&amp;UDPrecvBufferPointer);</span><br><span class="line">			print_resource_record(recv_authority);</span><br><span class="line">			decode_resource_record(recv_additional,UDPrecvbuf,&amp;UDPrecvBufferPointer);</span><br><span class="line">			print_resource_record(recv_additional);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//重置缓冲区</span></span><br><span class="line">			UDPsendBufferPointer=<span class="number">0</span>;</span><br><span class="line">			UDPrecvBufferPointer=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">memset</span>(UDPsendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">			<span class="built_in">memset</span>(UDPrecvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//用于计数本次循环是第几级服务器发来的</span></span><br><span class="line">			<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(isEnd(recv_header)==<span class="number">0</span>)  </span><br><span class="line">			&#123;</span><br><span class="line">				count++;</span><br><span class="line">				<span class="comment">//向下一个服务器建立UDP连接</span></span><br><span class="line">				<span class="keyword">int</span> sockfm=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">				addr.sin_family =AF_INET;</span><br><span class="line">				addr.sin_port =htons(SERVER_PORT);</span><br><span class="line">				addr.sin_addr.s_addr=inet_addr(recv_additional-&gt;rdata);		</span><br><span class="line">				<span class="comment">//recv_additional-&gt;rdata即保存着下一个服务器的IP</span></span><br><span class="line">				</span><br><span class="line">				bind(sockfm,(struct sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//重置缓冲区和结构</span></span><br><span class="line">				UDPsendBufferPointer=<span class="number">0</span>;</span><br><span class="line">				UDPrecvBufferPointer=<span class="number">0</span>;</span><br><span class="line">				<span class="built_in">memset</span>(UDPsendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">				<span class="built_in">memset</span>(UDPrecvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">				<span class="built_in">free</span>(recv_header);     recv_header = <span class="literal">NULL</span>;           </span><br><span class="line">				<span class="built_in">free</span>(recv_authority);  recv_authority = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="built_in">free</span>(recv_additional); recv_additional = <span class="literal">NULL</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//直接将从客户端接受收的请求写入发送缓冲区</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\n发送给 %d级 服务器的请求：\n"</span>,count);</span><br><span class="line">				encode_header(query_header,UDPsendbuf,&amp;UDPsendBufferPointer);</span><br><span class="line">				print_header(query_header);</span><br><span class="line">				encode_query_section(client_query_section,UDPsendbuf,&amp;UDPsendBufferPointer);</span><br><span class="line">				print_query_section(client_query_section);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//发送</span></span><br><span class="line">				sendto(sockfm,UDPsendbuf,UDPsendBufferPointer,<span class="number">0</span>,(struct sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//接收回复</span></span><br><span class="line">				len=<span class="keyword">sizeof</span>(addr);</span><br><span class="line">				recvfrom(sockfm,UDPrecvbuf,<span class="keyword">sizeof</span>(UDPrecvbuf),<span class="number">0</span>,(struct sockaddr*)&amp;addr,&amp;len);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//断开连接</span></span><br><span class="line">				close(sockfm); </span><br><span class="line">				</span><br><span class="line">				<span class="comment">//开始处理</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\n收到 %d级 服务器发来的回复：\n"</span>,count);	</span><br><span class="line">				</span><br><span class="line">				recv_header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">				recv_answer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">				recv_authority = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">				recv_additional = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">				</span><br><span class="line">				decode_header(recv_header,UDPrecvbuf,&amp;UDPrecvBufferPointer);</span><br><span class="line">				print_header(recv_header);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;recv_header-&gt;answerNum;j++)&#123;   </span><br><span class="line">					decode_resource_record(recv_answer,UDPrecvbuf,&amp;UDPrecvBufferPointer);</span><br><span class="line">					print_resource_record(recv_answer);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;recv_header-&gt;authorNum;j++)&#123;  </span><br><span class="line">					decode_resource_record(recv_authority,UDPrecvbuf,&amp;UDPrecvBufferPointer);</span><br><span class="line">					print_resource_record(recv_authority);</span><br><span class="line">				&#125;</span><br><span class="line">				 </span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;recv_header-&gt;addNum;j++)&#123;      </span><br><span class="line">					decode_resource_record(recv_additional,UDPrecvbuf,&amp;UDPrecvBufferPointer);</span><br><span class="line">					print_resource_record(recv_additional);</span><br><span class="line">				&#125;			</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//UDP请求的循环结束，此时构造得到的结构体已经得到该次请求目标结果，且已经在循环中打印  </span></span><br><span class="line">			<span class="comment">//将从最终结果服务器返回来的结构写入发送缓冲区，本次循环结束</span></span><br><span class="line">			encode_header(recv_header,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;recv_header-&gt;answerNum;j++)&#123;</span><br><span class="line">				encode_resource_record(recv_answer,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">				<span class="comment">//将结果写入cache</span></span><br><span class="line">				addRRToCache(recv_answer,<span class="string">"localCache.txt"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;recv_header-&gt;authorNum;j++)&#123;</span><br><span class="line">				encode_resource_record(recv_authority,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">				addRRToCache(recv_authority,<span class="string">"localCache.txt"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;recv_header-&gt;addNum;j++)&#123;</span><br><span class="line">				encode_resource_record(recv_additional,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">				addRRToCache(recv_additional,<span class="string">"localCache.txt"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		findit:;</span><br><span class="line">			<span class="comment">//⑤发送缓冲</span></span><br><span class="line">			<span class="comment">//发送已准备好的在缓冲区的数据,包总长度即为当下发送缓冲区指针下标</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">short</span> send_length = htons(sendBufferPointer);</span><br><span class="line">			send(client,&amp;send_length,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">			send(client, sendbuf, sendBufferPointer, <span class="number">0</span>);   </span><br><span class="line">			<span class="comment">//一个请求的解析与回答发送结束,清空发送缓冲区与指针，准备进行下一次发送</span></span><br><span class="line">			sendBufferPointer=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//对一个客户端的所有请求解析结束</span></span><br><span class="line">		close(client);</span><br><span class="line">		recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"连接关闭\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"===================================\n\n"</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p><em>Client为本机主逻辑</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="comment">//底层操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"defAndTools.h"</span></span></span><br><span class="line"><span class="comment">//本地服务器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"localServer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//容错</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(argc<span class="number">-1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">		<span class="keyword">if</span> (strTypeToCode(argv[<span class="number">2</span>*i])==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"类型错误！\n"</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//①连接本地服务器 初始化TCP连接</span></span><br><span class="line">	<span class="keyword">int</span> clientSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//发送缓冲和接收缓冲</span></span><br><span class="line">	<span class="keyword">char</span> sendbuf[<span class="number">512</span>];    </span><br><span class="line">	<span class="keyword">char</span> recvbuf[<span class="number">512</span>];</span><br><span class="line">	<span class="comment">//定义缓冲区指示下标</span></span><br><span class="line">	<span class="keyword">int</span> sendBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//清空缓冲区</span></span><br><span class="line">	<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">	serverAddr.sin_family = AF_INET;</span><br><span class="line">	serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">	serverAddr.sin_addr.s_addr = inet_addr(LOCAL_SERVER_IP);</span><br><span class="line">	<span class="comment">//连接服务器</span></span><br><span class="line">	<span class="keyword">if</span>(connect(clientSocket, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr))==<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"连接失败\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"发送信息：\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//②根据输入内容，准备DNS包，并写入发送缓冲区</span></span><br><span class="line">	<span class="comment">//定义DNS头部</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">query_header</span>;</span></span><br><span class="line">	query_header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">	<span class="comment">//调用函数，填写欲发送的DNS包的头部结构体</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> tag = create_tag(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);    </span><br><span class="line">	<span class="comment">//argc-1除2即为域名请求的个数，因为每个域名参数后带一个类型</span></span><br><span class="line">	create_query_header(query_header,<span class="number">999</span>,tag,argc/<span class="number">2</span>,<span class="number">0x0000</span>,<span class="number">0x0000</span>,<span class="number">0x0000</span>);</span><br><span class="line">	<span class="comment">//将头部写入缓冲区</span></span><br><span class="line">	encode_header(query_header,sendbuf,&amp;sendBufferPointer);</span><br><span class="line">	<span class="comment">//打印生成的头部</span></span><br><span class="line">	print_header(query_header);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据运行参数生成一个或多个请求部分并写入缓冲区                         </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(argc<span class="number">-1</span>)/<span class="number">2</span>;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//填写DNS请求结构，argv[2*i]字符串对应的类型</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">short</span> qtype = strTypeToCode(argv[<span class="number">2</span>*i]);    </span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">short</span> qclass = <span class="number">0x0001</span>;  </span><br><span class="line">		</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Query</span> *<span class="title">query_section</span>;</span></span><br><span class="line">		query_section = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_QUERY));</span><br><span class="line">		create_query_section(query_section,argv[<span class="number">2</span>*i<span class="number">-1</span>],qtype,qclass);</span><br><span class="line">		encode_query_section(query_section,sendbuf,&amp;sendBufferPointer);	</span><br><span class="line">		print_query_section(query_section);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//③向本地服务器发包</span></span><br><span class="line">	<span class="comment">//发送已准备好的在缓冲区的数据,包总长度即为当下发送缓冲区指针下标</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> length = htons(sendBufferPointer);</span><br><span class="line">	<span class="comment">//对于TCP连接，必须先发送一个DNS包总长度，否则wireshark不会识别！</span></span><br><span class="line">	send(clientSocket,&amp;length,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	send(clientSocket, sendbuf, sendBufferPointer, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//④根据请求数量收包,有多少个请求就会收到多少个DNS包</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;query_header-&gt;queryNum;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">short</span> recv_length;</span><br><span class="line">		recv(clientSocket,&amp;recv_length,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		recv_length = ntohs(recv_length);</span><br><span class="line">		<span class="keyword">int</span> dataNum = recv(clientSocket, recvbuf, recv_length, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//⑤处理接收到缓冲区的DNS包,从中抽取出需要返还给用户的数据</span></span><br><span class="line">		<span class="comment">//构造DNS包头部，从缓冲区读取并填充DNS头部	</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">recv_header</span>;</span></span><br><span class="line">		recv_header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">		decode_header(recv_header,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[回复： %d]\n"</span>,k+<span class="number">1</span>);</span><br><span class="line">		print_header(recv_header);	</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_RR</span> *<span class="title">recv_answer</span>,*<span class="title">recv_add</span>;</span></span><br><span class="line">		<span class="comment">//标准回复只可能在answer和addition有值，所以只需要考虑读这两个部分</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;recv_header-&gt;answerNum;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//读取解析打印一个回应部分</span></span><br><span class="line">			recv_answer = <span class="literal">NULL</span>;</span><br><span class="line">			recv_answer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">			decode_resource_record(recv_answer,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">			print_resource_record(recv_answer);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;recv_header-&gt;addNum;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//读取解析打印一个addition部分</span></span><br><span class="line">			recv_add = <span class="literal">NULL</span>;</span><br><span class="line">			recv_add = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_QUERY));</span><br><span class="line">			decode_resource_record(recv_add,recvbuf,&amp;recvBufferPointer);</span><br><span class="line">			print_resource_record(recv_add);</span><br><span class="line">		&#125;</span><br><span class="line">		recvBufferPointer=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="number">512</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	close(clientSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>多级中文域名解析系统-1（c语言）</title>
    <url>/2018/04/05/%E4%B8%AD%E6%96%87DNS%E5%AE%9E%E7%8E%B0%EF%BC%88c%E8%AF%AD%E8%A8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h2><ul>
<li><p>支持中文域名解析，支持缓存与多请求</p>
</li>
<li><p>遵循RFC1180标准，可被wireshark抓包检测到</p>
</li>
</ul>
<ul>
<li><p>本系统包含一个客户端，四个中间多级DNS，一个根DNS，一个本地DNS</p>
</li>
<li><p>难点在于①不用python而使用C语言必须写非常多的底层操作，主要集中在defAndTools库中②DNS请求的逻辑</p>
</li>
</ul>
<h2 id="Project-Structure"><a href="#Project-Structure" class="headerlink" title="Project Structure"></a>Project Structure</h2><div class="table-container">
<table>
<thead>
<tr>
<th>CODES</th>
<th>EXPLAINATION</th>
</tr>
</thead>
<tbody>
<tr>
<td>defAndTools.h</td>
<td>此包为主要工具包，涉及网络中的核心底层的操作，是主要难点之一</td>
</tr>
<tr>
<td>LOCAL_DNS.c</td>
<td>本地DNS服务器核心逻辑，是本网络中的核心部件，是主要难点之一</td>
</tr>
<tr>
<td>Client.c</td>
<td>客户端主逻辑</td>
</tr>
<tr>
<td>ROOT_DNS.c</td>
<td>根域名解析服务器的逻辑代码</td>
</tr>
<tr>
<td>DNS1.c</td>
<td>第一级域名解析服务器主逻辑</td>
</tr>
<tr>
<td>DNS2.c</td>
<td>第二级域名解析服务器主逻辑</td>
</tr>
<tr>
<td>DNS3.c</td>
<td>第三级域名解析服务器主逻辑</td>
</tr>
<tr>
<td>DNS4.c</td>
<td>第四级域名解析服务器主逻辑</td>
</tr>
<tr>
<td>localServer.h</td>
<td>本地DNS服务器的参数设置</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>FILES</th>
<th>EXPLAINATION</th>
</tr>
</thead>
<tbody>
<tr>
<td>localCache.txt</td>
<td>本地DNS服务器的缓存</td>
</tr>
<tr>
<td>RRL1.txt</td>
<td>第一级域名解析服务器的缓存</td>
</tr>
<tr>
<td>RRL2.txt</td>
<td>第二级域名解析服务器的缓存</td>
</tr>
<tr>
<td>RRL3.txt</td>
<td>第三级域名解析服务器的缓存</td>
</tr>
<tr>
<td>RRL4.txt</td>
<td>第四级域名解析服务器的缓存</td>
</tr>
<tr>
<td>RRroot.txt</td>
<td>根域名解析服务器的缓存</td>
</tr>
</tbody>
</table>
</div>
<h2 id="defAndTools"><a href="#defAndTools" class="headerlink" title="defAndTools"></a>defAndTools</h2><p><em>此包为主要工具包，涉及网络中的底层的操作</em></p>
 <a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE_OF_DOMAIN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROOT_SERVER_IP <span class="meta-string">"127.0.0.3"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于储存域名方便处理的全局变量</span></span><br><span class="line"><span class="keyword">char</span> domain_temp[MAX_SIZE_OF_DOMAIN];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> id;       <span class="comment">//16位的消息ID标示一次正常的交互，该ID由消息请求者设置，消息响应者回复请求时带上该ID。</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> tag;      <span class="comment">//tag要拆，并单独写一个生成tag函数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> queryNum; <span class="comment">//标示请求部分的条目数 </span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> answerNum;<span class="comment">//标示响应部分的资源记录数。如果响应消息中没有记录，则设置为0</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> authorNum;<span class="comment">//标示权威部分的域名服务器资源记录数。如果响应消息中没有权威记录，则设置为0</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> addNum;   <span class="comment">//标示额外部分的资源记录数。</span></span><br><span class="line">&#125;DNS_HEAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNS_Query</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *name;              <span class="comment">//请求的域名。</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> qtype;    <span class="comment">//记录的类型 [A:0x0001] [NS:0x0002] [CNAME:0x0005] [MX:0x000F]</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> qclass;   <span class="comment">//请求的资源记录的类型 一般为[IN:0x0001]</span></span><br><span class="line">&#125;DNS_QUERY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNS_RR</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *name;   </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> type;     <span class="comment">//请求的域名</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> _class;   <span class="comment">//响应的资源记录的类型 一般为[IN:0x0001]</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ttl;        <span class="comment">//该资源记录被缓存的秒数。</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> data_len; <span class="comment">//RDATA部分的长度</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> pre;      <span class="comment">//MX特有的优先级 Preference</span></span><br><span class="line">	<span class="keyword">char</span> *rdata;	         <span class="comment">//[A:32位的IP地址（4字节）] [CNAME/NS/MX:域名]</span></span><br><span class="line">&#125;DNS_ResouceRecord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> qr;       <span class="comment">//[1]标示该消息是请求消息（该位为0）还是应答消息（该位为1）</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> opcode;   <span class="comment">//[4]0  QUERY。标准查询</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> aa;       <span class="comment">//[1]只在响应消息中有效。该位标示响应该消息的域名服务器是该域中的权威域名服务器。因为Answer Section中可能会有很多域名</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> tc;       <span class="comment">//[1]标示这条消息是否因为长度超过UDP数据包的标准长度512字节，如果超过512字节，该位被设置为1</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> rd;       <span class="comment">//[1]是否递归查询。1为递归查询</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> ra;       <span class="comment">//[1]在响应消息中清除并设置。标示该DNS域名服务器是否支持递归查询。</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> z;        <span class="comment">//[3] 冗余res 0</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> rcode;    <span class="comment">//[4] 0  成功的响应</span></span><br><span class="line">&#125;TAG;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************缓冲区操作和工具***************************/</span></span><br><span class="line"><span class="comment">/*此函数用于向buffer中写入8bit数据</span></span><br><span class="line"><span class="comment"> * *buffer:指向缓冲区</span></span><br><span class="line"><span class="comment"> * *bufferPointer:目前已写入的缓冲区最新一位的下一位</span></span><br><span class="line"><span class="comment"> * 以下put16bits put32bits同理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put1Byte</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer, <span class="keyword">char</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//调整value为网络字节序</span></span><br><span class="line">	value = htons(value);</span><br><span class="line">	<span class="comment">//void *memcpy(void *dest, void *src, unsigned int count);</span></span><br><span class="line">	<span class="comment">//用于 把资源内存（src所指向的内存区域） 拷贝到目标内存（dest所指向的内存区域）,count为拷贝区域大小.</span></span><br><span class="line">	<span class="comment">//buffer为缓冲区首地址，bufferPointer为缓冲区已写入下标，此函数参数为指向这两个量的指针，通过传递地址来实现主函数与子函数的实参传递。</span></span><br><span class="line">	<span class="comment">//value为欲写入缓冲区的数据(value为8bit)</span></span><br><span class="line">	<span class="built_in">memcpy</span>(buffer + *bufferPointer,&amp;value,<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//缓冲区已写入下标向后移动，使其指向下一次写入时应该写入的位置,*bufferPointer为指针bufferPointer所指地址的内容</span></span><br><span class="line">	*bufferPointer += <span class="number">1</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put2Bytes</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer, <span class="keyword">unsigned</span> <span class="keyword">short</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	value = htons(value);</span><br><span class="line">	<span class="built_in">memcpy</span>(buffer + *bufferPointer,&amp;value,<span class="number">2</span>);</span><br><span class="line">	*bufferPointer += <span class="number">2</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put4Bytes</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	value = htons(value);</span><br><span class="line">	<span class="built_in">memcpy</span>(buffer + *bufferPointer,&amp;value,<span class="number">4</span>);</span><br><span class="line">	*bufferPointer += <span class="number">4</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将变长字符串str写入buffer  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putDomainName</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer, <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(buffer + *bufferPointer,str,<span class="built_in">strlen</span>(str)+<span class="number">1</span>); <span class="comment">//末尾0需要一起打印</span></span><br><span class="line">	*bufferPointer += <span class="built_in">strlen</span>(str)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从缓冲区取16个位</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">get2Bytes</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> value;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;value,buffer + *bufferPointer,<span class="number">2</span>);</span><br><span class="line">	*bufferPointer += <span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ntohs(value);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get4bits</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> value;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;value,buffer + *bufferPointer,<span class="number">4</span>);</span><br><span class="line">	*bufferPointer += <span class="number">4</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ntohs(value);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取变长字符串str 读取到0即停止 0即为'\0' </span></span><br><span class="line"><span class="comment">//域名不考虑字节序问题 ，也不用考虑编码问题，都是一个字节一个字节读</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDomainName</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer,<span class="keyword">int</span> *lengthOfDomain)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> valueWriting=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(buffer[*bufferPointer]!=<span class="number">0</span>)  </span><br><span class="line">	&#123;        </span><br><span class="line">		domain_temp[valueWriting] = buffer[*bufferPointer]; </span><br><span class="line">		valueWriting++;</span><br><span class="line">		(*bufferPointer)++;</span><br><span class="line">	&#125;</span><br><span class="line">	domain_temp[valueWriting] = <span class="number">0</span>; <span class="comment">//末尾为0，写入字符串结束符，方便对字符数组进行字符串操作</span></span><br><span class="line">	(*bufferPointer)++; <span class="comment">//缓冲区读写下一位指针指示跳过末尾0</span></span><br><span class="line">	*lengthOfDomain = valueWriting+<span class="number">1</span>; <span class="comment">//包含了末尾结束符 </span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//eg 3www6google3com0   </span></span><br><span class="line"><span class="comment">//生成域名编码</span></span><br><span class="line"><span class="comment">//一个UTF8 数字占1个字节。一个UTF8汉字占3个字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode_domain</span><span class="params">(<span class="keyword">char</span>* domain)</span>           </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(domain_temp,<span class="number">0</span>,MAX_SIZE_OF_DOMAIN);   </span><br><span class="line">	<span class="keyword">int</span> valueWriting=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> *p,*q;</span><br><span class="line">	q = domain;</span><br><span class="line">	p = q;</span><br><span class="line">	<span class="keyword">char</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)   </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((*p==<span class="string">'.'</span>)||(*p==<span class="number">0</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//第一位为count,写入字符串  </span></span><br><span class="line">			*(domain_temp+valueWriting)=count;  <span class="comment">//此处最后一位0的情况写入了 </span></span><br><span class="line">			valueWriting += <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//写入q开始，长度为count的字符串（长度为count)</span></span><br><span class="line">			<span class="built_in">memcpy</span>(domain_temp+valueWriting,q,count);</span><br><span class="line">			valueWriting += count; </span><br><span class="line">			</span><br><span class="line">			<span class="comment">//计数清0</span></span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//如果未读到字符串末尾，将q移动到p+1的位置，重新开始下一轮</span></span><br><span class="line">			<span class="keyword">if</span> (*p==<span class="string">'.'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				q=p+<span class="number">1</span>;</span><br><span class="line">				p = q;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p++;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析编码的域名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode_domain</span><span class="params">(<span class="keyword">char</span>* domain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(domain_temp,<span class="number">0</span>,MAX_SIZE_OF_DOMAIN);</span><br><span class="line">	<span class="keyword">int</span> valueWriting = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> *p = domain;  </span><br><span class="line">	<span class="keyword">int</span> count = *p;</span><br><span class="line">	<span class="keyword">while</span>(count!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			p += <span class="number">1</span>;</span><br><span class="line">			domain_temp[valueWriting] = *p;</span><br><span class="line">			valueWriting++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (*(p+<span class="number">1</span>)!=<span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			domain_temp[valueWriting] = <span class="string">'.'</span>;</span><br><span class="line">			valueWriting++;</span><br><span class="line">		&#125;</span><br><span class="line">		p += <span class="number">1</span>;</span><br><span class="line">		count = *p;</span><br><span class="line">	&#125;</span><br><span class="line">	domain_temp[valueWriting]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OPCODE、Z、RCODE不用管，无论输入什么都为0。其他都是单位的</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">create_tag</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> qr,<span class="keyword">unsigned</span> <span class="keyword">short</span> opcode,<span class="keyword">unsigned</span> <span class="keyword">short</span> aa,<span class="keyword">unsigned</span> <span class="keyword">short</span> tc,<span class="keyword">unsigned</span> <span class="keyword">short</span> rd,<span class="keyword">unsigned</span> <span class="keyword">short</span> ra,<span class="keyword">unsigned</span> <span class="keyword">short</span> z,<span class="keyword">unsigned</span> <span class="keyword">short</span> rcode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> tag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (qr==<span class="number">1</span>)  tag = tag | <span class="number">0x8000</span>;</span><br><span class="line">	<span class="keyword">if</span> (aa==<span class="number">1</span>)  tag = tag | <span class="number">0x0400</span>;</span><br><span class="line">	<span class="keyword">if</span> (tc==<span class="number">1</span>)  tag = tag | <span class="number">0x0200</span>;</span><br><span class="line">	<span class="keyword">if</span> (rd==<span class="number">1</span>)  tag = tag | <span class="number">0x0100</span>;</span><br><span class="line">	<span class="keyword">if</span> (ra==<span class="number">1</span>)  tag = tag | <span class="number">0x0080</span>;</span><br><span class="line">	<span class="keyword">return</span> tag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型的名字与编码的转换</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">strTypeToCode</span><span class="params">(<span class="keyword">char</span>* type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(type,<span class="string">"A"</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0x0001</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(type,<span class="string">"NS"</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0x0002</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(type,<span class="string">"CNAME"</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0x0005</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(type,<span class="string">"MX"</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0x000F</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">codeTypeToStr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num==<span class="number">0x0001</span>) <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">	<span class="keyword">if</span> (num==<span class="number">0x0002</span>) <span class="keyword">return</span> <span class="string">"NS"</span>;</span><br><span class="line">	<span class="keyword">if</span> (num==<span class="number">0x0005</span>) <span class="keyword">return</span> <span class="string">"CNAME"</span>;</span><br><span class="line">	<span class="keyword">if</span> (num==<span class="number">0x000F</span>) <span class="keyword">return</span> <span class="string">"MX"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************DNS头部操作***************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *此函数用于填充客户端发送请求的dns包的头部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_query_header</span><span class="params">(struct DNS_Header *query_header,<span class="keyword">unsigned</span> <span class="keyword">short</span> id,<span class="keyword">unsigned</span> <span class="keyword">short</span> tag,<span class="keyword">unsigned</span> <span class="keyword">short</span> queryNum,<span class="keyword">unsigned</span> <span class="keyword">short</span> answerNum,<span class="keyword">unsigned</span> <span class="keyword">short</span> authorNum,<span class="keyword">unsigned</span> <span class="keyword">short</span> addNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	query_header-&gt;id = id;</span><br><span class="line">	query_header-&gt;tag = tag;</span><br><span class="line">	query_header-&gt;queryNum = queryNum;</span><br><span class="line">	query_header-&gt;answerNum = answerNum;</span><br><span class="line">	query_header-&gt;authorNum = authorNum;</span><br><span class="line">	query_header-&gt;addNum = addNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*此函数用于将已经填充好的dns头部结构体的成员依次写入buffer</span></span><br><span class="line"><span class="comment"> *  *header: 指向已填充好的dns头部结构体的指针</span></span><br><span class="line"><span class="comment"> *  *buffer: 指向缓冲区</span></span><br><span class="line"><span class="comment"> *  *bufferPointer: 目前已写入的缓冲区最新一位的下一位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode_header</span><span class="params">(struct DNS_Header *header,<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	put2Bytes(buffer,bufferPointer,header-&gt;id);</span><br><span class="line">	put2Bytes(buffer,bufferPointer,header-&gt;tag);</span><br><span class="line">	put2Bytes(buffer,bufferPointer,header-&gt;queryNum);</span><br><span class="line">	put2Bytes(buffer,bufferPointer,header-&gt;answerNum);</span><br><span class="line">	put2Bytes(buffer,bufferPointer,header-&gt;authorNum);</span><br><span class="line">	put2Bytes(buffer,bufferPointer,header-&gt;addNum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode_header</span><span class="params">(struct DNS_Header *header,<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	header-&gt;id=get2Bytes(buffer,bufferPointer);</span><br><span class="line">	header-&gt;tag=get2Bytes(buffer,bufferPointer);</span><br><span class="line">	header-&gt;queryNum=get2Bytes(buffer,bufferPointer);</span><br><span class="line">	header-&gt;answerNum=get2Bytes(buffer,bufferPointer);</span><br><span class="line">	header-&gt;authorNum=get2Bytes(buffer,bufferPointer);</span><br><span class="line">	header-&gt;addNum=get2Bytes(buffer,bufferPointer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_header</span><span class="params">(struct DNS_Header *query_header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[DNS HEADER]\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ID         :         %d\n"</span>,query_header-&gt;id);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"TAG        :         0x%x\n"</span>,query_header-&gt;tag);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"QueryNum   :         %d\n"</span>,query_header-&gt;queryNum);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"AnswerNum  :         %d\n"</span>,query_header-&gt;answerNum);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"AuthorNum  :         %d\n"</span>,query_header-&gt;authorNum);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"AddNum     :         %d\n"</span>,query_header-&gt;addNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************DNS请求部分操作***************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *生成DNS包的请求部分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_query_section</span><span class="params">(struct DNS_Query *query_section,<span class="keyword">char</span>* domain_name, <span class="keyword">unsigned</span> <span class="keyword">short</span> qtype, <span class="keyword">unsigned</span> <span class="keyword">short</span> qclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> domain_length = <span class="built_in">strlen</span>(domain_name);</span><br><span class="line">	query_section-&gt;name = <span class="built_in">malloc</span>(domain_length+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(query_section-&gt;name,domain_name,domain_length+<span class="number">1</span>);	</span><br><span class="line">	</span><br><span class="line">	query_section-&gt;qtype = qtype;</span><br><span class="line">	query_section-&gt;qclass = qclass;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *将已经填充好的dns的一个请求结构体的成员依次写入buffer(调用一次该函数只写入一个请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode_query_section</span><span class="params">(struct DNS_Query *query_section,<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//先计算用decodeDomain得到字符串</span></span><br><span class="line">	<span class="comment">//再用strlen计算字符串长度为点语法name长度+2（头尾多了一个数字）</span></span><br><span class="line">	<span class="comment">//再发送 </span></span><br><span class="line">	<span class="keyword">char</span> *domain_name;</span><br><span class="line">	<span class="keyword">int</span> lengthOfEncodedDomain = <span class="built_in">strlen</span>(query_section-&gt;name)+<span class="number">2</span>;</span><br><span class="line">	domain_name = <span class="built_in">malloc</span>(lengthOfEncodedDomain);</span><br><span class="line">	encode_domain(query_section-&gt;name);</span><br><span class="line">	<span class="built_in">memcpy</span>(domain_name,domain_temp,lengthOfEncodedDomain);</span><br><span class="line">	putDomainName(buffer,bufferPointer,domain_name); </span><br><span class="line">	</span><br><span class="line">	put2Bytes(buffer,bufferPointer,query_section-&gt;qtype);</span><br><span class="line">	put2Bytes(buffer,bufferPointer,query_section-&gt;qclass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *解析请求部分。解析即为将缓冲区的字节流提取，转码，生成对应的结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode_query_section</span><span class="params">(struct DNS_Query *query_section,<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//从缓冲区读出编码过的域名</span></span><br><span class="line">	<span class="keyword">char</span>* domain_name = <span class="built_in">malloc</span>(MAX_SIZE_OF_DOMAIN); </span><br><span class="line">	<span class="built_in">memset</span>(domain_name,<span class="number">0</span>,MAX_SIZE_OF_DOMAIN);</span><br><span class="line">	<span class="keyword">int</span> lengthOfDomain=<span class="number">0</span>;</span><br><span class="line">	getDomainName(buffer,bufferPointer,&amp;lengthOfDomain);</span><br><span class="line">	<span class="built_in">memcpy</span>(domain_name,domain_temp,lengthOfDomain);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//解码域名</span></span><br><span class="line">	decode_domain(domain_name);</span><br><span class="line">	<span class="built_in">memcpy</span>(domain_name,domain_temp,<span class="built_in">strlen</span>(domain_name));  </span><br><span class="line">	</span><br><span class="line">	query_section-&gt;name = domain_name;</span><br><span class="line">	query_section-&gt;qtype = get2Bytes(buffer,bufferPointer);</span><br><span class="line">	query_section-&gt;qclass = get2Bytes(buffer,bufferPointer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_query_section</span><span class="params">(struct DNS_Query *query_section)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[DNS QUERY]\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name       :         %s\n"</span>,query_section-&gt;name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Type       :         %s\n"</span>,codeTypeToStr(query_section-&gt;qtype));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Class      :         IN\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************DNS RR操作和RR文件解析操作***************************/</span></span><br><span class="line"><span class="comment">//生成resource record记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_resource_record</span><span class="params">(struct DNS_RR *resource_record,<span class="keyword">char</span>* name, <span class="keyword">unsigned</span> <span class="keyword">short</span> type, <span class="keyword">unsigned</span> <span class="keyword">short</span> _class, <span class="keyword">unsigned</span> <span class="keyword">int</span> ttl, <span class="keyword">unsigned</span> <span class="keyword">short</span> pre,<span class="keyword">char</span> *rdata)</span> <span class="comment">//data_len不用输入  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//unsigned short pre为一个MX类型特有的优先级，定长，只有MX类型发送。</span></span><br><span class="line">	<span class="keyword">int</span> domain_length = <span class="built_in">strlen</span>(name);</span><br><span class="line">	<span class="comment">//易错点：strlen只读到0但不包含0，所以为了把结束符也复制进去，长度要+1</span></span><br><span class="line">	resource_record-&gt;name = <span class="built_in">malloc</span>(domain_length+<span class="number">1</span>);   </span><br><span class="line">	<span class="built_in">memcpy</span>(resource_record-&gt;name,name,domain_length+<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	resource_record-&gt;type = type;</span><br><span class="line">	resource_record-&gt;_class = _class;</span><br><span class="line">	resource_record-&gt;ttl = ttl;       <span class="comment">//data_len</span></span><br><span class="line">	<span class="keyword">if</span> (type==<span class="number">0x0001</span>) resource_record-&gt;data_len=<span class="number">4</span>;  <span class="comment">//对于IP，长度为4 data_len是编码后的长度，length是非编码长度，注意</span></span><br><span class="line">		<span class="keyword">else</span> resource_record-&gt;data_len = <span class="built_in">strlen</span>(rdata) + <span class="number">2</span>;      <span class="comment">//对于域名，生成data_len包含末尾结束符（域名末尾结束符）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//pre</span></span><br><span class="line">	<span class="keyword">if</span> (type==<span class="number">0x000F</span>) &#123;</span><br><span class="line">		resource_record-&gt;pre = pre;</span><br><span class="line">		resource_record-&gt;data_len += <span class="number">2</span>;  <span class="comment">//对于邮件类型，由于有pre的存在，多占两个字节</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//char* rdata</span></span><br><span class="line">	<span class="keyword">int</span> rdata_length = <span class="built_in">strlen</span>(rdata);  <span class="comment">//要加上末尾结束符</span></span><br><span class="line">	resource_record-&gt;rdata = <span class="built_in">malloc</span>(rdata_length+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(resource_record-&gt;rdata,rdata,rdata_length+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编码resource record记录，编码即为将结构体的内容编码，处理为字节流，写入缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode_resource_record</span><span class="params">(struct DNS_RR *resource_record,<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *domain_name;</span><br><span class="line">	<span class="keyword">int</span> lengthOfEncodedDomain = <span class="built_in">strlen</span>(resource_record-&gt;name)+<span class="number">2</span>;</span><br><span class="line">	domain_name = <span class="built_in">malloc</span>(lengthOfEncodedDomain);</span><br><span class="line">	 </span><br><span class="line">	encode_domain(resource_record-&gt;name);</span><br><span class="line">	<span class="built_in">memcpy</span>(domain_name,domain_temp,lengthOfEncodedDomain);</span><br><span class="line">	</span><br><span class="line">	putDomainName(buffer,bufferPointer,domain_name); </span><br><span class="line">	</span><br><span class="line">	put2Bytes(buffer,bufferPointer,resource_record-&gt;type);</span><br><span class="line">	put2Bytes(buffer,bufferPointer,resource_record-&gt;_class);</span><br><span class="line">	put4Bytes(buffer,bufferPointer,resource_record-&gt;ttl);</span><br><span class="line">	put2Bytes(buffer,bufferPointer,resource_record-&gt;data_len);   </span><br><span class="line">	<span class="keyword">if</span> (resource_record-&gt;type==<span class="number">0x000F</span>) </span><br><span class="line">		put2Bytes(buffer,bufferPointer,resource_record-&gt;pre);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//如果类型为A，发送的是IP，将IP写入缓冲区               </span></span><br><span class="line">	<span class="keyword">if</span>(resource_record-&gt;type == <span class="number">0x0001</span>)         </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//不能调用get put函数，因为inet_addr自带字节序变换功能</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> rdata = inet_addr(resource_record-&gt;rdata);</span><br><span class="line">		<span class="built_in">memcpy</span>(buffer + *bufferPointer,&amp;rdata,<span class="number">4</span>);</span><br><span class="line">		*bufferPointer += <span class="number">4</span>;</span><br><span class="line">	</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;          </span><br><span class="line">	<span class="comment">//如果类型为MX、CNAME、NS</span></span><br><span class="line">	<span class="comment">//则发送的是域名，则调用域名编码</span></span><br><span class="line">		<span class="keyword">char</span> *rdata;</span><br><span class="line">		<span class="keyword">int</span> lengthOfEncodedDomain2 = <span class="built_in">strlen</span>(resource_record-&gt;rdata)+<span class="number">2</span>;</span><br><span class="line">		rdata = <span class="built_in">malloc</span>(lengthOfEncodedDomain2);</span><br><span class="line">		encode_domain(resource_record-&gt;rdata);</span><br><span class="line">		<span class="built_in">memcpy</span>(rdata,domain_temp,lengthOfEncodedDomain2);   </span><br><span class="line">		putDomainName(buffer,bufferPointer,rdata); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析resource record记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode_resource_record</span><span class="params">(struct DNS_RR *resource_record,<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//从缓冲区读出编码过的域名</span></span><br><span class="line">	<span class="keyword">char</span>* domain_name = <span class="built_in">malloc</span>(MAX_SIZE_OF_DOMAIN); </span><br><span class="line">	<span class="built_in">memset</span>(domain_name,<span class="number">0</span>,MAX_SIZE_OF_DOMAIN);</span><br><span class="line">	<span class="keyword">int</span> lengthOfDomain=<span class="number">0</span>;</span><br><span class="line">	getDomainName(buffer,bufferPointer,&amp;lengthOfDomain);</span><br><span class="line">	<span class="built_in">memcpy</span>(domain_name,domain_temp,lengthOfDomain);</span><br><span class="line">	<span class="comment">//解码域名</span></span><br><span class="line">	</span><br><span class="line">	decode_domain(domain_name);</span><br><span class="line">	<span class="built_in">memcpy</span>(domain_name,domain_temp,<span class="built_in">strlen</span>(domain_name));  </span><br><span class="line">	resource_record-&gt;name = domain_name;</span><br><span class="line">	</span><br><span class="line">	resource_record-&gt;type = get2Bytes(buffer,bufferPointer);</span><br><span class="line">	resource_record-&gt;_class = get2Bytes(buffer,bufferPointer);</span><br><span class="line">	resource_record-&gt;ttl = get4bits(buffer,bufferPointer);   </span><br><span class="line">	resource_record-&gt;data_len = get2Bytes(buffer,bufferPointer);</span><br><span class="line">	<span class="keyword">if</span> (resource_record-&gt;type==<span class="number">0x000F</span>) </span><br><span class="line">			resource_record-&gt;pre = get2Bytes(buffer,bufferPointer);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果发送的是IP（类型为A），则读出IP 。 不能采用get put方法，因为inet_ntoa方法已经更换字节序</span></span><br><span class="line">	<span class="keyword">if</span>(resource_record-&gt;type == <span class="number">0x0001</span>)   </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> rdata;</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;rdata,buffer + *bufferPointer,<span class="number">4</span>);</span><br><span class="line">		*bufferPointer += <span class="number">4</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">in</span>;</span></span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;in, &amp;rdata, <span class="number">4</span>);  </span><br><span class="line">		</span><br><span class="line">		resource_record-&gt;rdata = <span class="built_in">malloc</span>(MAX_SIZE_OF_DOMAIN);</span><br><span class="line">		<span class="keyword">char</span> *temp =  inet_ntoa(in);</span><br><span class="line">		<span class="built_in">memcpy</span>(resource_record-&gt;rdata,temp,<span class="built_in">strlen</span>(temp)+<span class="number">1</span>);   <span class="comment">//+1是为了包含末尾0    </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//如果发送的是域名，则调用域名解码（类型为CNAME NS MX）</span></span><br><span class="line">		<span class="comment">//从缓冲区读出编码过的域名</span></span><br><span class="line">		<span class="keyword">char</span>* rdata = <span class="built_in">malloc</span>(MAX_SIZE_OF_DOMAIN); </span><br><span class="line">		<span class="keyword">int</span> lengthOfDomain2=<span class="number">0</span>;</span><br><span class="line">		getDomainName(buffer,bufferPointer,&amp;lengthOfDomain2);</span><br><span class="line">		<span class="built_in">memcpy</span>(rdata,domain_temp,lengthOfDomain2);</span><br><span class="line">		<span class="comment">//解码域名</span></span><br><span class="line">		decode_domain(rdata);</span><br><span class="line">		<span class="built_in">memcpy</span>(rdata,domain_temp,<span class="built_in">strlen</span>(rdata));  </span><br><span class="line">		resource_record-&gt;rdata = rdata;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_resource_record</span><span class="params">(struct DNS_RR *resource_record)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[RESOURCE RECORD]\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name       :         %s\n"</span>,resource_record-&gt;name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Type       :         %s\n"</span>,codeTypeToStr(resource_record-&gt;type));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Class      :         IN\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"TTL        :         %d\n"</span>,resource_record-&gt;ttl);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Data_Len   :         %d\n"</span>,resource_record-&gt;data_len);</span><br><span class="line">	<span class="keyword">if</span> (resource_record-&gt;type==<span class="number">0x000F</span>) </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Preference :         %d\n"</span>,resource_record-&gt;pre);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"IP|DOMAIN  :         %s\n"</span>,resource_record-&gt;rdata);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"===================================\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//砍掉一个域名第一个.之前的部分,如果已经是最后一节，指向域名的指针指向NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">char</span>** domainPointer)</span>  <span class="comment">//这里传入的是 指向指向域名的指针的指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		(*domainPointer)++;</span><br><span class="line">		<span class="keyword">if</span> (**domainPointer==<span class="string">'.'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			(*domainPointer)++;</span><br><span class="line">			<span class="keyword">break</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (**domainPointer==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*domainPointer = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************文件读写***************************/</span></span><br><span class="line"><span class="comment">//将RR写进cache文件里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addRRToCache</span><span class="params">(struct DNS_RR *resource_record, <span class="keyword">char</span>* cacheFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *RR = fopen(cacheFile, <span class="string">"a+"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(RR,<span class="string">"%s         "</span>,resource_record-&gt;name);</span><br><span class="line">	<span class="built_in">fprintf</span>(RR,<span class="string">"%d         "</span>,resource_record-&gt;ttl);</span><br><span class="line">	<span class="built_in">fprintf</span>(RR,<span class="string">"IN         "</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(RR,<span class="string">"%s         "</span>,codeTypeToStr(resource_record-&gt;type));</span><br><span class="line">	<span class="built_in">fprintf</span>(RR,<span class="string">"%s\n"</span>,resource_record-&gt;rdata);</span><br><span class="line">	fclose(RR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次在RR文件里扫描 （初次搜索函数）</span></span><br><span class="line"><span class="comment">//如果找到了，返回1，且encode进buffer</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstFindRR</span><span class="params">(struct DNS_Query *query_section,<span class="keyword">char</span> *RRDOCUMENT,<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> over = <span class="number">0</span>;</span><br><span class="line">	FILE *RR = fopen( RRDOCUMENT, <span class="string">"r"</span> );</span><br><span class="line">	<span class="comment">//定义一个RR结构体用来储存从文件中读入的一条RR</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DNS_RR</span> *<span class="title">fileRR</span>;</span></span><br><span class="line">	fileRR = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">	<span class="built_in">memset</span>(fileRR,<span class="number">0</span>,<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">	fileRR-&gt;name=<span class="built_in">malloc</span>(MAX_SIZE_OF_DOMAIN);  </span><br><span class="line">	fileRR-&gt;rdata=<span class="built_in">malloc</span>(MAX_SIZE_OF_DOMAIN);</span><br><span class="line">	<span class="comment">//第一次搜索</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">fscanf</span>(RR,<span class="string">"%s "</span>,fileRR-&gt;name)!=EOF)   </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fscanf</span>(RR,<span class="string">"%d"</span>,&amp;fileRR-&gt;ttl);</span><br><span class="line">		<span class="keyword">char</span> type[<span class="number">10</span>],_class[<span class="number">10</span>];</span><br><span class="line">		<span class="built_in">fscanf</span>(RR,<span class="string">"%s "</span>,_class);</span><br><span class="line">		<span class="built_in">fscanf</span>(RR,<span class="string">"%s "</span>,type);</span><br><span class="line">		fileRR-&gt;type = strTypeToCode(type);</span><br><span class="line">		<span class="built_in">fscanf</span>(RR,<span class="string">"%s\n"</span>,fileRR-&gt;rdata);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>((<span class="built_in">strcmp</span>(query_section-&gt;name,fileRR-&gt;name)==<span class="number">0</span>) &amp;&amp; (query_section-&gt;qtype==fileRR-&gt;type))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n发送回复：\n"</span>);</span><br><span class="line">			<span class="comment">//生成answer RR</span></span><br><span class="line">			create_resource_record(fileRR,fileRR-&gt;name, fileRR-&gt;type, <span class="number">0x0001</span>, fileRR-&gt;ttl, <span class="number">0x0000</span>,fileRR-&gt;rdata);</span><br><span class="line">			<span class="comment">//生成头</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">header</span>;</span></span><br><span class="line">			header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">short</span> tag = create_tag(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(type,<span class="string">"MX"</span>)==<span class="number">0</span>)   create_query_header(header,<span class="number">0x1235</span>,tag,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">else</span> create_query_header(header,<span class="number">999</span>,tag,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//将头和answer encode进buffer</span></span><br><span class="line">			encode_header(header,buffer,bufferPointer);</span><br><span class="line">			print_header(header);</span><br><span class="line">			encode_resource_record(fileRR,buffer,bufferPointer);</span><br><span class="line">			print_resource_record(fileRR);</span><br><span class="line">			over=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//读指针回到开头</span></span><br><span class="line">	fseek(RR,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//对于MX类型，特殊，需要再搜索一遍，搜索到的邮件服务器域名的IP，并写入addition RR中发送    </span></span><br><span class="line">	<span class="keyword">if</span> ((fileRR-&gt;type==<span class="number">0x000F</span>)&amp;&amp;(over==<span class="number">1</span>)) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_RR</span> *<span class="title">addFileRR</span>;</span></span><br><span class="line">		addFileRR = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">		addFileRR-&gt;name=<span class="built_in">malloc</span>(MAX_SIZE_OF_DOMAIN);</span><br><span class="line">		addFileRR-&gt;rdata=<span class="built_in">malloc</span>(MAX_SIZE_OF_DOMAIN);</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">fscanf</span>(RR,<span class="string">"%s "</span>,addFileRR-&gt;name)!=EOF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fscanf</span>(RR,<span class="string">"%d "</span>,&amp;addFileRR-&gt;ttl);</span><br><span class="line">			<span class="keyword">char</span> type[<span class="number">10</span>],_class[<span class="number">10</span>];</span><br><span class="line">			<span class="built_in">fscanf</span>(RR,<span class="string">"%s "</span>,_class);</span><br><span class="line">			<span class="built_in">fscanf</span>(RR,<span class="string">"%s "</span>,type);</span><br><span class="line">			addFileRR-&gt;type = strTypeToCode(type);</span><br><span class="line">			<span class="built_in">fscanf</span>(RR,<span class="string">"%s\n"</span>,addFileRR-&gt;rdata);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(fileRR-&gt;rdata,addFileRR-&gt;name)==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"邮件服务器：\n"</span>);</span><br><span class="line">				<span class="comment">//生成addition RR</span></span><br><span class="line">				create_resource_record(addFileRR,fileRR-&gt;rdata, <span class="number">1</span>, <span class="number">1</span>, fileRR-&gt;ttl, <span class="number">0</span>, addFileRR-&gt;rdata);</span><br><span class="line">				encode_resource_record(addFileRR,buffer,bufferPointer);</span><br><span class="line">				print_resource_record(addFileRR);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(RR);</span><br><span class="line">	<span class="keyword">return</span> over;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loopFindNS</span><span class="params">(struct DNS_Query *query_section,<span class="keyword">char</span> *RRDOCUMENT,<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *bufferPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *RR = fopen( RRDOCUMENT, <span class="string">"r"</span> );</span><br><span class="line">	cut(&amp;query_section-&gt;name);</span><br><span class="line">	<span class="comment">//剪掉首段地址，进行第二次搜索</span></span><br><span class="line">	<span class="keyword">while</span>(query_section-&gt;name!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fseek(RR,<span class="number">0</span>,<span class="number">0</span>);  </span><br><span class="line">		</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">DNS_RR</span> *<span class="title">nextRR</span>;</span></span><br><span class="line">		nextRR = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">		nextRR-&gt;name=<span class="built_in">malloc</span>(MAX_SIZE_OF_DOMAIN);</span><br><span class="line">		nextRR-&gt;rdata=<span class="built_in">malloc</span>(MAX_SIZE_OF_DOMAIN);</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">fscanf</span>(RR,<span class="string">"%s "</span>,nextRR-&gt;name)!=EOF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fscanf</span>(RR,<span class="string">"%d "</span>,&amp;nextRR-&gt;ttl);</span><br><span class="line">			<span class="keyword">char</span> type[<span class="number">10</span>],_class[<span class="number">10</span>];</span><br><span class="line">			<span class="built_in">fscanf</span>(RR,<span class="string">"%s "</span>,_class);</span><br><span class="line">			<span class="built_in">fscanf</span>(RR,<span class="string">"%s "</span>,type);</span><br><span class="line">			nextRR-&gt;type = strTypeToCode(type);</span><br><span class="line">			<span class="built_in">fscanf</span>(RR,<span class="string">"%s\n"</span>,nextRR-&gt;rdata);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(query_section-&gt;name,nextRR-&gt;name)==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\n下一级服务器信息：\n"</span>);</span><br><span class="line">				<span class="comment">//生成头</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">DNS_Header</span> *<span class="title">header</span>;</span></span><br><span class="line">				header = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_HEAD));</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">short</span> tag = create_tag(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">				create_query_header(header,<span class="number">999</span>,tag,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">				encode_header(header,buffer,bufferPointer);</span><br><span class="line">				print_header(header);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//生成authority RR  NS记录type=2   此时query_section-&gt;name经过cut后已经变成了下一个要去的DNS服务器域名</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">DNS_RR</span> *<span class="title">authRR</span>;</span></span><br><span class="line">				authRR = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">				create_resource_record(authRR, query_section-&gt;name, <span class="number">2</span>, <span class="number">1</span>, nextRR-&gt;ttl, <span class="number">0</span>, query_section-&gt;name);</span><br><span class="line">				encode_resource_record(authRR,buffer,bufferPointer);</span><br><span class="line">				print_resource_record(authRR);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//生成additon RR   A记录type=1</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">DNS_RR</span> *<span class="title">addRR</span>;</span></span><br><span class="line">				addRR = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNS_ResouceRecord));</span><br><span class="line">				create_resource_record(addRR, query_section-&gt;name, <span class="number">1</span>, <span class="number">1</span>, nextRR-&gt;ttl, <span class="number">0</span>, nextRR-&gt;rdata);</span><br><span class="line">				encode_resource_record(addRR,buffer,bufferPointer);</span><br><span class="line">				print_resource_record(addRR);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		cut(&amp;query_section-&gt;name);	</span><br><span class="line">	&#125;</span><br><span class="line">	out:</span><br><span class="line">	fclose(RR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>2018</title>
    <url>/2018/01/01/2018/</url>
    <content><![CDATA[<p>呼，又一年过去了。 愿望实现了吗？努力了吗？坚持希望了吗？有未来吗？</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>递归算法设计</title>
    <url>/2017/10/19/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>一、递归算法设计</p>
<p>设计一个递归算法，先要搞清楚最基本的模型</p>
<p>先考虑最小模型（最基本模型）应该如何操作</p>
<p>写出基本模型和递推式之后，再确定参数传递</p>
<p>其中注意抓住（单或多）入口与（单或多）出口</p>
<p>进入入口之后就不要管其中间过程，将他们视为整体，转而去出口语句处，思考对最小单元执行什么内容，判断是否出栈。</p>
 <a id="more"></a>
<p>（即只管整体（入栈）与最小单元（出栈口判断与操作））</p>
<p>（这时候结合二叉树递归遍历就很好理解。</p>
<p>对于栈底，先遍历左子树，然后第二条语句执行时，第一条语句遍历左子树已经执行结束，也就是说对于栈底层来说，左子树已经完全遍历结束</p>
<p>这对于每一个中间节点都是成立的，我们只需要考虑当层，不用管中间过程，这个中间过程就是递归，我们在设计最小单元、入口出口的时候就已经设计好了）</p>
<p>二、递归大体等效为两种</p>
<p>一种等效于正向循环（直到不满足前一直执行），另一种回溯（直到满足条件再反向执行）</p>
<p>这取决于执行体相对于递归语句的位置</p>
<p>递归思想在树与图中应用广泛，可以说是重要爆了</p>
<p>设计算法要充分发掘隐含实际情况的隐含特性</p>
<p>TBC.</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>验收</title>
    <url>/2017/05/15/%E9%AA%8C%E6%94%B6/</url>
    <content><![CDATA[<p>问老师验收中</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>Know more ,know less</title>
    <url>/2017/04/20/know-more-know-less/</url>
    <content><![CDATA[<p>知道越多，知道越少</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>がんばれ！</title>
    <url>/2016/11/09/%E3%81%8C%E3%82%93%E3%81%B0%E3%82%8C%EF%BC%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>CO-原码、反码、补码</title>
    <url>/2016/10/18/CO-%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<p>转载自<a href="http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html</a></p>
<h1 id="原码-反码-补码-详解"><a href="#原码-反码-补码-详解" class="headerlink" title="原码, 反码, 补码 详解"></a><a href="http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">原码, 反码, 补码 详解</a></h1><p>本篇文章讲解了计算机的原码, 反码和补码. 并且进行了深入探求了为何要使用反码和补码, 以及更进一步的论证了为何可以用反码, 补码的加法计算原码的减法. 论证部分如有不对的地方请各位牛人帮忙指正! 希望本文对大家学习计算机基础有所帮助!  </p>
<h2 id="一-机器数和真值"><a href="#一-机器数和真值" class="headerlink" title="一. 机器数和真值"></a>一. 机器数和真值</h2><p>在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.</p>
 <a id="more"></a>
<h3 id="1、机器数"><a href="#1、机器数" class="headerlink" title="1、机器数"></a>1、机器数</h3><p>一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1. 比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。 那么，这里的 00000011 和 10000011 就是机器数。</p>
<h3 id="2、真值"><a href="#2、真值" class="headerlink" title="2、真值"></a>2、真值</h3><blockquote>
<p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p>
</blockquote>
<p>例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1  </p>
<h2 id="二-原码-反码-补码的基础概念和计算方法"><a href="#二-原码-反码-补码的基础概念和计算方法" class="headerlink" title="二. 原码, 反码, 补码的基础概念和计算方法."></a>二. 原码, 反码, 补码的基础概念和计算方法.</h2><p>在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.</p>
<h3 id="1-原码"><a href="#1-原码" class="headerlink" title="1. 原码"></a>1. 原码</h3><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<blockquote>
<p>[+1]原 = 0000 0001 [-1]原 = 1000 0001</p>
</blockquote>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<blockquote>
<p>[1111 1111 , 0111 1111]</p>
</blockquote>
<p>即</p>
<blockquote>
<p>[-127 , 127]</p>
</blockquote>
<p>原码是人脑最容易理解和计算的表示方式.</p>
<h3 id="2-反码"><a href="#2-反码" class="headerlink" title="2. 反码"></a>2. 反码</h3><p>反码的表示方法是: 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 [-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>
<h3 id="3-补码"><a href="#3-补码" class="headerlink" title="3. 补码"></a>3. 补码</h3><p>补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补 [-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.  </p>
<h2 id="三-为何要使用原码-反码和补码"><a href="#三-为何要使用原码-反码和补码" class="headerlink" title="三. 为何要使用原码, 反码和补码"></a>三. 为何要使用原码, 反码和补码</h2><p>在开始深入学习前, 我的学习建议是先”死记硬背”上面的原码, 反码和补码的表示方式以及计算方法. 现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
</blockquote>
<p>所以不需要过多解释. 但是对于负数:</p>
<blockquote>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢? 首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了. 于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码: 计算十进制的表达式: 1-1=0</p>
<blockquote>
<p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>
</blockquote>
<p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数. 为了解决原码做减法的问题, 出现了反码: 计算十进制的表达式: 1-1=0</p>
<blockquote>
<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p>
</blockquote>
<p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0. 于是补码的出现, 解决了0的符号以及两个编码的问题:</p>
<blockquote>
<p>1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p>
</blockquote>
<p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p>
<blockquote>
<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>
</blockquote>
<p>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的) 使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]. 因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.  </p>
<h2 id="四-原码-反码-补码-再深入"><a href="#四-原码-反码-补码-再深入" class="headerlink" title="四 原码, 反码, 补码 再深入"></a>四 原码, 反码, 补码 再深入</h2><p>计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢? 将钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢?我们可以:</p>
<blockquote>
<p>1. 往回拨2个小时: 6 - 2 = 4 2. 往前拨10个小时: (6 + 10) mod 12 = 4 3. 往前拨10+12=22个小时: (6+22) mod 12 =4</p>
</blockquote>
<p>2,3方法中的mod是指取模操作, 16 mod 12 =4 即用16除以12后的余数是4. 所以钟表往回拨(减法)的结果可以用往前拨(加法)替代! 现在的焦点就落在了如何用一个正数, 来替代一个负数. 上面的例子我们能感觉出来一些端倪, 发现一些规律. 但是数学是严谨的. 不能靠感觉. 首先介绍一个数学中相关的概念: 同余  </p>
<h3 id="同余的概念"><a href="#同余的概念" class="headerlink" title="同余的概念"></a>同余的概念</h3><p>两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余 记作 a ≡ b (mod m) 读作 a 与 b 关于模 m 同余。 举例说明:</p>
<blockquote>
<p>4 mod 12 = 4 16 mod 12 = 4 28 mod 12 = 4</p>
</blockquote>
<p>所以4, 16, 28关于模 12 同余.  </p>
<h3 id="负数取模"><a href="#负数取模" class="headerlink" title="负数取模"></a>负数取模</h3><p>正数进行mod运算是很简单的. 但是负数呢? 下面是关于mod运算的数学定义: <a href="http://images.cnblogs.com/cnblogs_com/zhangziqiu/201103/201103302155507894.jpg" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/zhangziqiu/201103/201103302155504514.jpg" alt="clip_image001" title="clip_image001"></a> 上面是截图, “取下界”符号找不到如何输入(word中粘贴过来后乱码). 下面是使用”L”和”J”替换上图的”取下界”符号:</p>
<blockquote>
<p>x mod y = x - y L x / y J</p>
</blockquote>
<p>上面公式的意思是: x mod y等于 x 减去 y 乘上 x与y的商的下界. 以 -3 mod 2 举例:</p>
<blockquote>
<p>-3 mod 2 = -3 - 2xL -3/2 J = -3 - 2xL-1.5J = -3 - 2x(-2) = -3 + 4 = 1</p>
</blockquote>
<p>所以:</p>
<blockquote>
<p>(-2) mod 12 = 12-2=10 (-4) mod 12 = 12-4 = 8 (-5) mod 12 = 12 - 5 = 7</p>
</blockquote>
<h3 id="开始证明"><a href="#开始证明" class="headerlink" title="开始证明"></a>开始证明</h3><p>再回到时钟的问题上:</p>
<blockquote>
<p>回拨2小时 = 前拨10小时 回拨4小时 = 前拨8小时 回拨5小时= 前拨7小时</p>
</blockquote>
<p>注意, 这里发现的规律! 结合上面学到的同余的概念.实际上:</p>
<blockquote>
<p>(-2) mod 12 = 10 10 mod 12 = 10</p>
</blockquote>
<p>-2与10是同余的.</p>
<blockquote>
<p>(-4) mod 12 = 8 8 mod 12 = 8</p>
</blockquote>
<p>-4与8是同余的. 距离成功越来越近了. 要实现用正数替代负数, 只需要运用同余数的两个定理: 反身性:</p>
<blockquote>
<p>a ≡ a (mod m)</p>
</blockquote>
<p>这个定理是很显而易见的. 线性运算定理:</p>
<blockquote>
<p>如果a ≡ b (mod m)，c ≡ d (mod m) 那么: (1)a ± c ≡ b ± d (mod m) (2)a <em> c ≡ b </em> d (mod m)</p>
</blockquote>
<p>如果想看这个定理的证明, 请看:<a href="http://baike.baidu.com/view/79282.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/79282.htm</a> 所以:</p>
<blockquote>
<p>7 ≡ 7 (mod 12) (-2) ≡ 10 (mod 12) 7 -2 ≡ 7 + 10 (mod 12)</p>
</blockquote>
<p>现在我们为一个负数, 找到了它的正数同余数. 但是并不是7-2 = 7+10, 而是 7 -2 ≡ 7 + 10 (mod 12) , 即计算结果的余数相等. 接下来回到二进制的问题上, 看一下: 2-1=1的问题.</p>
<blockquote>
<p>2-1=2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]反 + [1111 1110]反</p>
</blockquote>
<p>先到这一步, -1的反码表示是1111 1110. 如果这里将[1111 1110]认为是原码, 则[1111 1110]原 = -126, 这里将符号位除去, 即认为是126. 发现有如下规律:</p>
<blockquote>
<p>(-1) mod 127 = 126 126 mod 127 = 126</p>
</blockquote>
<p>即:</p>
<blockquote>
<p>(-1) ≡ 126 (mod 127) 2-1 ≡ 2+126 (mod 127)</p>
</blockquote>
<p>2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1 所以说一个数的反码, 实际上是这个数对于一个膜的同余数. 而这个膜并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值! 而2+126很显然相当于钟表转过了一轮, 而因为符号位是参与计算的, 正好和溢出的最高位形成正确的运算结果. 既然反码可以将减法变成加法, 那么现在计算机使用的补码呢? 为什么在反码的基础上加1, 还能得到正确的结果?</p>
<blockquote>
<p>2-1=2+(-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]补 + [1111 1111]补</p>
</blockquote>
<p>如果把[1111 1111]当成原码, 去除符号位, 则:</p>
<blockquote>
<p>[0111 1111]原 = 127</p>
</blockquote>
<p>其实, 在反码的基础上+1, 只是相当于增加了膜的值:</p>
<blockquote>
<p>(-1) mod 128 = 127 127 mod 128 = 127 2-1 ≡ 2+127 (mod 128)</p>
</blockquote>
<p>此时, 表盘相当于每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 128]. 但是由于0的特殊情况, 没有办法表示128, 所以补码的取值范围是[-128, 127] 本人一直不善于数学, 所以如果文中有不对的地方请大家多多包含, 多多指点!</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title>javascript扼要</title>
    <url>/2016/10/07/javascript%E6%89%BC%E8%A6%81/</url>
    <content><![CDATA[<p>  ~_~</p>
<p>继续开坑</p>
<p>html负责数据的显示，css负责样式的显示，javascript负责<strong>完成页面的交互</strong></p>
<p>javascript有很多<strong>框架</strong>（类似于OC中的Fundation Cocoa框架集等），最早的是prototype.js现在很少用</p>
<p>现在最流行的几种比如  jQuery  有很多插件，Extjs等，DWR框架（可以达到直接通过js调用java的代码）</p>
  <a id="more"></a>
<p>一、</p>
<p>①可直接在html中在script标签中写<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script type=”text/javascript&gt;  (类似于css的&lt;style type=”text/css”&gt;..</span><br><span class="line"></span><br><span class="line">/*js代码*/</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">②也可以引入外部文件（常用） css中用link  通过src指定外部文件位置</span><br><span class="line"></span><br><span class="line"> &lt;script type=”text/javascript” src=”hello.js&gt;&lt;/script&gt; </span><br><span class="line"></span><br><span class="line">注意：&lt;script&gt;标签**不能自结束！**</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">alert(“”);</span><br></pre></td></tr></table></figure></p>
<p>二、基本语法相关</p>
<p>很多东西 常用技巧习惯语法和java很像</p>
<p>①javascript是<strong>动态类型语言</strong>，而C java等是静态类型语言，动态类型语言是运行到哪读哪</p>
<p>②变量：js<strong>只能通过var来创建变量，</strong>eg: var a = 20 注意for(var i;i&lt;=10;i++) 不要习惯性把var写成int等 住手这不是c/java啊喂 xxxx</p>
<p><strong>注意：当在函数内部没有使用var来声明变量的时候，这个变量就会作为全局变量声明！所以在函数中定义变量一定要使用var</strong></p>
<p>③函数: 通过<strong>function来创建函数</strong></p>
<p>方法一： <code>function fn1() {   }</code></p>
<p>方法二：<code>var x=function(){ return a;}</code>然后x(); 就是这个函数</p>
<p>方法三：<code>function fn2(){}  var y=fn2;</code>（仅函数名 不带括号）</p>
<p>(理解..其实都一个原理，指针 内存等） 函数名字可以通过改指针改，这是静态语言无法做到的</p>
<p>④注释：同java</p>
<p>（html）通过<code>&lt;input  type=”xxx”&gt;&lt;/input&gt;</code>标签  等来插入按钮等  然后可以添加事件  比如xxx可以为button，则为添加一个按钮</p>
<p>⑤数据类型相关 常用</p>
<p><code>alert（typeof a);</code> 查看a的类型 注对于数组等对象而言返回object 对于函数返回function</p>
<p>强制类型转换：<code>Number(a)</code>（java中为（Number）a）  如果强制转换一个非数字的值为Number会得到一个<strong>NaN</strong>的值</p>
<p><code>parseInt(a)</code>可将字符串开头的几个数字转换为Int ，但如果开头不是数字则NaN</p>
<p>a instanceof Array 判断as是不是Array的实例 是则返回true</p>
<p><strong>布尔类型 true false 在js中，除了NaN，undefined，0这三个类型以外，其余皆为true</strong> （ 然后就可以通过这个特性搞事情</p>
<p>比如if(a) 等等</p>
<p>三、面向对象、原型（详细原理见二部分引用外部文章）</p>
<p>js中没有“类”的概念（ruby python也是） js的对象是基于原型拷贝的</p>
<p>动态语言一般都基于原型拷贝 只有一个根对象</p>
<p>“类”的定义<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function Person(name,age)&#123;</span><br><span class="line"></span><br><span class="line">this.name=name; (定义了Person的一个属性为name)</span><br><span class="line"></span><br><span class="line">this.age= age;</span><br><span class="line"></span><br><span class="line">this.mmm=”ssssss”; (定义了Persion的一个属性为mmm）</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>必须要用this声明，如果没有this声明则仅仅只是函数的一个局部变量而不是类的属性</p>
<p><strong>就算要在类里面创建函数 也需要this！ eg :this.abc= function(){}</strong></p>
<p>js中每创建一个对象都存在一个function行为，占有内存，因为这个<strong>function行为属于一个属性</strong>，而java中不会这样，function不属于类的属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p1= new Person(“jack”,10);</span><br><span class="line"></span><br><span class="line">alert(p1.name);</span><br></pre></td></tr></table></figure>
<p>除了点语法以外，也可以通过对象[“属性字符串”]完成对属性的调用</p>
<p>如<code>alert(p1[“name”];</code></p>
<p>在js中对于对象而言 ，可以通过for in来遍历对象的属性 可以获取对象中<strong>所有的显示声明的属性</strong></p>
<p>e.g.<code>for (var a in p1){}</code></p>
<p>要显示p1的所有属性 遍历输出之 即可<code>for(var i in p1) {alert(p1[i]}</code></p>
<p>常用对象：查库。</p>
<hr>
<p>二部分引用外部文章：理解（重要，此文写得非常详细清晰）</p>
<h1 id="Javascript中的函数、this以及原型"><a href="#Javascript中的函数、this以及原型" class="headerlink" title="Javascript中的函数、this以及原型"></a><a href="http://www.cnblogs.com/xfrog/archive/2013/06/16/3138293.html" target="_blank" rel="noopener">Javascript中的函数、this以及原型</a></h1><p>链接：<strong><a href="http://www.cnblogs.com/xfrog/archive/2013/06/16/3138293.html" target="_blank" rel="noopener">http://www.cnblogs.com/xfrog/archive/2013/06/16/3138293.html</a></strong></p>
<p><strong>关于函数</strong></p>
<p>在Javascript中函数实际上就是一个对象，具有引用类型的特征，所以你可以将函数直接传递给变量，这个变量将表示指向函数“对象”的指针，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(message)&#123;</span><br><span class="line">          alert(message);</span><br><span class="line">     &#125;</span><br><span class="line">     var f = test;</span><br><span class="line">     f(&apos;hello world&apos;);</span><br></pre></td></tr></table></figure>
<p>你也可以直接将函数申明赋值给变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f = function(message)&#123;</span><br><span class="line">          alert(message);     </span><br><span class="line">     &#125;;</span><br><span class="line">     f(&apos;hello world&apos;);</span><br></pre></td></tr></table></figure>
<p>在这种情况下，函数申明中可以省略函数名称，因为此时名称已经没有任何意义，我们可直接通过变量f来调用函数。</p>
<p>通过Function类型，我们可以更好地理解函数即对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f = new Function(&quot;message&quot;,&quot;alert(message);&quot;);</span><br><span class="line">     f(&apos;hello world&apos;);</span><br></pre></td></tr></table></figure>
<p><strong>关于this</strong></p>
<p>this可以看成调用函数的实际作用域上下文。比较以下函数的执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">          this.property = &apos;hello world&apos;;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     test();</span><br><span class="line">     alert(window.property);   //由于在全局范围内调用，test函数中的this实际指向全局对象(window)</span><br><span class="line"></span><br><span class="line">     var obj = &#123;&#125;;</span><br><span class="line">     test.call(obj);      //通过call第一个参数指定执行上下文范围，所以test函数中this指向obj实例。</span><br><span class="line">     alert(obj.property);      </span><br><span class="line"></span><br><span class="line">     var obj2 = &#123;&#125;;</span><br><span class="line">     obj2.test2 = test;      //将obj2实例方法test指向 全局test方法</span><br><span class="line">     obj2.test2();            //由于是在obj2上调用test方法，所以test函数中的this也指向了obj2实例</span><br><span class="line">     alert(obj2.property);</span><br></pre></td></tr></table></figure>
<p><strong>定义类型</strong></p>
<p>在Javascript中可以定义构造函数，构造函数与一般函数没有任何区别，在创建实例时，如果我们使用了new关键字，那么这个函数就具有构造函数的特性，否则就是一般函数，如下所示，我们定义了一个Person类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">     this.name = &apos;xfrog&apos;;</span><br><span class="line">     this.Say = function()&#123;</span><br><span class="line">          alert(this.name);</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用new关键字时，可以创建一个新的Person对象实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p1 = new Person();</span><br><span class="line">p1.Say();</span><br></pre></td></tr></table></figure>
<p>如果不使用new关键字，将直接执行Person函数，由于执行上下文为全局范围，故name属性和Say方法将被添加到window对象：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Person();</span><br><span class="line">&gt; Say();</span><br><span class="line">&gt; window.Say();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>原型</strong></p>
<p>注意上述Person的定义方式，当使用new来创建Person实例时，将会执行Person构造函数，也就是会声明name属性和Say方法，这样可能产生效率问题，注意以下代码：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var p1 = new Person();</span><br><span class="line">&gt;      var p2 = new Person();</span><br><span class="line">&gt;      var test = p1.Say == p2.Say;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>比较p1和p2两个Say函数指针，返回false，表示每个Person实例中的Say方法都是独立的，而事实上Say函数的功能是完全一样的，我们完全没有必要为每个对象重新分配Say函数”对象“，如果Person实例很多，将会造成大量的内存耗用。</p>
<p>如果将Say函数提取出来放入全局执行范围，似乎可解决次问题：</p>
<p>&gt;<br>&gt;</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; function Person()&#123;</span><br><span class="line">&gt;           this.name = &apos;xfrog&apos;;</span><br><span class="line">&gt;           this.Say = say;     </span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;      function say()&#123;</span><br><span class="line">&gt;           alert(this.name);     </span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;      var p1 = new Person();</span><br><span class="line">&gt;      var p2 = new Person();</span><br><span class="line">&gt;      alert(p1.Say == p2.Say);</span><br><span class="line">&gt;      p1.name = &apos;wang&apos;;</span><br><span class="line">&gt;      p1.Say();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>由于this始终和执行上下文相关，p1和p2实例中的Say方法中会正确地返回对应实例的name属性。但是，使用此方式有违面向对象的思想，也失去了类型密封的原则。还会造成大量的全局函数。</p>
<p>为了解决这些缺点，Javascript引出了原型的概念，简单理解，原型可以看成是类型的共享区，原型本身是一个对象，而对象中的属性对于类型来说是共享的。Javascript中每个类型通过prototype属性来表示原型，通过这个属性可指定共享方法：</p>
<p>&gt;<br>&gt;</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; function Person()&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      Person.prototype.name = &apos;xfrog&apos;;</span><br><span class="line">&gt;      Person.prototype.Say = function()&#123;</span><br><span class="line">&gt;           alert(this.name);</span><br><span class="line">&gt;      &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt;      var p1 = new Person();</span><br><span class="line">&gt;      var p2 = new Person();</span><br><span class="line">&gt;      alert(p1.Say == p2.Say);     //返回true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>为什么这里可以通过p1.Say来访问Say方法呢？这是因为ECMAScript标准规定了类型属性的查找顺序：先在类型的实例上查找，如果没有则继续在类型原型上查找，这一查找路径采用短路算法，即找到首个后即返回，考虑如下代码：</p>
<p>&gt;<br>&gt;</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; function Person()&#123;</span><br><span class="line">&gt;           this.name = &apos;wang&apos;;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;      Person.prototype.name = &apos;xfrog&apos;;</span><br><span class="line">&gt;      Person.prototype.Say = function()&#123;</span><br><span class="line">&gt;           alert(this.name);</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;      var p1 = new Person();</span><br><span class="line">&gt;      p1.Say();      //将返回wang</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面提到prototype实际上是一个对象，那么我们是否可以直接访问呢？ 在一些浏览器实现（如Chrome、Fixfox等）的确可通过实例的<strong>proto</strong>属性来访问内部的prototype对象，这种特征表明Javascript引擎在每个对象的内部都是通过一个变量来保存对prototype的引用，这保证了prototype对应整个类型的实例来说是共享的，例如，你可在Chrome浏览器内使用如下方式来访问Say方法：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; p1.__proto__[&quot;Say&quot;]();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>由于原型是一个对象，我们可以直接将一个对象赋值给prototype：</p>
<p>&gt;<br>&gt;</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; function Person()&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;      Person.prototype = &#123;name:&apos;xfrog&apos;, Say:function()&#123;</span><br><span class="line">&gt;           alert(this.name);</span><br><span class="line">&gt;      &#125;&#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意这个方式下，实际上是完全替换了Person的prototype，这与上面Person.prototype.name方式还是有细微差异的，这是因为任何类型，Javascript引擎都会添加默认的prototype，在这个prototype中包含一个对构造函数的引用，即原型对象属性constructor，所以通常使用替代prototype方式时，我们需要手动加上constructor属性：</p>
<p>&gt;<br>&gt;</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Person.prototype = &#123; </span><br><span class="line">&gt;           constructor: Person,</span><br><span class="line">&gt;           name :&apos;xfrog&apos;,</span><br><span class="line">&gt;           Say:function()&#123;</span><br><span class="line">&gt;                alert(this.name);</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，由于prototype对于整个类型是共享的，那么在prototype中的引用类型可能会存在问题，前面的Say函数作为一个对象，也是引用类型，所以每个实例中的Say都指向原型对象中的同一个函数，这本身没有问题，也是我们使用原型的初衷，但对于其他引用对象，可能结果并不是我们想要的：</p>
<p>&gt;<br>&gt;</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; function Person()&#123;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;      Person.prototype = &#123;</span><br><span class="line">&gt;           name: &apos;xfrog&apos;,</span><br><span class="line">&gt;           obj : &#123; age: 18 &#125;,</span><br><span class="line">&gt;           Say : function()&#123;</span><br><span class="line">&gt;                alert(this.obj.age);</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;      &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt;      var p1 = new Person();</span><br><span class="line">&gt;      var p2 = new Person();</span><br><span class="line">&gt;      p1.obj.age = 20;</span><br><span class="line">&gt;      p1.Say();</span><br><span class="line">&gt;      p2.Say();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>p2.Say返回的是20，这是因为obj属性作为原型属性是共享的，在内存中只存在一个实例，所以通过p1修改后，p2只能得到修改后的状态。如果要避免此情况，可将obj属性放到实例中：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; function Person()&#123;</span><br><span class="line">&gt;           this.obj = &#123; age: 18 &#125;;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>程序语言</category>
        <category>HTML/JS/CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS扼要-2</title>
    <url>/2016/10/03/CSS%E6%89%BC%E8%A6%81-2/</url>
    <content><![CDATA[<p>六、超链接样式</p>
<p>CSS:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a:link&#123;      &lt;!–此为默认情况–&gt;</span><br><span class="line"></span><br><span class="line">text-decoration:none;   &lt;!–去掉下划线–&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>②访问后样式 a:visited</strong>{      &lt;!–链接被访问（点击）过之后–&gt;</p>
<p>}</p>
 <a id="more"></a>
<p>兼容性问题：非IE会继承默认属性而IE不继承，故第一段未访问情况改为这样</p>
<p><strong>①未访问样式 a:link,a:visited</strong>{</p>
<p>}</p>
<p><strong>③鼠标移动到上面的时候的样式 a:hover</strong>{</p>
<p>}</p>
<p><strong>注意 :hover不只运用于超链接 对于任何元素均可设置hover的属性,表示当鼠标移动到上面的时候的样式 xxx:hovor{}</strong></p>
<p>类超链接控制器 <code>eg: a.xxx:link{} a.xxx:visited{} a.xxx:hover{}</code></p>
<p>—</p>
<p>HTML:</p>
<p><code>&lt;a href=”#”&gt;xxx&lt;/a&gt;</code></p>
<p><strong>注意CSS样式表的优先级问题 被包含的处理优先级要高（先加载它）一些</strong>，也就是先处理，所<strong>以实际套用的是优先级低（后加载的）的</strong>包含者的属性</p>
<p>比如<code>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;p&gt;&lt;/p&gt;&lt;/ui&gt;</code></p>
<p>ul{}</p>
<p>ul p{}</p>
<p>p被包含于ul中，所以实际上先处理了第二条 再处理了第一条，所以第二条的属性被第一条覆盖了</p>
<p>当使用了包含的操作符之后，它的加载时间比使用class的加载时间低，此时再来定义一个class的样式，就不会把使用包含的样式覆盖掉</p>
<p>七、CSS HACK</p>
<p>加<em> 使得不同浏览器读出不同的语句 加</em>语句该浏览器能识别就读 不能识别就跳过</p>
<p>八、错误总结出的经验：</p>
<p>1、float是设置给所有需要浮动的元素的属性 而不是表格整体</p>
<p>2、不能忽视[ul]和[div块]的宽度！！ul与div本身是有宽度属性的！！！</p>
<p>img文件一般放在css文件夹中（或其中的子目录） 方便background url设置等</p>
<p>两个点 ..访问上一级目录</p>
<p>cursor:pointer;   hovor中的样式 使得鼠标移动上去变成手指 </p>
<p>九、布局设计/流派</p>
<p>布局一：</p>
<p>一整块div网页的写法 这种大DIV一块的方式是以前的网站的常用布局</p>
<p>现在的布局一般不采用</p>
<p>布局二：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div id=“head”&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div id=“c_head”&gt;顶部图片&lt;/div&gt;  /*c center*/</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=“nav”&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div id=“c_nav”&gt;导航内容&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=“content”&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div id=“c_content”&gt;内容&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=“bottom”&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div id=“c_bottom”&gt;底部内容&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>c_xxx也要用到div的居中对齐方法，见文章 <em>CSS扼要-1</em></p>
<p>这样就使得页面很宽 内容全铺在屏幕上</p>
<p>但实际上显示的内容还是在中间一部分</p>
<p>布局三：瀑布流布局</p>
<p>以专门看图片为主 仅CSS无法实现</p>
<p>十、display属性</p>
<p>display:none; 不显示</p>
<p>display:block; 显示</p>
<p><strong>导航菜单的伸缩实现</strong>：为菜单首先加上class=”a”; 但点击后使其class=”a”变成class=”b”（通过javascript实现）</p>
<p>–样式表：class=”a”{不显示} class=”b”{显示}</p>
]]></content>
      <categories>
        <category>程序语言</category>
        <category>HTML/JS/CSS</category>
      </categories>
  </entry>
  <entry>
    <title>bandwagon迁移digitalocean 大成功</title>
    <url>/2016/10/01/bandwagon%E8%BF%81%E7%A7%BBdigitalocean%20%E5%A4%A7%E6%88%90%E5%8A%9F/</url>
    <content><![CDATA[<p>centos6.5无可用php5.5源真是折腾死我了 ……………</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>CSS扼要-1</title>
    <url>/2016/09/29/CSS%E6%89%BC%E8%A6%81-1/</url>
    <content><![CDATA[<p>一、<br>HTML仅用于页面内容的显示<br>而CSS是修饰<br>可查阅CSS手册查看大量的CSS样式</p>
<p>CSS难点在于在什么情况应该用什么手段解决问题</p>
<p>参考书籍 <em>Zen Garden</em></p>
<p>引入样式表<code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;xxx.css&quot;&gt;</code></p>
<p>px像素</p>
<p><strong>标题和文章一般用12px/14px</strong> </p>
  <a id="more"></a>
<p>ATT注意编码问题，win10纪事本默认ANSI编码 如果meta里设置UTF-8则txt文档在保存的时候应该储存为UTF-8编码！否则会出现乱码，中文字体读不出来等情况</p>
<p><code>background:url(“xxx.xxx”) no-repeat;</code></p>
<p><code>background-position:5px 10px;</code>第一个值为左右 第二个值为上下</p>
<p>插入图片有三种方式：①img标签src属性②设置background</p>
<p>background更快，因为backgrond会把图片存入缓存中，<strong>故除非该图片会变化，则一律用background插入图片(可设置为一个div的样式）</strong></p>
<p>max-width:100%; 宽度自适应屏幕，高度同理,max-height:;</p>
<p>二、<strong>选择器</strong><br>p{} 标签选择器<br>#xx{} id选择器 id=”xx”<br>x.xx{} 类（class）选择器 class=”xx” 可以选择【一组】标签  p.xx{} 标签为p中的class为xx的标签，表示p标签的所有xx类，类不可单独拿出来选择 必须要【标签.类名】 格式<br>（W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class）<br>p.#xx{} 标签为p中id为xx的<br>* {} *表示所有的标签</p>
<p>div span{} 包含选择符 指p标签中的所有span标签都来设置这个信息(eg:<code>&lt;div&gt;..&lt;span&gt;&lt;/span&gt;..&lt;/div&gt;
div &gt;</code>h2{} 子对象选择符 (eg:<code>&lt;div&gt;…….&lt;h2&gt;….&lt;/h2&gt;….&lt;h2&gt;…..&lt;/h2&gt;…&lt;p&gt;..&lt;/p&gt;..&lt;div&gt;</code><br>注意区别：子对象选择符(&gt;)仅仅只针对第一级子对象，而包含选择符(空格)则针对一切子对象</p>
<p>xx,xx,#xx,#xx{} 分组选择符，用逗号同时设定多个标签，使他们都遵循下面样式</p>
<p>三、盒子模型（代替HTML中的表格布局 但不能完全替代框架）<br>对于每一层盒其margin和padding属性<br>margin:对外（上一级）<br>padding:对内（下一级）<br>不加left right top button则是四个方向统一设置(若加则单独设置margin-left,padding-right,etc）<br>也可以 margin:12px,10px,20px,20px 表示从top开始顺时针转的各方向</p>
<p><strong>千万不要使用padding来进行对齐操作</strong>。对于IE padding的值会算在width中，而对于其他浏览器，padding的值不算入width中！ <strong>不兼容问题</strong> 但若没有设置width则可以，但最建议还是用position方式</p>
<p>(如主菜单 每一个都是一个span 共存一个div中；或者文章列表，每一个标题都是一个span 存于一块div中)<br><strong>但主菜单，文章列表等等 一般用表格 ul dl等</strong></p>
<p><strong>那么如何方便居中呢 也一般使用表格ul dl</strong></p>
<p>（补充：去掉ul的点 list-style-type:none;）</p>
<p>有些标签比如h3 body标签自身margin和padding属性不为0，若需要要自己改，可以直接<strong>*{margin:0; padding:0;} css文件第一句话要写这个！一般都不用自身的margin和padding</strong></p>
<p>在html，有一些标签仅仅是用来设置文本，<strong>诸如a和span</strong>，对于这两个标签而言，在W3C标准中默认是<strong>不能进行width等样式进行修饰</strong>的，所以为这些标签设置width是没有作用的，<strong>需要display:block;</strong>（写入样式表）之后才有作用。但对于IE是有作用的（IE的标准与W3C不一样 微软强无敌= =）在开发中，一般对span加width是没有意义的，<strong>（一般不用为span加width），若果需要可能是设计有问题..</strong></p>
<p>四、定位</p>
<p>position样式  然后就可以设置top/bottom/right/left的值(eg : left:40px)</p>
<p>1、position:absolute; 绝对定位 针对浏览器而言的（此话是有误的，但很多时候是这样，见下一段）。当设置之后，该容器就不会再占用相应的空间，原有的空间会被其它元素占用</p>
<p>（<strong>实际上，绝对定位会针对父级标签中进行了absolute定位的标签来进行left/right等设置，如果父级标签都没有这样的定位方式，则根据body来定位</strong>）</p>
<p>2、position:relative;相对定位 针对父级元素进行定位，而且空间会一直占用，哪怕这个元素已经移动到其它位置</p>
<p>默认的定位方式为static，这种定位不能设置top/bottom/right/left</p>
<p>使用经验：经常会使用relative来实现文本位置的移动。所以如果要为某个容器设置里面的文本位置，可以按照如下方式来处理<strong><li><span>abscd</span></li></strong>   </p>
<p><strong>经验：内容一般都存在<span></span>或<a></a>里。</strong></p>
<p><strong>所以做居中对齐的时候，把内容放在span里，加position:relative;然后设置top/bottom/right/left</strong></p>
<p><strong>这是对齐的唯一方式！不能用padding,width！</strong></p>
<p><strong>居中一个div的方法（重要！）</strong>，text-align:center;只有IE可以居中，margin:auto;只有IE之外的浏览器可以居中，<strong>所以推荐的居中方式就是position定位的方法！见下：eg</strong></p>
<p>#container{</p>
<p><strong>width:1100px;</strong> &lt;!–宽度设为1100px–&gt;</p>
<p>border:1px solid #229;  &lt;!–别给contain div（整块的主div设高度），不设高度就让元素把它撑下来 有多少高多少–&gt;</p>
<p><strong>position:absolute;</strong> &lt;!—-&gt;</p>
<p><strong>left:50%;</strong>    &lt;!–左边框对齐页面中央–&gt;</p>
<p><strong>margin-left:-550px;</strong>  &lt;!–向左回一半–&gt;</p>
<p>}</p>
<p>当然也可两个居中方式都写..（orz这样IE和非IE都管用了，简单粗暴..）但推荐还是用以上的方式（因为如果设了margin：auto后其子类全部都继承这个属性）</p>
<p>3、position:fixed;</p>
<p>固定在页面上，不随滚动条滚动而改变位置</p>
<p>五、float</p>
<p>float:left;左飘，第一个放最左边</p>
<p>float:right;右飘，第一个放最右边</p>
<p>float可使得表格等横向浮动 （<strong>表格中在<li>样式里设置</li></strong>）</p>
<p>兼容性：对于IE，设置float后该标签依然占用空间，而其他浏览器不占用，<strong>故必须要再添加一个属性 clear:both;  将两段的float清除！否则对于IE外的浏览器设置了float的元素不再占用空间，下面的元素会飘上来！</strong></p>
<p><strong>border-bottom:1px solid red; 只设置底部边框那条 ，etc  加线</strong></p>
]]></content>
      <categories>
        <category>程序语言</category>
        <category>HTML/JS/CSS</category>
      </categories>
  </entry>
  <entry>
    <title>HTML扼要</title>
    <url>/2016/09/29/html/</url>
    <content><![CDATA[<p>一、每个块的标题 全用h 搜索引擎会搜索h<br>ul无序 （li） 诸如导航 文章列表等<br>dl 数据列表块 （dt标题 dd元素）</p>
<p>ul dl非常重要</p>
<p>表格<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">&lt;tr&gt;  /*第一行*/</span><br><span class="line"></span><br><span class="line">&lt;td&gt;&lt;/td&gt;td&gt;&lt;/td&gt;td&gt;&lt;/td&gt;  /*第一行里每一列*/</span><br><span class="line"></span><br><span class="line">&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;tr&gt; /*第二行*/</span><br><span class="line"></span><br><span class="line">&lt;td&gt;&lt;/td&gt;td&gt;&lt;/td&gt;td&gt;&lt;/td&gt; /*第二行里每一列*/</span><br><span class="line"></span><br><span class="line">&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p>
 <a id="more"></a>
<p>表格的样式属性 网上查</p>
<p>ol不常用<br>&amp;nbsp 页面空格<br>a超链接<code>href</code><br><code>&lt;!– –&gt;</code><br><code>&lt;br/&gt;</code><br>每个标签都要有/结束 如果只有一个不是一组则自结束<br>frame input br等都可自结束<br><code>&lt;pre&gt;</code> 格式显现出来的文本</p>
<p>二、常用布局标签<br>div于span用于进行容器控制<br>div 一般设定一个容器，这个容器中可以放置大量的内容<br>span 一般用于放置最后的文本数据，用来进行简单的控制</p>
<p>补充href属性和src属性的区别</p>
<p>href 表示超文本引用（hypertext reference），在 link和a 等元素上使用。src 表示来源地址，在 img、script、iframe 等元素上。</p>
<p>src 的内容，是页面必不可少的一部分，是引入。href 的内容，是与该页面有关联，是引用。区别就是，引入和引用。</p>
<p>三、表单<br>常用的表单标签原则上都要放在form标签中<br>input标签可以用来设置文本框密码框等数据<br>submit表示提交，提交的时候会链接到指定页面去处理<br>button是按钮，如果没有进行控制则不会发生反应<br>radio单选框 name用来分组 使得其变成单选框，当name一样表示这几个radio都在一个组中，点击其中一个会取消其他的选中<br>checkbox多选框 用法同radio 不用分组<br>下拉列表框 select 不用input 用法见下<br>textarea文本框 不用input 用法见下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action=”01.html”&gt;</span><br><span class="line">用户名：&lt;input type=”text”/&gt;&lt;br/&gt;</span><br><span class="line">密码：&lt;input type=”password”/&gt;&lt;br/&gt;</span><br><span class="line">性别：&lt;input type=”radio” value=”男” name=”sex”/&gt;男&lt;input type=”radio” value=”女” name=”sex”/&gt;女&lt;br/&gt;</span><br><span class="line">兴趣：&lt;input type=”checkbox”/&gt;足球&lt;input type=”checkbox”/&gt;羽毛球&lt;input type=”checkbox”/&gt;篮球&lt;input type=”checkbox”/&gt;乒乓球&amp;ltbr/&gt;</span><br><span class="line">籍贯：&lt;select&gt;</span><br><span class="line">&lt;option&gt;北京&lt;/option&gt;</span><br><span class="line">&lt;option&gt;上海&lt;/option&gt;</span><br><span class="line">&lt;option&gt;广州&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;textarea cols=”50″ rows=”10″ &gt;&lt;/textarea&gt;&lt;br/&gt;</span><br><span class="line">&lt;input type=”submit” value=”用户注册”/&gt;</span><br><span class="line">&lt;input type=”button” value=”点一下试试”/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>四、frameset 框架 布局</p>
<p>框架并不是完全被CSS布局替代，比如说在设计管理界面等页面框架的时候 局部刷新等的时候就需要框架 （当然建议也可以用div+css方式完成）<br>不能在body中设置，其上级为html标签<br>cols/rows表示让这个框架基于横/纵向方式切分，cols，rows可同时使用以平均拆分（像表格一样），每行每列达到要求。如果不想全部平均拆分（有些地方分有些地方部分），则使用frame嵌套的方法（多个框架文件嵌套）。<br>多使用frame嵌套方法实现较好的布局</p>
<p>3个框架大小依次列出150 *（剩下） 150<br>norisize使得边框不能移动；frameborder值为0表示没有边框 如果有边框则为1 border设置边框厚度<br>框架不能src属性不能为其自身文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;frameset cols=&quot;150,*,150&gt; (&lt;frameset cols=&quot;150,*,150 rows=&quot;150,*,150″/&gt;)</span><br><span class="line">&lt;frame src=&quot;01.html&quot; noresize frameborder=0 border=3/&gt;</span><br><span class="line">&lt;frame src=&quot;02.html&quot; target=&quot;content&quot;/&gt;</span><br><span class="line">&lt;frame name=&quot;content&quot; src=&quot;03.html&quot;/&gt;</span><br><span class="line">&lt;/frameset&gt;</span><br></pre></td></tr></table></figure>
<p>局部刷新的方法：在超链接的时候增加属性<code>target=”content”</code>，这个链接就会在content这个frame（href必须链接到该页面）中显示（当然，需要先把一个frame的名字设置为content）</p>
<p>如果要将整个框架居中 则需要在框架外再嵌套一层框架 使其分为左中右三栏，左右留为空白</p>
<p>如何通过css+div实现局部刷新？ 参考<a href="http://zhidao.baidu.com/link?url=ZuP0aA_mv4coT4zCflt3_wwuj9d2G-6kAgD9W22P_6sBdgWtp0iFRvZAcmb7XU0C7L35aO7VoqRH2tHhTlc8H_" target="_blank" rel="noopener">http://zhidao.baidu.com/link?url=ZuP0aA_mv4coT4zCflt3_wwuj9d2G-6kAgD9W22P_6sBdgWtp0iFRvZAcmb7XU0C7L35aO7VoqRH2tHhTlc8H_</a></p>
<p>五、通过<code>&lt;input  type=&quot;xxx&quot;&gt;&lt;/input&gt;</code>标签  等来插入按钮等  然后可以添加事件  比如xxx可以为button，则为添加一个按钮</p>
]]></content>
      <categories>
        <category>程序语言</category>
        <category>HTML/JS/CSS</category>
      </categories>
  </entry>
  <entry>
    <title>提前进入国庆状态..</title>
    <url>/2016/09/29/%E6%8F%90%E5%89%8D%E8%BF%9B%E5%85%A5%E5%9B%BD%E5%BA%86%E7%8A%B6%E6%80%81../</url>
    <content><![CDATA[<p><img src="http://aisakaki.com/wp-content/uploads/2016/05/image-1.jpeg" alt="image"></p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>172</title>
    <url>/2016/09/21/172/</url>
    <content><![CDATA[<p>——你是日向同学吧… </p>
<p>——你是说以前的我吗 </p>
<p>——…果然…你不记得了啊……已经…想不起来了吗…</p>
<p> ——做不到.我以前的记忆已经完全被消除了 </p>
<p>——什么都…能做到哦…日向同学的话……你看，去做的话总有办法… ………. </p>
<p>——果然…还是不行啊… ………. </p>
<p>——没能救…日向同学…对不起…</p>
<p> ——就算成了这种状况，你还是想着保护别人啊</p>
<p> ——因为…我喜欢大家啊………不要…不想死…我还有…想做的事…还想继续和大家做同学…还想再一次和日向同学…一起打游戏啊… </p>
<p>--- 我才是…谢谢你。 大家的事…我不会忘记哦… 永远永远…不会忘记哦… 从今以后…我也会在某处给大家加油哦。 因为…我们永远都是同伴嘛。</p>
<p> --- 你的愿望最终实现了哟</p>
]]></content>
      <categories>
        <category>Anime</category>
      </categories>
  </entry>
  <entry>
    <title>今年成都的夏天真热</title>
    <url>/2016/08/29/%E4%BB%8A%E5%B9%B4%E6%88%90%E9%83%BD%E7%9A%84%E5%A4%8F%E5%A4%A9%E7%9C%9F%E7%83%AD/</url>
    <content><![CDATA[<p>终于降温了~</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>iOS-1</title>
    <url>/2016/08/12/ios-1/</url>
    <content><![CDATA[<p>1、获取UIApplication代理： AppDelegate* appDelegate = [UIApplication shareApplication].delegate 应用程序代理是整个iOS应用的通讯中心，其他应用程序组件都可以通过该对象进行数据交换，同时ios应用代理还负责处理用用程序执行中的事件循环 应用程序代理需要满足两个规则：继承UIResponder基类和遵守UIApplicationDelegate协议（UIResponder是iOS应用提供的一个基类，所有需要向用户提供响应的对象都需要继承UIResponder基类）   </p>
 <a id="more"></a>
<p>2、MVC模式 百度百科：</p>
<p><a href="https://www.baidu.com/s?wd=MVC&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nHP-Pv7bPW6LnHF9rynv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHDsrjb1P101" target="_blank" rel="noopener">MVC</a>全名是Model View Controller，是模型(model)－视图(view)－<a href="https://www.baidu.com/s?wd=%E6%8E%A7%E5%88%B6%E5%99%A8&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nHP-Pv7bPW6LnHF9rynv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHDsrjb1P101" target="_blank" rel="noopener">控制器</a>(controller)的缩写，一种软件设计典范，用于组织代码用一种业务逻辑和数据显示分离的方法，这个方法的假设前提是如果业务逻辑被聚集到一个部件里面，而且界面和用户围绕数据的交互能被改进和个性化定制而不需要重新编写业务逻辑<a href="https://www.baidu.com/s?wd=MVC&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nHP-Pv7bPW6LnHF9rynv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHDsrjb1P101" target="_blank" rel="noopener">MVC</a>被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
<p>个人观点部分：<br><a href="https://www.baidu.com/s?wd=MVC&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nHP-Pv7bPW6LnHF9rynv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHDsrjb1P101" target="_blank" rel="noopener">MVC</a>也可以说是一个架构，无论架构还是设计模式也就离不开灵活性、重用性跟扩展性<br>Model-View-Control，可以看到，他的原则就是把一个项目分成三个部分，分别对项目中的三种元素进行拆解<br>Model：用于保存实体部分，保存了关于这个实体的某些算法功能、读写资料的功能<br>Control：顾名思义。<a href="https://www.baidu.com/s?wd=%E6%8E%A7%E5%88%B6%E5%99%A8&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nHP-Pv7bPW6LnHF9rynv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHDsrjb1P101" target="_blank" rel="noopener">控制器</a>就是将由View传来的任务分配给特定的Model去处理，再将处理完的结果返回到目地View。<br>View：用来将结果做显示。这是展现给用户看的一面<br>所以可以看到，只要遵循约定，Mdoel层中某个实体的输入输出算法需要改变或扩展的时候并不影响到Control跟View。而Control就像一个导航指针，作为Model跟View的中间桥梁，View则是象征着输出的部分。</p>
<p>另外还要遵循设计模式中的原则之一：要面向接口编程。这样才能谈得上其中一个元素的更改不会影响到另外两个元素。</p>
<p>最后再次引用<a href="https://www.baidu.com/s?wd=%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nHP-Pv7bPW6LnHF9rynv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHDsrjb1P101" target="_blank" rel="noopener">百度百科</a>：MVC使开发和维护用户接口的技术含量降低。　分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。</p>
<p>原来以前做java大作业的时候，为了更好地设计程序架构，我自己无意间就实现了MVC模式..不过因为那时不知道，我把M叫底层，V叫表层，C叫数据传输   考虑到iOS， View组件：*.stroyboard等 Controller组件：View组件由ViewController来负责加载管理 Model组件：『数据，底层』</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>IOS开发</category>
      </categories>
  </entry>
  <entry>
    <title>OC-4</title>
    <url>/2016/08/12/oc-4/</url>
    <content><![CDATA[<p>OC学习过程中的笔记</p>
<p>1、 NSString *str = @”Hello OC~~~”;</p>
<p>  NSLog(@”%@”,str);</p>
<p>只要输出一个字符串，则必须在””前加@。（只输出一个格式控制符也叫一个字符串 两个双引号出现就是一个字符串）</p>
<p>NSString的格式标识符为%@ 故如此输出</p>
<p>2、应该这么理解方法定义：</p>
<p>-(void) setWord1:(NSString <em>) word1 setWord2:(NSString </em>) word2</p>
 <a id="more"></a>
<p>“setWord1:setWord2:”是方法名，word1和word2是参数名。你所谓的参数2的名称（setWord2）其实是方法名的一部分，而不是参数名。objective-c的发明者希望方法名读起来像一个通顺的句子，结合这点来理解方法定义，就不会对objective-c怪异的语法感到困惑了。</p>
<p>例如，定义一个求两个数的和的方法，</p>
<p>-(float) addNumber1:(float)num1 toNumber2:(float)num2;</p>
<p>方法名“addNumber1:toNumber2:”读起来就像一个通顺的句子。</p>
<p>3、OC中self 类似于 java中的this</p>
<p>①OC没有私有成员，而是通过接口与实现两部分的方式来实现封装，在实现中定义接口没有的成员即为私有成员（仅供该类使用 不提供给子类及外部使用）</p>
<p>②使用interface声明的成员变量是只能在自己类和子类使用的（oc的默认访问权限是protected），而不能在类的外部使用，（就是通过类名. 点的方式是显示不出来的），pproperty则相反，它可以在类的外部访问，在类的内部可以通过下划线+变量名或者self.变量名的方式来访问。</p>
<p>③@property给默认访问权限的成员变量提供了一套getter和setter给外界 并且可以使用点语法</p>
<p>④另可使用访问控制符</p>
<p>但注意myWorld是指向对象的该对象的类的类型的引用，在使用的时候不能用点语法 而是用-&gt;  eg:myWORLD-&gt;cc</p>
<p>而对property定义的变量 外部调用只能用点语法不能用-&gt;</p>
<p>-&gt;是直接调用改成员 （因为property定义的是私有变量，所以不能直接调用），而点语法是调用getter setter方法</p>
<p>OC是不推荐成员变量即使是用公共访问控制符访问的，所以在其它语言中很常用的.语法 ，在OC中只给@property定义的变量提供</p>
<p>（property定义的变量可以使用点语法 默认调用setter getter方法）</p>
<p>这体现了oc良好的封装性，需要与外界交互的变量全权由property负责定义 等。</p>
<p>property 字面意思—属性 理解之</p>
<p>【注意property不只是可以定义基本类型，还可以定义对象，声明委托等等】</p>
<p>对于通过property与interface定义变量的两种定义方法的理解</p>
<p>见我的个人网站OC1文章 ，详细解释@interface @property两种定义变量的方法</p>
<p>当然 也可以用访问控制符来实现</p>
<p>@private 本类</p>
<p>@public</p>
<p>@protected 本类及子类</p>
<p>@package</p>
<p>当然也有getter setter oc为了简便，提供了合成存取方法 @property @synthesize</p>
<p>注意 @property int abc 后 实际上的成员变量为_abc 自动加了下划线请注意 （但是 在外部运用点语法的时候，依然使用xxx.abc而不是xxx.底层成员变量，相当于套了一层引用，我觉得可以叫表层成员变量）  可以通过synthesize的参数来修改</p>
<p>若@synthesize name 则默认等效于@synthesize name=name</p>
<p>此时 就可以直接运用点语法了</p>
<p>以下资料来自百度</p>
<p>『当定义了一系列的变量时，需要写很多的getter和setter方法，而且它们的形式都是差不多的，所以Xcode提供了@property和@synthesize属性，@property用在 .h 头文件中用作声明，@synthesize用在.m 文件中用于实现。</p>
<p>在X-code4.5以前，在.h中声明完属性之后，如：</p>
<p>@property（nonatomic，assign) int age;</p>
<p>@property（nonatomic，assign) NSString *name;</p>
<p>需要在.m中写上</p>
<p>@synthesize int age;</p>
<p>@synthesize NSString *name;</p>
<p>系统会自动去实现setter和getter方法</p>
<p>而在X-code4.5之后，@synthesize就不需要再写了，系统会直接去实现setter和getter方法。</p>
<p>【补充：但是 若要自己重写setter 或getter方法 则必须在实现部分声明@synthesize 注意 若@synthesize name则等效于把name的底层变量从_name修改成了name要注意】</p>
<p>另外，声明完property属性之后，会自动生成下划线，如_age、_name；如果不想要下划线，那么就可以使用@synthesize去修饰，例如，在.m中写@synthesize age；那么_age就会变成age』</p>
<p>4、一些习俗</p>
<p>接口部分和实现部分通常放到两个文件中（接口.h 实现.m）</p>
<p>成员变量通常加一个下划线用_a 参数用a</p>
<p>库前两个大写字母加特殊标识 一般表公司</p>
<p>5、@interface helloworld:NSObject</p>
<p>任何类都继承于NSObject 在没有其它父类的时候必须标明</p>
<p>6、OC中不存在类变量，但存在类方法，可以定义一个全局变量（static）（在实现部分）然后通过类似于getMethod 定义一个类方法返回该变量，称之为模拟类变量</p>
<p>7、OC须手动装箱</p>
<p>NSNumber 方法：numberWithXxx initWithXxx xxxValue</p>
<p>自动装箱不支持ARC</p>
<p>【补充：装箱的意义：将基本类型装箱成对象， 便于将『基本类型元素』储存在像集合这种只能储存对象的结构】</p>
<p>8、只要涉及对象 都要@ 而且是建立一个引用指向对象 故</p>
<p>ABC<em> q = xxx 要打</em> 是一个指针</p>
<p>9、（A）oc中也有类似于java中的toString方法———description</p>
<p>该方法为NSObject的方法 重写该方法以实现功能（打印对象）</p>
<p>直接输出该对象等于调用该方法</p>
<p>一般重写该方法用于告诉外界该对象所具有的状态信息</p>
<p>该方法返回值为NSString*</p>
<p> （B）oc中也有java中字符串的一些特性</p>
<p>比如  常量池保证相同的字符串直接量只有一个，不会产生多个副本，即两个指针指向同一个常量池中的对象，而可以用stringWithFormat方法（类似于java中的stringBuffer）将字符串对象创建在运行时内存区（堆内存）中。</p>
<p>[NSString stringWithFormat:”abc”]</p>
<p> （C）同java一样，==可以判断基本类型相等和指针地址相等（包括指向对象的引用 故判断字符串相等的时候要注意，需要用isEqualToString方法，注意NSObject的isEqual和==是等价的，经常需要重写）</p>
<p>10、nil相当于其它语言的NULL</p>
<p>11、OC中的『协议』相当于其它语言的接口</p>
<p>非正式协议通过类别和扩展实现 不强制实现所有方法</p>
<p>正式协议 @protocol 必须实现协议中所有方法</p>
<p>（但可以用@optional @required（默认）来改变）</p>
<p>使用协议定义的方法只可调用该协议中声明的[方法]，且只有两种定义语法 [用此方法来限定只能调用该协议中声明的方法]</p>
<p>NSObject<protocol1,protocol2>* p;</protocol1,protocol2></p>
<p>id<p1,p2> p;</p1,p2></p>
<p>p是指向对象的变量名</p>
<p>类可继承多个协议 协议可继承多个协议</p>
<p>定义方法 使用方法见书</p>
<p>@protocol XXX<xxx2,xxx3></xxx2,xxx3></p>
<p>@end</p>
<p>对委托的理解 见OC-3</p>
<p>12、扩展即为匿名类别，但类别只能有方法，而扩展可以增加实例变量 用@property @synthesize等</p>
<p>13、NSString 是不可变类 字符串一旦生成则不可改变</p>
<p>可以用NSMutableString（NSString的子类） 该类定义的字符串可以改变（但需要用到方法如appendFormat insertString 等等）</p>
]]></content>
      <categories>
        <category>程序语言</category>
        <category>OC/SWIFT</category>
      </categories>
  </entry>
  <entry>
    <title>OC-3 delegate</title>
    <url>/2016/08/08/OC-3%20delegate/</url>
    <content><![CDATA[<p>委托是协议的沿用，委托简单的理解就是某人委托某人去做某事，这个和java中的接口回调机制比较相似。委托在IOS开发中比较常用，比如我们不知道一个列表中的数据有多少，我们可以用委托的方式，将数据委托给其他类，让其他类去填充数据。委托的常用功能主要是传值和事件监听。</p>
<p>我们下面使用委托来实现2个类的委托，即老师委托学生去买本《OC开发》。</p>
<p>用来实现委托的协议(BuyBookDelegate.h)</p>
<p>@protocol BuyBookDelegate<br>//定义一个委托协议，协议中只有一个方法，用来买书<br>-(void)buyBook:(NSString*)name;<br>@end</p>
 <a id="more"></a>
<p>老师类</p>
<h1 id="import"><a href="#import" class="headerlink" title="import "></a>import <foundation foundation.h=""></foundation></h1><h1 id="import-“BuyBookDelegate-h”"><a href="#import-“BuyBookDelegate-h”" class="headerlink" title="import “BuyBookDelegate.h”"></a>import “BuyBookDelegate.h”</h1><p>@interface Teacher : NSObject<br>//定义一个委托协议<br>@property (nonatomic,assign)id<buybookdelegate> buyBookDele;<br>//定义一个老师想让学生买书的方法<br>-(void)willBuyBook:(NSString*)bookName;<br>@end</buybookdelegate></p>
<h1 id="import-“Teacher-h”"><a href="#import-“Teacher-h”" class="headerlink" title="import “Teacher.h”"></a>import “Teacher.h”</h1><p>@implementation Teacher<br>-(void)willBuyBook:(NSString*)bookName{<br>​    NSLog(@”老师想买本《%@》”,bookName);<br>​    [_buyBookDele buyBook:bookName];<br>}<br>@end</p>
<p>学生类</p>
<h1 id="import-1"><a href="#import-1" class="headerlink" title="import "></a>import <foundation foundation.h=""></foundation></h1><h1 id="import-“Teacher-h”-1"><a href="#import-“Teacher-h”-1" class="headerlink" title="import “Teacher.h”"></a>import “Teacher.h”</h1><p>@interface Student : NSObject <buybookdelegate><br>@end</buybookdelegate></p>
<h1 id="import-“Student-h”"><a href="#import-“Student-h”" class="headerlink" title="import “Student.h”"></a>import “Student.h”</h1><p>@implementation Student<br>-(void)buyBook:(NSString *)name{<br>​    NSLog(@”学生去买《%@》”,name);<br>}<br>@end</p>
<p>测试：</p>
<h1 id="import-2"><a href="#import-2" class="headerlink" title="import "></a>import <foundation foundation.h=""></foundation></h1><h1 id="import-“Teacher-h”-2"><a href="#import-“Teacher-h”-2" class="headerlink" title="import “Teacher.h”"></a>import “Teacher.h”</h1><h1 id="import-“Student-h”-1"><a href="#import-“Student-h”-1" class="headerlink" title="import “Student.h”"></a>import “Student.h”</h1><p>int main(int argc, const char <em> argv[]) {<br>​    @autoreleasepool {<br>​        Teacher</em> teacher = [[Teacher alloc]init];<br>​        Student* student = [[Student alloc]init];<br>​        //为老师设置委托的对象<br>​        [teacher setBuyBookDele:student];<br>​        //老师要买书了<br>​        [teacher willBuyBook:@”OC开发”];<br>​    }<br>​    return 0;<br>}</p>
<p>结果：</p>
<p><strong>老师想买本《**</strong>OC<strong>**开发》</strong></p>
<p><strong> </strong>学生去买《<strong>**OC</strong>开发》**</p>
<p>转载自<a href="http://m.blog.csdn.net/article/details?id=41827599" target="_blank" rel="noopener">http://m.blog.csdn.net/article/details?id=41827599</a></p>
]]></content>
      <categories>
        <category>程序语言</category>
        <category>OC/SWIFT</category>
      </categories>
  </entry>
  <entry>
    <title>OC-2 invalid operands to binary expression ('NSString *' and 'NSString *')q</title>
    <url>/2016/07/31/oc-2-invalid-operands-to-binary-expression-nsstring-and-nsstring-q/</url>
    <content><![CDATA[<p>Q： I have the following code:</p>
<pre><code>NSString  *String=TextField1.text + TextField2.text 
</code></pre><p>its giving the error: <code>-invalid operands to binary expression (&#39;NSString *&#39; and &#39;NSString *&#39;)</code>   An:</p>
 <a id="more"></a>
<p>You cannot do it this way, because objective-c doesn’t use ‘+’ operator for concatenation This way should work:</p>
<pre><code>NSString *concat = [NSString stringWithFormat@&quot;%@%@&quot;, TextField1.text, TextField2.text];
</code></pre><p>or</p>
<pre><code>NSString *concat = [TextField1.text stringByAppendingString:TextField2.text];
</code></pre><p>Hope this works for you ;)</p>
<pre><code>from stackoverflow
</code></pre>]]></content>
      <categories>
        <category>程序语言</category>
        <category>OC/SWIFT</category>
      </categories>
  </entry>
  <entry>
    <title>OC 1</title>
    <url>/2016/07/30/oc-1/</url>
    <content><![CDATA[<p><strong>**1、oc的默认访问权限：变量是protected，函数是public</strong></p>
<p>@property给默认访问权限的成员变量提供了一套getter和setter给外界</p>
<p>封装</p>
<p>2、</p>
<p>一直有疑问，在objective_C中声明变量会有 2种方式，今天有空和网友讨论了下，并且自己查了stackoverflew后算是稍微弄懂了一点。记录如下：</p>
<p>用了一段oc；会发现有2种定义变量的方式</p>
<p>1.在  @interface :NSObject{} 的括号中，当然NSObject 是指一个父类，可以是其他的。</p>
 <a id="more"></a>
<p>形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @interface GCTurnBasedMatchHelper : NSObject &#123;</span><br><span class="line">2 BOOL gameCenterAvailable;</span><br><span class="line">3 BOOL userAuthenticated;</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure>
<p>2.另外一种是直接在 @interface : NSObject{}括号之后，用 @property 去定义一个变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @property (assign, readonly) BOOL gameCenterAvailable;</span><br></pre></td></tr></table></figure>
<p>你会发现，有人会再@interface中定义了变量后，又在 @property中重复定义相同的变量，而且很常见。</p>
<p>结果可能是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @interface GCTurnBasedMatchHelper : NSObject &#123;</span><br><span class="line">2 BOOL gameCenterAvailable;</span><br><span class="line">3 BOOL userAuthenticated;</span><br><span class="line">4 &#125;</span><br><span class="line">5 </span><br><span class="line">6 @property (assign, readonly) BOOL gameCenterAvailable;</span><br></pre></td></tr></table></figure>
<p>而且你可以单独在@interface中定义变量，而不用@property定义；也可以只用@property去定义，而不在@interface中定义，当然用了@property去定义，一般要在.m文件中用@synthsize去合成相应的setter，getter方法。否则会得到一个警告。当然@synthsize是可选的，但是是Apple推荐的，不用会有什么后果，我没试过，有兴趣的童鞋可以试一下。</p>
<p>那这两种方式有什么区别呢。</p>
<p>\1. 只在@interface中定义变量的话，你所定义的变量只能在当前的类中访问，在其他类中是访问不了的；而用@property声明的变量可以在外部访问。</p>
<p>2.用了@property去声明的变量，可以使用“self.变量名”的方式去读写变量。而用@interface的方式就不可以。</p>
<p>\3.  这里给出一个链接：<a href="http://stackoverflow.com/questions/9702258/difference-between-properties-and-variables-in-ios-header-file" target="_blank" rel="noopener">http://stackoverflow.com/questions/9702258/difference-between-properties-and-variables-in-ios-header-file</a>    里面讲到：  我英语菜，简单翻一下：</p>
<p>Defining the variables in the brackets simply declares them instance variables.</p>
<p>在括号中定义一个变量只是简单的声明了一个实例变量（实例变量应该指的成员变量）。  博主注：老外对variable 和instance variable是有不同理解的。所以下文中 用了一个模糊的词 ivar。</p>
<p>Declaring (and synthesizing) a property generates getters and setters for the instance variable, according to the criteria within the parenthesis. This is particularly important in Objective-C because it is often by way of getters and setters that memory is managed (e.g., when a value is assigned to an ivar, it is by way of the setter that the object assigned is retained and ultimately released). Beyond a memory management strategy, the practice also promotes encapsulation and reduces the amount of trivial code that would otherwise be required.</p>
<p>声明（和 @synthsize）一个属性会为成员变量生成 getter 和setter方法，根据括号内的标准,在oc中经常用setter和getter 做内存管理，这是很重要的。（例如： 当一个值被赋给这个变量，对象是通过setter函数去分配，修改计数器，并最后释放的）。更高一个层次来说，这种做法也促进了封装，减少了一些不必要的代码。</p>
<p>It is very common to declare an ivar in brackets and then an associated property (as in your example), but that isn’t strictly necessary. Defining the property and synthesizing is all that’s required, because synthesizing the property implicitly also creates an ivar.</p>
<p>在@interface括号中定义一个变量并用@property 重复定义一次是很普遍的，实际上不是必要的。用@property和@synthszie就够了，因为在用@synthsize合成这个属性的读写方法时就会创建一个变量。</p>
<p>The approach currently suggested by Apple (in templates) is:</p>
<p>目前苹果（在模板中）建议的方法是这样的：</p>
<p>-Define property in header file, e.g.:</p>
<p>先在头文件中定义一个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @property int gameCenter;</span><br></pre></td></tr></table></figure>
<p>Then synthesize &amp; declare ivar in implementation:</p>
<p>然后在实现文件中  synthsize和declare成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @synthesize gameCenter = __ gameCenter;</span><br></pre></td></tr></table></figure>
<p>The last line synthesizes the gameCenter property and asserts that whatever value is assigned to the property will be stored in the __gameCenter ivar. Again, this isn’t necessary, but by defining the ivar next to the synthesizer, you are reducing the locations where you have to type the name of the ivar while still explicitly naming it.</p>
<p>最后一行synthsize  gameCenter 属性并说明了不管什么值被分配给这个属性，都会存储到_gameCenter这个变量中。 再次说明，这不是必要的，但是，这样写了之后，你能减少输入已经明确命名的变量名。</p>
<p>最后一句的意思you are reducing the locations where you have to type the name of the ivar while still explicitly naming it .不好翻。</p>
<p>据千锋的第2节语法课课程的讲解，这样写之后可以使得 @synthsize 时内部getter方法会展成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 -(int)gameCenter</span><br><span class="line">2 &#123;</span><br><span class="line">3    return  _gameCenter;</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure>
<p>而直接写  @synthsize  gameCenter；</p>
<p>setter函数会在内部展开成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 -(int)gameCenter</span><br><span class="line">2 &#123;</span><br><span class="line">3    return  gameCenter;</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure>
<p>注意到：函数名和变量名是一样的。在斯坦福的课程中，白胡子教授也模糊的说道这样的同名有可能带来bug，具体什么bug他没说，我也没见过，所以还是养成这样写的习惯为好。其他语言的getter函数  一般会在变量前加 get；但oc没有，可能是为了与其他语言做区分，算是oc的特色，结果却带来这么个麻烦。</p>
<p>转载自<a href="http://www.cnblogs.com/letmefly/archive/2012/07/20/2601338.html" target="_blank" rel="noopener">http://www.cnblogs.com/letmefly/archive/2012/07/20/2601338.html</a></p>
]]></content>
      <categories>
        <category>程序语言</category>
        <category>OC/SWIFT</category>
      </categories>
  </entry>
  <entry>
    <title>终于考完了 进入苦逼的小学期</title>
    <url>/2016/07/05/%E7%BB%88%E4%BA%8E%E8%80%83%E5%AE%8C%E4%BA%86%20%E8%BF%9B%E5%85%A5%E8%8B%A6%E9%80%BC%E7%9A%84%E5%B0%8F%E5%AD%A6%E6%9C%9F/</url>
    <content><![CDATA[<p>先来局屁股</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>...</title>
    <url>/2016/05/18/113/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>不要让你的生命留下太多遗憾</title>
    <url>/2016/05/09/%E4%B8%8D%E8%A6%81%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E7%95%99%E4%B8%8B%E5%A4%AA%E5%A4%9A%E9%81%97%E6%86%BE/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>TestMovie</title>
    <url>/2016/05/09/TestMovie/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>链表，栈，队列、树四种结构的构建方式的简单理解</title>
    <url>/2016/05/07/%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97%E3%80%81%E6%A0%91%E5%9B%9B%E7%A7%8D%E7%BB%93%E6%9E%84%E7%9A%84%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>开个坑，有空填，方便自己考前速看一下</p>
<hr>
<p>两种储存结构 链式和顺式</p>
<p>比较一下链表的链式储存结构、栈和队列的顺式储存结构（不代表他们只有链式/顺式，只是着重强调）</p>
<p>假设所有的储存数据都是int型</p>
<ul>
<li>顺序栈的结构构建</li>
</ul>
<p>两个参数：初始容量、每次增加的容量</p>
<p>struct stack</p>
<p>{</p>
<p>int <em>base,</em>top;</p>
<p>int length;</p>
<p>};</p>
  <a id="more"></a>
<p>base指向栈底，top指向栈顶</p>
<p>length表明现在栈的容量</p>
<p>初始化的时候，需要初始化一个初始容量大小的空间。base指向第一个位置，top指向顶位置</p>
<p>base和top是指针，代表指向的位置，<strong>要储存的数据储存在『top指针当时指向的那一个位置』</strong></p>
<p>当到达栈顶，开辟新空间</p>
<ul>
<li>循环队列的结构构建</li>
</ul>
<p>参数： 最大容量</p>
<p>struct queen</p>
<p>{</p>
<p>int *base;</p>
<p>int front,rear;</p>
<p>};</p>
<p>其实顺序结构实际上是个数组。数组和指针在用法上有非常多的相似，这里用指针的操作方式建立了一个数组，</p>
<p>base是指向数组头的指针；base手动开辟一段最大容量大小的空间</p>
<p>front和rear是数组的下标，front在第一位数，rear在最后一个存放数据的位置的后一位</p>
<p><strong>要储存的内容即存放在该数组中</strong></p>
<p>这里，可以使用数组操作了。 比如base[a]</p>
<p>front-base即为队列长度</p>
<p>但是对于普通的一长列，可以用后-前来算长度，但由于这是循环的队列，所以有一些数学上的东西要修正：</p>
<p>若为不循环的表，b在a后面，那么b-a即可</p>
<p>若为一个循环列表 a到b中间空了多少格？</p>
<p>1、假设b在a前面，那么这就尴尬了。b-a为负数，这时候求个补，即加一个总长，b-a+length，这时候假设2-4=-2 ，那么就变成了-2+6（总长）=4，这即为他们之间的距离（注意：距离是朝顺方向的距离）。但是如果b-a&gt;0的话，这tm就又尴尬了，4-2+6=8了，再结合2、处理</p>
<p>2、若为一个循环链表，一个数到达顶端了要跳回第一个数怎么处理？</p>
<p>对它加一然后求余即可，故在循环链表中，表示一个数进一位用（a+1）%length表示。对于循环列表中的数，下标%length即为其该在的位置</p>
<ul>
<li>链表</li>
</ul>
<p>struct linknode</p>
<p>{</p>
<p>int data;</p>
<p>int *next;</p>
<p>};</p>
<p><strong>链表的内容储存在每一个节点中，每一个节点都是一个struct，而栈和队列都只有一个struct，即为栈、队列本身。</strong></p>
<p>串珠子，很容易理解</p>
<p>{对所有数据结构}一个易错点，struct sim;在主函数创建一个 sim a 还是 sim* a 要注意，两者皆可以但用法不同</p>
<p>建议链式结构 sim*a  顺式结构 sim a</p>
<ul>
<li>二叉树</li>
</ul>
<p>栈的递归运用之–二叉树</p>
<p>注意这里和链表的感觉很像，实则不然，创建方式和遍历方式是不同的，栈的创建需要至少两个指针p，q，像爬梯子一样创建。而二叉树的创建只需要一个根，然后递归创建</p>
<p>TBC</p>
<p><img src="http://aisakaki.com/wp-content/uploads/2016/05/image-2-300x298.jpeg" alt="image"></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>VMware虚拟机ping不通主机</title>
    <url>/2016/05/03/VMware%E8%99%9A%E6%8B%9F%E6%9C%BAping%E4%B8%8D%E9%80%9A%E4%B8%BB%E6%9C%BA/</url>
    <content><![CDATA[<p>待解决  </p>
<hr>
<p>5月4日更新 </p>
<p>问题解决了 <img src="http://aisakaki.com/wp-content/uploads/2016/05/image-2-300x298.jpeg" alt="image"> 使用桥接模式需要dhclient自动获取IP地址………..</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>Test image</title>
    <url>/2016/05/01/test-image/</url>
    <content><![CDATA[<p><img src="http://aisakaki.com/wp-content/uploads/2016/05/image-1.jpeg" alt="image"> 一脸懵逼</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>Sever.</title>
    <url>/2016/04/30/sever/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2016/04/30/hello-world-2/</url>
    <content><![CDATA[<p>from aisaka</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
</search>
